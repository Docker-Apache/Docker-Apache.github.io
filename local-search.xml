<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/Curricula/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A7%91%E6%8A%80%E4%BC%A6%E7%90%86/"/>
    <url>/2022/02/12/Curricula/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A7%91%E6%8A%80%E4%BC%A6%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-人工智能时代的科技伦理"><a href="#1-人工智能时代的科技伦理" class="headerlink" title="1 人工智能时代的科技伦理"></a>1 人工智能时代的科技伦理</h1><h2 id="1-1-人工智能"><a href="#1-1-人工智能" class="headerlink" title="1.1 人工智能"></a>1.1 人工智能</h2><h3 id="1-1-1-三大挑战"><a href="#1-1-1-三大挑战" class="headerlink" title="1.1.1 三大挑战"></a>1.1.1 三大挑战</h3><p>人工智能只能处理特定边界的问题，目前，人工智能面临烦人三大挑战分别是：<strong>综合认知的能力、理解他人的能力和自我决定的能力。</strong></p><ul><li>人工智能无法回答跨界问题、常识问题</li><li>无法回答需要因人而异、体察人情的问题</li><li>不会做这样的决定，因为它并没有对于自我的了解、自我的认知</li><li>这种能够从自己出发做决定的能力，也能够看得出来人工智能和人的区别。</li></ul><p>综合认知的能力：现在的深度学习网络，一个网络只能够学习一件事情，这在科学界被称为<strong>遗忘的灾难</strong>。一个这样的人工智能只能干一件事情，不可能像我们人一样有通识的能力，这是人类和人工智能很大的不同，人是触类旁通的。</p><p>理解他人的能力：现在是有一些人工智能和人的语言对话，但自然语言处理仍然还是一个难题，只有在特定领域的专业问答，才可以有比较好的答案匹配，</p><p>自我决定的能力：需要两个方面的突破，一是自我表征的能力，人工智能需要能够自己说出来，我做这个事情是为什么；此外，人工智能没有自我意识。</p><p>人工智能最大的威胁，并不是取代工作，它们会取代一部分工作，但是他们会制造出更多更多的就业岗位。<strong>“人工智能对我们最大的威胁就在于，当我们过于依赖很多的数据系统以后，我们自己如果变得懒于思考、懒于自我反思，而让我们自己的智慧退化的话，这是对人类最大的威胁。”</strong> —— 中国科幻作家、第74届雨果奖获得者郝景芳</p><h3 id="1-1-2-通用人工智能-AGI"><a href="#1-1-2-通用人工智能-AGI" class="headerlink" title="1.1.2 通用人工智能 AGI"></a>1.1.2 通用人工智能 AGI</h3><p>真正的人工智能是 AGI（Artificial General Intelligence），即通用人工智能。人的智能是通用智能，人类经过学习可以做任何事情。人工智能要达到像人类一样的通用智能，才谈得上是真正的人工智能。通用人工智能如何实现以及何时实现，都还是个未知数。</p><h2 id="1-2-人工智能时代的科技伦理"><a href="#1-2-人工智能时代的科技伦理" class="headerlink" title="1.2 人工智能时代的科技伦理"></a>1.2 人工智能时代的科技伦理</h2><h3 id="1-2-1-科技向善"><a href="#1-2-1-科技向善" class="headerlink" title="1.2.1 科技向善"></a>1.2.1 科技向善</h3><h4 id="科技伦理为科技创新及其应用划定底线和边界以指明科技向善的发展方向"><a href="#科技伦理为科技创新及其应用划定底线和边界以指明科技向善的发展方向" class="headerlink" title="科技伦理为科技创新及其应用划定底线和边界以指明科技向善的发展方向"></a>科技伦理为科技创新及其应用划定底线和边界以指明科技向善的发展方向</h4><p>对于未来可能出现的通用人工智能和超级人工智能，如果不加约束地发展应用，就有可能威胁到人类整体的利益。国际社会已在积极推动AI伦理研究并争取最大范围的共识。因此，亟需为新技术应用划定伦理底线和边界，以确保向善的发展方向。</p><ul><li>一方面，科技伦理可以使科学技术的应用得到明确的道德理性的引导，从而最大限度地减少出于邪恶目的利用科技成果的可能性</li><li>另一方面，作为道德理性的科技伦理又可以弥补单纯的科技理性之不足，增强科技工作者对于科技开发之后果的道德责任感，从而以道德理性的自觉来最大限度地消解科技理性在社会负面作用上的不自觉。</li></ul><h3 id="1-2-2-自律作用"><a href="#1-2-2-自律作用" class="headerlink" title="1.2.2 自律作用"></a>1.2.2 自律作用</h3><h4 id="科技伦理在人工智能技术的治理中发挥越来越重要的软法规约作用"><a href="#科技伦理在人工智能技术的治理中发挥越来越重要的软法规约作用" class="headerlink" title="科技伦理在人工智能技术的治理中发挥越来越重要的软法规约作用"></a>科技伦理在人工智能技术的治理中发挥越来越重要的软法规约作用</h4><p>北京大学法学院教授、副院长薛军在《数字经济立法与执法应当审慎、包容》一文中所言，由于技术以及商业模式快速发展和迭代，草率的立法，不可能期待会产生正面的效果；除了法律之外，也完全可以通过国家标准、行业公约、最佳实践、技术指南等“软法”性质的规范来调整数字经济领域的事项。</p><p>因此，<strong>作为对技术应用的“软法”规制，可以通过科技伦理来对科技行业的狭隘的技术向度和利益局限进行矫正。</strong></p><p>另一方面，<strong>科技伦理水平直接衡量着科技发展的成熟度，完善的科技伦理制度意味着能够更好地防范、缓解科技发展应用带来的负面影响，从而营造积极健康的发展氛围</strong></p><p><strong>国外：</strong>近几年来，谷歌、微软、Facebook、DeepMind 等科技公司多举措加强人工智能伦理的自律建设，包括发起成立行业组织（比如 Partnership on AI），成立伦理部门（比如伦理委员会），提出人工智能伦理和技术相关的原则、准则、指南、最佳实践等，加强人工智能伦理与社会研究。</p><p><strong>国内：</strong>当前需要加强科技伦理的制度化建设，发挥科技伦理的行业自律作用，通过伦理审查、自律组织、行业标准、最佳实践、技术指南等方式来支持、促进行业自律，以确保科技发展应用的正确方向。而立法与执法应当坚持审慎、包容的指导思想。</p><h3 id="1-2-3-数字福祉"><a href="#1-2-3-数字福祉" class="headerlink" title="1.2.3 数字福祉"></a>1.2.3 数字福祉</h3><h4 id="科技伦理推动互联网发展从获取用户注意力向促进用户数字福祉转变"><a href="#科技伦理推动互联网发展从获取用户注意力向促进用户数字福祉转变" class="headerlink" title="科技伦理推动互联网发展从获取用户注意力向促进用户数字福祉转变"></a>科技伦理推动互联网发展从获取用户注意力向促进用户数字福祉转变</h4><p>相关研究已经开始思考数字技术可能会对我们的健康、思维、自主性等产生什么样的负面影响，尤其是数字技术对未成年人的潜在影响。此外，随着个性化推荐算法在互联网领域的广泛应用，人们也开始担心推荐算法也可能给用户带来网络过度使用、信息茧房、算法偏见等负面影响。</p><p>比如，限制用户对信息的自由选择，将用户置于算法建立起来的泡沫之中，只接触到自己喜欢或认同的内容，从而可能给用户造成信息茧房、自我封闭和偏见，进而影响用户的思维模式并可能扭曲用户的认知，并不利于用户的长远发展。</p><p><strong>数字福祉（Digital Wellbeing）有两大内涵</strong></p><ul><li>一方面，人人都可享受到数字技术带来的便利和红利，最大化地实现普惠和赋能</li><li>另一方面，促进个人对数字技术和网络服务的高质量使用，减小、防止数字技术对个人的负面影响</li></ul><p>例如，iOS 12推出了 “屏幕使用时间” 功能，同样意在帮助用户将手机和网络使用控制在合理的限度，防止过度使用。Facebook 则发布了“数字福祉”工具，允许用户监测自己花在社交网络上的时间并设定时长限制，同时更容易地关闭推送通知。</p><h3 id="1-2-4-数字信任"><a href="#1-2-4-数字信任" class="headerlink" title="1.2.4 数字信任"></a>1.2.4 数字信任</h3><h4 id="科技伦理最终是要实现数字信任，践行科技向善"><a href="#科技伦理最终是要实现数字信任，践行科技向善" class="headerlink" title="科技伦理最终是要实现数字信任，践行科技向善"></a>科技伦理最终是要实现数字信任，践行科技向善</h4><p><strong>信任是一切社会的基础，数字信任是数字社会的基础。</strong>需要依靠社会习俗、伦理道德、法律规范等一起来协同构建，以保障数字经济社会的健康发展。</p><p>数字信任体现在四个维度</p><ul><li>安全的维度，产品服务安全可靠，包括网络安全、个人隐私安全等</li><li>透明的维度，保障用户的参与和知情</li><li>责任的维度，确保相关主体负责任地提供产品服务，并为其行为承担责任</li><li>伦理的维度，秉持正确的价值观，不作恶。在数字文明下，科技伦理旨在维护、促进数字信任，呼吁践行科技向善，让大数据、人工智能等数字技术最大程度地造福于人类和人类社会</li></ul><p>在人工智能研发应用方面，<strong>腾讯提出并倡导人工智能“四可”理念，即可用、可靠、可知、可控（英文简写为 ARCC，寓意“方舟”）。</strong>正如传说中拯救人类文明的诺亚方舟一样，人工智能领域的 ARCC 也将在未来的人工智能时代尤其是可能到来的 AGI 和 ASI 时代，确保人类与机器之间友好、和谐的关系，最大化地促进人类的发展，并避免潜在负面影响。</p><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p><strong>科技伦理是创新驱动发展战略、数字中国建设、数字时代商业竞争的重要保障。</strong></p><p><strong>科技创新是手段，科技伦理是保障，科技向善是目的，三者配合才能确保科技向善的发展方向，最大化促进人类福祉。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E6%91%98%E8%A6%81/"/>
    <url>/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>客户流失的意义</li><li>流式因素</li><li>决策树和随机森林的结果对比</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Paragraph-1"><a href="#Paragraph-1" class="headerlink" title="Paragraph 1"></a>Paragraph 1</h3><ul><li>客户流失是什么</li><li>预防客户流式流失的益处、方法</li><li>引用决策树和随机森林的文献</li></ul><h3 id="Paragraph-2"><a href="#Paragraph-2" class="headerlink" title="Paragraph 2"></a>Paragraph 2</h3><ul><li>数据集的组成</li><li>流失因素的分析</li></ul><h3 id="Paragraph-3"><a href="#Paragraph-3" class="headerlink" title="Paragraph 3"></a>Paragraph 3</h3><ul><li>使用两个算法分析流失因素</li></ul><h3 id="Paragraph-4"><a href="#Paragraph-4" class="headerlink" title="Paragraph 4"></a>Paragraph 4</h3><ul><li>文章结构</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>根据挖掘任务可分为五种:分类与回归、聚类分析、关联分析、时间序列分析和偏差检测。在数据库挖掘中，C4.5（决策树算法），遗传算法等，其中决策树方法与神经网络方法是其关键方法。<br>而挖掘方法又可以分为：机器学习方法、统计方法、神经网络方法。机器学习中，可细分为：归纳学习方法（决策树、规则归纳等）、基于范例学习、遗传算法等。统计方法中，可细分为：回归分析（多元回归、自回归等）、判别分析（贝叶斯判别、费歇尔判别、非参数判别等）、聚类分析（系统聚类、动态聚类等）、探索性分析（主元分析法、相关分析法等）等。神经网络方法中，可细分为：前向神经网络（BP 算法等）、自组织神经网络（自组织特征映射、竞争学习等）等。</p><h2 id="分类与回归"><a href="#分类与回归" class="headerlink" title="分类与回归"></a>分类与回归</h2><p>分类与回归都是<strong>对输入做出预测</strong>，并且<strong>都是监督学习</strong>。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>分类问题输出的是物体所属的类别，回归问题输出的是物体的值。</li><li>分类问题输出的值是离散的，回归问题输出的值是连续的。</li><li>分类问题输出的值是定性的，回归问题输出的值是定量的。</li><li>分类与回归问题可以相互转换。</li></ul><h3 id="决策树（Decision-Tree）"><a href="#决策树（Decision-Tree）" class="headerlink" title="决策树（Decision Tree）"></a>决策树（Decision Tree）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>学习时，利用训练数据，根据<strong>损失函数最小化</strong>的原则建立决策树模型。</li><li>预测时，对新的数据，利用决策树模型进行分类。其中每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。</li></ul><p><img src="C:\Users\11026\AppData\Roaming\Typora\typora-user-images\image-20220105092700193.png" alt="image-20220105092700193"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>简单直观，生成的决策树很直观。</p></li><li><p>基本不需要预处理，不需要提前归一化，处理缺失值。</p></li><li><p>使用决策树预测的代价是O(log2m)。 m为样本数。</p></li><li><p>既可以处理离散值也可以处理连续值。很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>相比于神经网络之类的黑盒分类模型，决策树在逻辑上可以得到很好的解释。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>决策树算法非常容易过拟合，导致泛化能力不强。可以通过设置节点最少样本数量和限制决策树深度来改进。</li><li>策树会因为样本发生一点点的改动（特别是在节点的末梢），导致树结构的剧烈改变。这个可以通过集成学习之类的方法解决。</li><li>寻找最优的决策树是一个NP难的问题，我们一般是通过启发式方法，容易陷入局部最优。可以通过集成学习之类的方法来改善。</li><li>有些比较复杂的关系，决策树很难学习，比如异或。这个就没有办法了，一般这种关系可以换神经网络分类方法来解决。</li><li>如果某些特征的样本比例过大，生成决策树容易偏向于这些特征。这个可以通过调节样本权重来改善。</li></ul><h4 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h4><p><strong>决策树学习的关键：</strong>如何选择最优划分属性（特征选择）。一般而言，随着划分过程不断进行，希望决策树的分支结点所包含的样本尽可能属于同一类别，即<strong>结点的 “纯度” (purity) 越高越好。</strong>学习过程包含以下三步：</p><ul><li>特征选择：从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法。</li><li>决策树生成： 根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。</li><li>剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有<strong>预剪枝</strong>和<strong>后剪枝</strong>两种。</li></ul><p><strong>基尼指数：</strong>总体内包含的类别越杂乱，GINI 指数就越大（跟熵的概念很相似）。</p><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>ID3 算法使用<strong>信息增益 Gain</strong> 准则来选择特征，递归的构建决策树。具体方法：从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征。</p><p><strong>缺点：</strong>信息增益准则偏向选择取值较多的属性。如果一个特征所取不同值的个数越多，则该特征就越可能用来做分裂点。最极端的情况就是该特征每个结果都对应一个不同的特征取值，那么，求得信息熵为0，信息增益最大。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><p>C4.5 算法不直接选择<strong>信息增益率</strong>最大的候选划分属性，候选划分属性中找出信息增益高于平均水平的属性（这样保证了大部分好的特征），再从中选择增益率最高的（又保证了不会出现编号特征这种极端的情况）。</p><h4 id="CART（Classification-And-Regression-Tree）"><a href="#CART（Classification-And-Regression-Tree）" class="headerlink" title="CART（Classification And Regression Tree）"></a>CART（Classification And Regression Tree）</h4><p>既可以做分类，也可以做回归。只能形成二叉树。<br>分支条件：二分类问题<br>分支方法：对于连续特征的情况：比较阈值，高于某个阈值就属于某一类，低于某个阈值属于另一类。对于离散特征：抽取子特征，比如颜值这个特征，有帅、丑、中等三个水平，可以先分为帅和不帅的，不帅的里面再分成丑和中等的。<br>得分函数（y）：就是上面提到的gt(x)，对于分类树取得是分类最多的那个结果（也即众数），对于回归树取得是均值。</p><p>损失函数：分类准则，也就是求最优化的准则</p><ul><li><p>对于分类树（目标变量为离散变量）：同一层所有分支假设函数的基尼系数的平均。</p></li><li><p>对于回归树（目标变量为连续变量）：同一层所有分支假设函数的平方差损失。</p></li></ul><p>分裂准则：</p><ul><li>对于分类树（目标变量为离散变量）：使用<strong>基尼指数（基尼不纯度）</strong>作为分裂规则。比较分裂前的 gini 和分裂后的 gini 减少多少，减少的越多，则选取该分裂规则。</li><li>对于回归树（目标变量为连续变量）：使用<strong>最小方差</strong>作为分裂规则。</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><thead><tr><th>算法</th><th>支持模型</th><th>树结构</th><th>特征选择</th><th>连续值处理</th><th>缺失值处理</th><th>剪枝</th></tr></thead><tbody><tr><td>ID3</td><td>分类</td><td>多叉树</td><td>信息增益</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>C4.5</td><td>分类</td><td>多叉树</td><td>信息增益率</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>CART</td><td>分类，回归</td><td>二叉树</td><td>基尼指数，均方差</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h4 id="国内外研究现状"><a href="#国内外研究现状" class="headerlink" title="国内外研究现状"></a>国内外研究现状</h4><p>Yoo et al. [1] 研究调查了使用基于深度学习的决策树分类器从 CXR 图像中检测 COVID-19 的可行性。所提出的分类器包括三个二元决策树，每个树都由一个基于 PyTorch 框架的带有卷积神经网络的深度学习模型训练。识别信息特征已成为数据挖掘的重要步骤，不仅可以规避维数灾难，还可以减少需要处理的数据量。Rao et al. [2] 提出了一种基于蜂群和梯度提升决策树的新特征选择方法，旨在解决所选特征的效率和信息质量等问题。传统的信息熵和皮尔逊相关系数通常被用作分裂规则的度量，以寻找最佳分裂属性。然而，这些方法无法衡量属性之间的关系和属性的无序程度。Li et al. [3] 提出邓熵作为分裂规则的度量来构建模糊数据集分类的证据决策树。与传统的BBA组合组合规则相比，证据决策树可以直接应用于分类，有效降低了算法的复杂度。</p><p>梯度提升决策树 (GBDT) 是一种流行的机器学习算法，并且有很多有效的实现，例如 XGBoost 和 pGBRT。但在特征维数高、数据量大的情况下，效率和可扩展性仍然不尽如人意。一个主要原因是对于每个特征，他们需要扫描所有的数据实例来估计所有可能的分割点的信息增益，这是非常耗时的。为了解决这个问题，Ke et al. [4] 提出了两种新技术：基于梯度的单侧采样（GOSS）和专有特征捆绑（EFB）。使用 GOSS，我们排除了很大一部分具有小梯度的数据实例，仅使用其余部分来估计信息增益。Velásquez et al [5] 根据大理石花纹程度对牛肉进行分类。通过400-1000 nm的高光谱成像系统在反射模式下扫描了总共35个样品的背最长肌。 选择528nm波长对样品和背景进行分割，440nm用于样品分类。 对感兴趣区域采用基于决策树方法的图像处理算法，在构建阶段获得0.08%的分类误差。</p><p>[1] <a href="https://www.semanticscholar.org/paper/f8cd8cc5ba09b2fef8bed86c5a53e3ae1d551b12">Deep Learning-Based Decision-Tree Classifier for COVID-19 Diagnosis From Chest X-ray Imaging</a></p><p>[2] <a href="https://www.semanticscholar.org/paper/484c4178ae2e60cb7ceb81de484335b3d19eaffa">Feature selection based on artificial bee colony and gradient boosting decision tree</a></p><p>[3] <a href="https://www.semanticscholar.org/paper/9eb04b5bb74ecc5781b62214b628813e9150196b">Evidential Decision Tree Based on Belief Entropy</a></p><p>[4] <a href="https://www.semanticscholar.org/paper/497e4b08279d69513e4d2313a7fd9a55dfb73273">LightGBM: A Highly Efficient Gradient Boosting Decision Tree</a></p><p>[5] <a href="https://www.semanticscholar.org/paper/feaa37c21048c7779ec3a722c5c3703ae500b2e6">An application based on the decision tree to classify the marbling of beef by hyperspectral imaging.</a></p><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><h3 id="K-means-聚类"><a href="#K-means-聚类" class="headerlink" title="K-means 聚类"></a>K-means 聚类</h3><h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><h3 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h3><h3 id="FP-growth-算法"><a href="#FP-growth-算法" class="headerlink" title="FP-growth 算法"></a>FP-growth 算法</h3><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h2 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h2><h2 id="偏差检测"><a href="#偏差检测" class="headerlink" title="偏差检测"></a>偏差检测</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/Introduction/"/>
    <url>/2022/02/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Customer Churn refers to that the company terminates the partnership with the customers, impeding the development of the company. Through the approaches of data analysis based on machine learning, predicting Customer Churn precisely is conducive to adjusting the business strategy of the corporation, which provides decision-making for the progress of the company. The key of data analysis is to select corresponding solution schemes on the basis of disparate data structures.</p><p>The methods of data analysis based on machine learning are employed in different application scenarios. </p><p>Different methods of data analysis based on machine learning are employed to address different problems, including classification, regression, time-series, clustering,  etc. Decision Tree and Random Forest are two methods commonly used for classification problems, which are both supervised learning methods.  Decision Tree (<a href="file:///C:/Users/zuo/Downloads/a9ccea8d.docx#_bookmark27">Charbuty and Abdulazeez</a>, <a href="file:///C:/Users/zuo/Downloads/a9ccea8d.docx#_bookmark27">2021</a>) provides a graphical representation of the relationship among different properties for classification tasks (Burez and Poel, 2007). predict Customer Churn and analyze the factors which cause Customer Churn (Balasubramanian and Selvarani, 2014)., Random Forest is </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/MySQL/%E7%AC%AC3%E7%AB%A0%20%20NoSQL/"/>
    <url>/2022/02/12/MySQL/%E7%AC%AC3%E7%AB%A0%20%20NoSQL/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>四种 NoSQL 类型</th><th>存取</th><th>时间复杂度</th><th>优缺点</th><th>应用场景</th><th>例子</th></tr></thead><tbody><tr><td>键值 数据库</td><td></td><td></td><td></td><td></td><td>Redis</td></tr><tr><td>文档型 数据库</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>列存储 数据库</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>图 数据库</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>NoSQL 非关系型数据库</p><p>通常采用非关系型、分布式的数据存储系统，支持高性能、高并发，并有良好的扩展性，但大都以牺牲一致性为代价。NoSQL 数据库用于存储非结构化数据，适用于联机分析 OLAP 的应用场景。此外，NoSQL数据库不支持 SQL语言，尤其不支持连接（JOIN）操作。</p><p>它们的安全性往往比 SQL 数据库差一点。因此，您需要考虑数据库安全，而加强安全的一种方法是使用 SAST。 SAST 即静态应用程序安全测试，直接查看源代码以查找漏洞。您还可以运行 DAST (动态版本)，同样有助于避免NoSQL注入攻击。</p><h2 id="3-0-NoSQL-应用场景"><a href="#3-0-NoSQL-应用场景" class="headerlink" title="3.0 NoSQL 应用场景"></a>3.0 NoSQL 应用场景</h2><ul><li>No need for ACID</li><li>Flexible schema</li><li>No constraints and validations to be executed in database</li><li>Temporary data</li><li>Different data types</li><li>High data volume.</li></ul><h2 id="3-1-键值数据库（Redis）"><a href="#3-1-键值数据库（Redis）" class="headerlink" title="3.1 键值数据库（Redis）"></a>3.1 键值数据库（Redis）</h2><p>Redis 是一种基于内存的键值对数据库，主要是通过查找键的方式来读写对应的值，且提供一定的数据持久化能力。限于成本的原因，Redis 一般用于存储一些常用和主要的数据，比如用户登录的信息等。</p><h3 id="3-1-1-优点"><a href="#3-1-1-优点" class="headerlink" title="3.1.1 优点"></a>3.1.1 优点</h3><ul><li><p>读写快：运行在内容中</p></li><li><p>扩展性强：关系型数据库为某行增加新属性时，只能为整张表增加新属性，需将其他行的新属性设置为 <code>null</code> 或默认值。键值数据库直接在改行尾部追加即可，不影响其他行。不仅可以加快写的速度，而且节省了存储其他行不必要的新属性的空间</p></li></ul><h3 id="3-1-2-缺点"><a href="#3-1-2-缺点" class="headerlink" title="3.1.2 缺点"></a>3.1.2 缺点</h3><ul><li>内存受限：不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>不能按值查询：如果要实现对值的内容进行查找，则需要对全表进行遍历，在大数据场景下效率较低</li></ul><h3 id="3-1-3-应用场景"><a href="#3-1-3-应用场景" class="headerlink" title="3.1.3 应用场景"></a>3.1.3 应用场景</h3><ul><li>适合大量写操作，比如内容缓存（会话、参数、购物车等）。而关系型数据库需要通过建立索引来实现加速查询，频繁写时，索引会频繁更新，维护索引的开销很大</li></ul><h2 id="3-2-列存储数据库（HBase）"><a href="#3-2-列存储数据库（HBase）" class="headerlink" title="3.2 列存储数据库（HBase）"></a>3.2 列存储数据库（HBase）</h2><p>在关系数据库中，通过行和列组成的二维坐标来定位一个数据</p><p>在 HBase 中，需要通过「行键、列族、列限定符、时间戳」组成的一个四维坐标来获取一个值</p><h3 id="3-2-1-优点"><a href="#3-2-1-优点" class="headerlink" title="3.2.1 优点"></a>3.2.1 优点</h3><ul><li>查询效率高、磁盘 IO 开销小：一个列族可能包含多个属性，同一列的数据会存储在一起。查询时只需关心目标列</li><li>磁盘的空间利用率高：同一列中的数据类型相同，因此数据压缩时有很好的压缩比，提高了磁盘的空间利用率</li><li>适合稀疏宽表的查询：例如在一个二维表中，每一行只在其中的一列有值，其他的列大多为空值，即这个表是稀疏的，必然出现大量的空值。而在面向行的关系数据库中，如果出现空值，则数据库通常会预留空间以便后续有值写入，但这对于稀疏宽表（列很多的表）则会造成存储的低效率。在面向列的存储中，如果出现空值，则数据库不会为其预留空间。</li></ul><h3 id="3-2-2-缺点"><a href="#3-2-2-缺点" class="headerlink" title="3.2.2 缺点"></a>3.2.2 缺点</h3><ul><li>修改性能低：常用作数据仓库</li></ul><h3 id="3-2-3-应用场景"><a href="#3-2-3-应用场景" class="headerlink" title="3.2.3 应用场景"></a>3.2.3 应用场景</h3><ul><li><p>数据仓库</p></li><li><p>行式数据库擅长随机读，列式数据库则擅长批量数据查询</p></li><li><p>适用于批量数据查询：磁盘 I/O 开销小，因此支持大量并发用户查询，典型的应用是分布式数据存储与管理</p></li></ul><h2 id="3-3-文档数据库（MongoDB）"><a href="#3-3-文档数据库（MongoDB）" class="headerlink" title="3.3 文档数据库（MongoDB）"></a>3.3 文档数据库（MongoDB）</h2><p>文档数据库也由键值对组成。与键值数据库不同，文档数据库既可以根据 Key 来简历索引，也可以基于文档内容来构建索引</p><p>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。MongoDB 有数据分片</p><h3 id="3-3-1-优点"><a href="#3-3-1-优点" class="headerlink" title="3.3.1 优点"></a>3.3.1 优点</h3><ul><li>按值查询：既可以基于键来构建索引，也可以基于文档内容来构建索引。和键值模式相比，文档存储强调可以通过关键词查找查询文档内部的结构，而非只通过键来进行检索</li><li>文档支持嵌套（Join 查询）：可以将传统关系型数据库中需要 Join 查询的字段整合为一个文档，这种做法理论上会增加存储开销，但是会提高查询效率。在分布式系统中，Join 查询的开销较大，文档式嵌套存储的优势更加明显</li><li>查询的直接是 JSON 文档</li></ul><h3 id="3-3-2-缺点"><a href="#3-3-2-缺点" class="headerlink" title="3.3.2 缺点"></a>3.3.2 缺点</h3><ul><li>缺乏统一的查询语法</li><li>查询字段在文档中，文档可能过大，导致查询速度慢</li></ul><h3 id="3-3-3-应用场景"><a href="#3-3-3-应用场景" class="headerlink" title="3.3.3 应用场景"></a>3.3.3 应用场景</h3><ul><li>文档数据库主要用于存储和检索文档数据，非常适合那些把输入数据表示成文档的应用</li><li>日志、 Web 应用等</li></ul><h2 id="3-4-图数据库（Neo4J）"><a href="#3-4-图数据库（Neo4J）" class="headerlink" title="3.4 图数据库（Neo4J）"></a>3.4 图数据库（Neo4J）</h2><h3 id="3-4-1-优点"><a href="#3-4-1-优点" class="headerlink" title="3.4.1 优点"></a>3.4.1 优点</h3><ul><li>擅长处理实体间的关系</li></ul><h3 id="3-4-2-缺点"><a href="#3-4-2-缺点" class="headerlink" title="3.4.2 缺点"></a>3.4.2 缺点</h3><ul><li>查询效率低：图的时间复杂度高，有时需要对整个图做计算才能得出需要的信息</li></ul><h3 id="3-4-3-应用场景"><a href="#3-4-3-应用场景" class="headerlink" title="3.4.3 应用场景"></a>3.4.3 应用场景</h3><ul><li>社交网络</li><li>推荐系统</li></ul><h2 id="3-5-实验"><a href="#3-5-实验" class="headerlink" title="3.5 实验"></a>3.5 实验</h2><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><h4 id="1-开启-hbase-服务"><a href="#1-开启-hbase-服务" class="headerlink" title="1. 开启 hbase 服务"></a>1. 开启 hbase 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd hbase<br>sudo bin/start-hbase.sh<br></code></pre></td></tr></table></figure><h4 id="2-打开-hbase-数据库"><a href="#2-打开-hbase-数据库" class="headerlink" title="2. 打开 hbase 数据库"></a>2. 打开 hbase 数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo bin/hbase shell<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/MySQL/Gensim/"/>
    <url>/2022/02/12/MySQL/Gensim/</url>
    
    <content type="html"><![CDATA[<h2 id="步骤一：训练语料的预处理"><a href="#步骤一：训练语料的预处理" class="headerlink" title="步骤一：训练语料的预处理"></a>步骤一：训练语料的预处理</h2><p>作用：将文档中原始的字符文本转换成 Gensim 模型所能理解的稀疏向量</p><ul><li>作业块</li><li>分词，去除停用词</li><li>特征列表</li><li>建立语料特征（此处即是word）的索引字典</li><li>词袋模型对应的稀疏向量（bow 向量）的表达</li></ul><h2 id="步骤二：主题向量的变换"><a href="#步骤二：主题向量的变换" class="headerlink" title="步骤二：主题向量的变换"></a>步骤二：主题向量的变换</h2><p>对文本向量的变换是 Gensim 的核心。通过挖掘语料中隐藏的语义结构特征，我们最终可以变换出一个简洁高效的文本向量。</p><ul><li>主题模型</li><li>主题向量</li></ul><h2 id="步骤三：文档相似度的计算"><a href="#步骤三：文档相似度的计算" class="headerlink" title="步骤三：文档相似度的计算"></a>步骤三：文档相似度的计算</h2><p>在得到每一篇文档对应的主题向量后，我们就可以计算文档之间的相似度，进而完成如文本聚类、信息检索之类的任务。在Gensim中，也提供了这一类任务的API接口。</p><ul><li>新的作业块作为待检索的</li><li>待检索的作业块和作业块文本集合放在同一个向量空间（如 LSI 向量空间）下表达为文本向量（以为例）</li><li>用作业块文本集合的文本向量初始化一个相似度计算对象，该对象是一个相似度矩阵</li><li>可以持久化相似度矩阵</li><li>通过相似度计算对象计算任意一个作业块与所有作业块集合的（余弦）相似度</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/LeetCode/2%20%20C++%20STL/"/>
    <url>/2022/02/12/LeetCode/2%20%20C++%20STL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/Journals/Prediction/"/>
    <url>/2022/02/12/Journals/Prediction/</url>
    
    <content type="html"><![CDATA[<h2 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h2><h3 id="Applied-Soft-Computing（SCI-2区）"><a href="#Applied-Soft-Computing（SCI-2区）" class="headerlink" title="Applied Soft Computing（SCI 2区）"></a><a href="https://www.journals.elsevier.com/applied-soft-computing">Applied Soft Computing（SCI 2区）</a></h3><p>IF：6.725</p><p>First Online: 1.0 weeks</p><p>Final Online: 4.0 weeks</p><h3 id="Journal-of-Statistical-Software-SCI-2区"><a href="#Journal-of-Statistical-Software-SCI-2区" class="headerlink" title="Journal of Statistical Software (SCI 2区)"></a><a href="https://www.jstatsoft.org/index.php/jss/index">Journal of Statistical Software (SCI 2区)</a></h3><p>教育背景：</p><p>2021-2024：研究生在读（计算机）</p><p>2016-2020：西南石油大学（自动化）</p><p>工作经历：</p><p>2021年1月-2021年6月，在华为任职软件开发工程师</p><p>本科经历：</p><p>2019年全国大学生数学建模竞赛全国一等奖（负责建模，编程）</p><p>2019年中国高校智能机器人创意大赛全国一等奖（负责运动控制，图像）</p><p>其他多项省级奖项、一项四川省省级项目，三篇专利</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/Journals/Pose/"/>
    <url>/2022/02/12/Journals/Pose/</url>
    
    <content type="html"><![CDATA[<h1 id="Pattern-Recognition"><a href="#Pattern-Recognition" class="headerlink" title="Pattern Recognition"></a>Pattern Recognition</h1><h2 id="The-requirement-of-PR"><a href="#The-requirement-of-PR" class="headerlink" title="The requirement of PR"></a>The requirement of PR</h2><ul><li>Single Column, Double Spaced</li><li>20-35 Pages</li><li>35-45 References</li><li>页编号</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><h3 id="Related-Theories"><a href="#Related-Theories" class="headerlink" title="Related Theories"></a>Related Theories</h3><h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><p>[32] <a href="https://www.semanticscholar.org/paper/0db0416feb136b5e41b8d7ce51dbd362be9a9f41">Reinforced SVM method and memorization mechanisms</a></p><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>[28] <a href="https://www.semanticscholar.org/paper/2c03df8b48bf3fa39054345bafabfeff15bfd11d">Deep Residual Learning for Image Recognition</a></p><p>[29] <a href="https://www.sciencedirect.com/science/article/pii/S0031320321000388">CapsNet regularization and its conjugation with <em>ResNet</em> for signature identification</a></p><p>[30] <a href="https://www.sciencedirect.com/science/article/pii/S0031320319300135">Wider or Deeper: Revisiting the <em>ResNet</em> Model for Visual Recognition</a></p><h4 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h4><p>[31] <a href="https://www.semanticscholar.org/paper/b3afc89dbd3f690d3d9a7c29e883dd6da93232d6">Multilayer Perceptron (MLP)</a></p><p><a href="https://www.semanticscholar.org/paper/1280befa3f7efee004b9bb98f4888ee798020266">Prediction of solubility of N-alkanes in supercritical CO2 using RBF-ANN and MLP-ANN</a></p><h4 id="BlazePose"><a href="#BlazePose" class="headerlink" title="BlazePose"></a>BlazePose</h4><p>[23] <a href="https://www.semanticscholar.org/paper/c9bcea08fb81c041ed6d2b7576d8f0e47c1c850f">BlazePose: On-device Real-time Body Pose tracking</a></p><h3 id="Fashion"><a href="#Fashion" class="headerlink" title="Fashion"></a>Fashion</h3><p>[1] <a href="https://www.semanticscholar.org/paper/c020ff7138c87f6e972e3974141d7cf6d902bf41">Two-Stream Multi-Task Network for Fashion Recognition</a></p><p>[2] <a href="https://www.semanticscholar.org/paper/5850605d21859e5878844ed16ed7ed013ca7f477">NeuroStylist: Neural Compatibility Modeling for Clothing Matching</a></p><p>[3] <a href="https://www.semanticscholar.org/paper/1686a73010fadf9c78b2d617a74d8e981fd7a290">Learning Fashion Compatibility with Bidirectional LSTMs</a></p><p>[4] <a href="https://www.semanticscholar.org/paper/e7627120568bda6e0dcd94491c8b1ad6c71600e9">Fashion Forward: Forecasting Visual Style in Fashion</a></p><h4 id="Clothing-Classification"><a href="#Clothing-Classification" class="headerlink" title="Clothing Classification"></a>Clothing Classification</h4><p>[5] <a href="https://www.semanticscholar.org/paper/385ae5201434ac8d903f1f6bb1b0d420a1ef2c4f">DeepFashion: Powering Robust Clothes Recognition and Retrieval with Rich Annotations</a></p><p>[6] <a href="https://www.semanticscholar.org/paper/ab54f8cdd3e0e259a8cadc58b0c4cca2bfcd92a8">Texture and Shape Biased Two-Stream Networks for Clothing Classification and Attribute Recognition</a></p><p>[7] <a href="https://www.semanticscholar.org/paper/71573d5dc03b28279c1a337e9fd91ffbeff47569">Attentive Fashion Grammar Network for Fashion Landmark Detection and Clothing Category Classification</a></p><p>[8] <a href="https://www.semanticscholar.org/paper/99ffb908dd85d36d62ad2c51817ffb591a6044b5">Multi-task Curriculum Transfer Deep Learning of Clothing Attributes</a></p><h4 id="Landmark-Detection"><a href="#Landmark-Detection" class="headerlink" title="Landmark Detection"></a>Landmark Detection</h4><p>[9] <a href="https://www.semanticscholar.org/paper/89eb2c81f55433fdb6a7f40dabf384beab90ced4">A Global-Local Embedding Module for Fashion Landmark Detection</a></p><p>[10] <a href="https://www.semanticscholar.org/paper/e4c6aee62e4a1e02007980fdc987fdfeac1dcdac">Improving Fashion Landmark Detection by Dual Attention Feature Enhancement</a></p><p>[11] <a href="https://www.semanticscholar.org/paper/4fefd1bc8dc4e0ab37ee3324ddfa43ad9d6a04a7">Fashion Landmark Detection in the Wild</a></p><p>[12] <a href="https://www.semanticscholar.org/paper/def40fb1f3a41179a4f7d81d0e522c4dc79535b4">PCLoss: Fashion Landmark Estimation with Position Constraint Loss</a></p><p><a href="https://www.semanticscholar.org/paper/70442027bc56ab92d77ea2d5ff7da61b1244f3de">Deep Fashion Analysis with Feature Map Upsampling and Landmark-Driven Attention</a></p><h4 id="Clothing-Retrieval-and-Recommedation"><a href="#Clothing-Retrieval-and-Recommedation" class="headerlink" title="Clothing Retrieval and Recommedation"></a>Clothing Retrieval and Recommedation</h4><p>[13] <a href="https://www.semanticscholar.org/paper/8cdd1830d7cd2d2bbbd825c3d5fd16792f7ea1aa">Hipster Wars: Discovering Elements of Fashion Styles</a></p><p>[14] <a href="https://www.semanticscholar.org/paper/5bea1762f43987f03ddbd8d9c46757cba281a05f">What Makes a Style: Experimental Analysis of Fashion Prediction</a></p><p>[-1] <a href="https://www.semanticscholar.org/paper/2cf785868dd412736f7008e2bdb51f62c173c292">Where to Buy It: Matching Street Clothing Photos in Online Shops</a></p><p>[-2] <a href="https://www.semanticscholar.org/paper/b1db62044adca574e4cf88b23c170f3cc089d513">GP-BPR: Personalized Compatibility Modeling for Clothing Matching</a></p><p>[-3] <a href="https://www.semanticscholar.org/paper/b85c8741405d24fb21b8a05c278df31c45c793d7">Fashion Retrieval via Graph Reasoning Networks on a Similarity Pyramid</a></p><p>[-4] <a href="https://www.semanticscholar.org/paper/58f5484ab0f032b2c1f9c1062a9b07879276d6ba">Smart Clothing Recommendation System with Deep Learning</a></p><h3 id="SVM-1"><a href="#SVM-1" class="headerlink" title="SVM"></a>SVM</h3><h4 id="HOG"><a href="#HOG" class="headerlink" title="HOG + ?"></a>HOG + ?</h4><p>[15] <a href="https://www.semanticscholar.org/paper/cec734d7097ab6b1e60d95228ffd64248eb89d66">Histograms of oriented gradients for human detection</a></p><p>[16] <a href="https://www.sciencedirect.com/science/article/pii/S0167739X21002119">Research on pedestrian detection technology based on the <em>SVM</em> classifier trained by <em>HOG</em> and LTP features</a></p><p>[17] <a href="https://www.semanticscholar.org/paper/3d871866070a93ab30c6ea3e722280ac5ee4b46a">Multi-vehicle detection algorithm through combining Harr and HOG features</a></p><p>[18] <a href="https://www.semanticscholar.org/paper/bd9446d2b61139867662442147d81181e84ab4f2">An HOG-LBP human detector with partial occlusion handling</a></p><p><a href="https://www.semanticscholar.org/paper/f11a7136b6b7854bd0998ef463ffa8e907c411a2">Multiresolution Gray-Scale and Rotation Invariant Texture Classification with Local Binary Patterns</a></p><h4 id="LBP"><a href="#LBP" class="headerlink" title="LBP"></a>LBP</h4><p>改进1：[24] Ojala, T. , Matti Pietikäinen, &amp; Topi Mäenpää. (2001). A generalized local binary pattern operator for multiresolution gray scale and rotation invariant texture classification. Springer, Berlin, Heidelberg</p><p>改进2（LBP uniform）：[25] Ojala, T. , Pietikainen, M. , &amp; Maenpaa, T. . (2002). Multiresolution gray-scale and rotation invariant texture classification with local binary patterns. IEEE Transactions on Pattern Analysis and Machine Intelligence, 24(7), 971-987.</p><h4 id="SVM-HSV"><a href="#SVM-HSV" class="headerlink" title="SVM + HSV"></a>SVM + HSV</h4><p>Sea target detection HSV+SVM：[26] Mirghasemi, S. , &amp; Banihashem, E. . (2009). Sea target detection based on SVM method using HSV color space. Research &amp; Development. IEEE.<br>安全监控领域中的人脸检测系统预处理方法：[27] Gupta, M. , &amp; Gupta, N. . (2011). A novel approach for pre-processing of face detection system based on hsv color space and iwpt. International Journal of Advanced Computer Science &amp; Applications, 2(11).</p><h4 id="Clothing-Recognition"><a href="#Clothing-Recognition" class="headerlink" title="Clothing Recognition"></a>Clothing Recognition</h4><p>[19] <a href="https://www.semanticscholar.org/paper/d8655f05a6b82c9061df7b030d9042b5fe27b06f">Clothing Co-Segmentation Based on HOG Features and E-SVM Classifier</a></p><p>[20] <a href="https://www.semanticscholar.org/paper/b146277ed892658f7e8aa89c5ccee41658791796">Efficient Clothing Pattern Recognition for Blind People Using SVM Classifier</a></p><p>[21] <a href="https://www.semanticscholar.org/paper/66aeb6e8b09001d8d736eda4c54728bc81fc99b3">HOG of Region of Interest for Improving Clothing Retrieval Performance</a></p><p>[22] <a href="https://www.semanticscholar.org/paper/9e071a5c3b8d85627c61bbbd303f919afc64ac3b">Evaluation of LBP and HOG Descriptors for Clothing Attribute Description</a></p><h3 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h3><p><a href="https://www.semanticscholar.org/paper/cb19a4a7afff90171dc348fd9c9f30889059fd45">SVMs multi-class loss feedback based discriminative dictionary learning for image classification</a></p><p><a href="https://www.semanticscholar.org/paper/45540df15593049b513a3aedd55aa253c1439f51">SVM based multi-label learning with missing labels for image annotation</a></p><h2 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a>Submission</h2><p>First：2021.12.16</p><p>Second：2021. 12.18。页数 37 超了（20~35），系统中第三个作者未提交</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/12/Journals/Journal/"/>
    <url>/2022/02/12/Journals/Journal/</url>
    
    <content type="html"><![CDATA[<h2 id="Journal-of-Machine-Learning-Research"><a href="#Journal-of-Machine-Learning-Research" class="headerlink" title="Journal of Machine Learning Research"></a><a href="https://www.jmlr.org/">Journal of Machine Learning Research</a></h2><p>IF：3.654</p><p>审查时间：3月（2019 年 &lt; 100days）</p><h2 id="Applied-Soft-Computing（推荐）"><a href="#Applied-Soft-Computing（推荐）" class="headerlink" title="Applied Soft Computing（推荐）"></a><a href="https://www.journals.elsevier.com/applied-soft-computing">Applied Soft Computing（推荐）</a></h2><p>IF：6.725</p><p>First Online: 1.0 weeks</p><p>Final Online: 4.0 weeks</p><h2 id="Pattern-Recognition（Top，推荐）"><a href="#Pattern-Recognition（Top，推荐）" class="headerlink" title="Pattern Recognition（Top，推荐）"></a><a href="https://www.journals.elsevier.com/pattern-recognition">Pattern Recognition（Top，推荐）</a></h2><p>IF：7.74</p><p>First Online: 1.2 weeks</p><p>Final Online: 4.6 weeks</p><h2 id="Transactions-on-Cybernetics"><a href="#Transactions-on-Cybernetics" class="headerlink" title="Transactions on Cybernetics"></a><a href="https://www.ieee.org/membership-catalog/productdetail/showProductDetailPage.html?product=PER169-PRT">Transactions on Cybernetics</a></h2><h2 id="Knowledge-Based-Systems（Top）"><a href="#Knowledge-Based-Systems（Top）" class="headerlink" title="Knowledge-Based Systems（Top）"></a><a href="https://www.journals.elsevier.com/knowledge-based-systems#description">Knowledge-Based Systems（Top）</a></h2><p>IF：8.308</p><p>First Online: 1.2 weeks</p><p>Final Online: 4.6 weeks</p><h2 id="Information-Fusion（Top）"><a href="#Information-Fusion（Top）" class="headerlink" title="Information Fusion（Top）"></a><a href="https://www.sciencedirect.com/journal/information-fusion">Information Fusion（Top）</a></h2><p>IF：12.975</p><p>First Online: 1.2 weeks</p><p>Final Online: 4.6 weeks</p><h2 id="Artificial-Intelligence"><a href="#Artificial-Intelligence" class="headerlink" title="Artificial Intelligence"></a><a href="https://www.journals.elsevier.com/artificial-intelligence">Artificial Intelligence</a></h2><p>IF：9.088</p><p>First Online: 1.1 weeks</p><p>Final Online: 7.1 weeks</p><h2 id="IEEE-Transactions-on-Knowledge-and-Data-Engineering（数据相关、有特征提取、机器学习）"><a href="#IEEE-Transactions-on-Knowledge-and-Data-Engineering（数据相关、有特征提取、机器学习）" class="headerlink" title="IEEE Transactions on Knowledge and Data Engineering（数据相关、有特征提取、机器学习）"></a><a href="https://ieeexplore.ieee.org/xpl/topAccessedArticles.jsp?punumber=69">IEEE Transactions on Knowledge and Data Engineering（数据相关、有特征提取、机器学习）</a></h2><p>IF：6.977</p><p>First Online: 1.0 weeks</p><p>Final Online: 4.0 weeks</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第3章  分区和采样</title>
    <link href="/2021/11/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC3%E7%AB%A0%20%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/11/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC3%E7%AB%A0%20%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-中心思想"><a href="#3-1-中心思想" class="headerlink" title="3.1 中心思想"></a>3.1 中心思想</h2><h3 id="3-1-1-为什么写这篇文章（Why）"><a href="#3-1-1-为什么写这篇文章（Why）" class="headerlink" title="3.1.1 为什么写这篇文章（Why）"></a>3.1.1 为什么写这篇文章（Why）</h3><ul><li>大多数现有的数据存储、处理和分析工具都不足以处理海量的数据。 因此，迫切需要更先进、更合适的大数据解决方案</li><li>而已存在的研究在大数据框架的评估特性（没有同时比较批处理和流处理）和数量上都存在不足</li></ul><h3 id="3-1-2-文章的目的是什么（What）"><a href="#3-1-2-文章的目的是什么（What）" class="headerlink" title="3.1.2 文章的目的是什么（What）"></a>3.1.2 文章的目的是什么（What）</h3><ul><li>对大数据框架在批处理和流处理情况下的性能进行综合比较</li><li>给出了这些大数据框架在不同场景（流处理、小批处理、机器学习和图形处理）中的最佳实践</li></ul><h3 id="3-1-3-中心思想是什么（What）"><a href="#3-1-3-中心思想是什么（What）" class="headerlink" title="3.1.3 中心思想是什么（What）"></a>3.1.3 中心思想是什么（What）</h3><ul><li><p>讨论已存在的关于大数据框架的比较和研究</p></li><li><p>概述几个最流行的大数据框架，并将它们按某些关键特性进行分类</p></li><li><p>在批处理和流处理的情况下，设计实验对这些大数据框架的性能进行评估</p></li><li><p>这些大数据框架在不同场景（流处理、小批处理、机器学习和图形处理）中各自的优势</p></li></ul><h2 id="3-2-中心内容"><a href="#3-2-中心内容" class="headerlink" title="3.2 中心内容"></a>3.2 中心内容</h2><h3 id="3-2-3-BIG-DATA-FRAMEWORKS"><a href="#3-2-3-BIG-DATA-FRAMEWORKS" class="headerlink" title="3.2.3 BIG DATA FRAMEWORKS"></a>3.2.3 BIG DATA FRAMEWORKS</h3><p>五个框架中的 WordCount Exmaple</p><h4 id="1-Hadoop"><a href="#1-Hadoop" class="headerlink" title="1. Hadoop"></a>1. Hadoop</h4><p>组成：HDFS + MapReduce + YARN</p><h4 id="2-Spark"><a href="#2-Spark" class="headerlink" title="2. Spark"></a>2. Spark</h4><h4 id="3-Storm"><a href="#3-Storm" class="headerlink" title="3. Storm"></a>3. Storm</h4><h4 id="4-Samza"><a href="#4-Samza" class="headerlink" title="4. Samza"></a>4. Samza</h4><h4 id="5-Flink"><a href="#5-Flink" class="headerlink" title="5. Flink"></a>5. Flink</h4><h4 id="6-Categorization-of-Big-Data-Frameworks"><a href="#6-Categorization-of-Big-Data-Frameworks" class="headerlink" title="6. Categorization of Big Data Frameworks"></a>6. Categorization of Big Data Frameworks</h4><h4 id="7-Real-world-applications"><a href="#7-Real-world-applications" class="headerlink" title="7. Real-world applications"></a>7. Real-world applications</h4><ul><li><p>Healthcare applications</p></li><li><p>Recommendation systems</p></li><li><p>Social media</p></li><li><p>Smart cities</p></li></ul><h3 id="3-2-4-EXPERIMENTS"><a href="#3-2-4-EXPERIMENTS" class="headerlink" title="3.2.4 EXPERIMENTS"></a>3.2.4 EXPERIMENTS</h3><h4 id="1-Experimental-environment"><a href="#1-Experimental-environment" class="headerlink" title="1. Experimental environment"></a>1. Experimental environment</h4><h4 id="2-Experimental-protocol"><a href="#2-Experimental-protocol" class="headerlink" title="2. Experimental protocol"></a>2. Experimental protocol</h4><p>Batch mode、Stream mode</p><h4 id="3-Experimental-results"><a href="#3-Experimental-results" class="headerlink" title="3.  Experimental results"></a>3.  Experimental results</h4><h5 id="（1）Batch-mode"><a href="#（1）Batch-mode" class="headerlink" title="（1）Batch mode"></a>（1）Batch mode</h5><ul><li><p>Scalability</p></li><li><p>Iterative processing</p></li><li><p>Data partitioning</p></li><li><p>Impact of the cluster manager</p></li><li><p>Impact of bandwidth</p></li><li><p>Impact of some configuration parameters</p></li><li><p>Resources consumption（CPU、RAM、Disk I/O usage、Bandwidth consumption）</p></li></ul><h5 id="（2）Stream-mode"><a href="#（2）Stream-mode" class="headerlink" title="（2）Stream mode"></a>（2）Stream mode</h5><p>CPU、RAM、Disk R/W usage、Bandwidth resource usage</p><h4 id="4-Summary-of-the-evaluation"><a href="#4-Summary-of-the-evaluation" class="headerlink" title="4. Summary of the evaluation"></a>4. Summary of the evaluation</h4><h5 id="（1）Batch-mode-1"><a href="#（1）Batch-mode-1" class="headerlink" title="（1）Batch mode"></a>（1）Batch mode</h5><ul><li>Spark 比 Hadoop 和 Flink 能更好地处理大型数据集。 尽管由于 RDD 的概念，Spark 被认为是最快的框架，但在内存处理任务密集的情况下，它并不是一个合适的选择。这个过程会降低 Spark 的性能，因为 SparkContext 会被引导找到未使用的 RDD 并删除它们以获得更多的空闲内存空间</li><li>Hadoop 总体上表现良好。但它在将中间结果写入硬盘方面有一些限制，并且当数据大小增加时需要相当长的处理时间，尤其是在迭代应用场景中。</li><li>根据 batch mode 下的资源消耗结果，与 Spark 和 Hadoop 相比，Flink 最大限度地利用了 CPU资源。这取决于 Flink 的流水线技术，它最大限度地减少了空闲资源的周期。但与 Hadoop 相比，Flink  对网络资源要求高</li></ul><h5 id="（2）Stream-mode-1"><a href="#（2）Stream-mode-1" class="headerlink" title="（2）Stream mode"></a>（2）Stream mode</h5><ul><li>在流场景中，Flink、Samza 和 Storm 在数据处理方面非常相似。 事实上，它们最初是为流处理而设计的。</li><li>Flink 低延迟，因为它基于管道处理和消息传递技术，而 Spark 基于 JVM，属于批处理模式框架的类别</li><li>每个 Samza 作业被分成一个或多个分区，每个分区在一个独立的容器或执行器中处理，这能显示大量的流消息</li><li>在调整框架时，考虑的另一个重要方面是集群管理器。 在 Standalone 模式下，Spark 和 Flink 中的资源分配由用户在提交作业时指定，而使用 Mesos 或 YARN 等集群管理器，资源的分配是自动完成的。</li></ul><h3 id="3-4-5-BEST-PRACTICES"><a href="#3-4-5-BEST-PRACTICES" class="headerlink" title="3.4.5 BEST PRACTICES"></a>3.4.5 BEST PRACTICES</h3><p><strong>挑战：</strong>各种类似的框架越来越多，选择正确的大数据框架是一个挑战</p><p><strong>目的：</strong>本节旨在阐明上述框架在特定领域（流处理、小批处理、机器学习和图形处理）中的优势</p><h4 id="1-Stream-processing"><a href="#1-Stream-processing" class="headerlink" title="1. Stream processing"></a>1. Stream processing</h4><ul><li>流计算成为多个领域实时应用的基本能力，包括监控系统、智慧城市、金融市场和制造业</li><li> Storm、Flink 适合流处理的情况下</li><li>Storm 是面向大/高流的应用程序（每秒数十亿个事件/核心）的最佳选择。 正如所进行的实验所示，即使事件流变得重要，Storm 也表现良好并且可以节省资源。</li></ul><h4 id="2-Micro-batch-processing"><a href="#2-Micro-batch-processing" class="headerlink" title="2. Micro-batch processing"></a>2. Micro-batch processing</h4><ul><li>在批处理的情况下，Spark 可能是处理周期性处理任务的合适框架，例如 Web 使用挖掘、欺诈检测</li><li>在某些情况下，需要一种编程模型，在 lambda 架构中将批处理和流处理结合到庞大的数据量/频率上。在这种架构中，周期性分析任务在更大的窗口时间内执行。 这种行为称为微批处理。在这种情况下，像 Flink 和 Spark 这样的框架可能是不错的选择</li></ul><h4 id="3-Machine-learning-algorithms"><a href="#3-Machine-learning-algorithms" class="headerlink" title="3. Machine learning algorithms"></a>3. Machine learning algorithms</h4><ul><li>机器学习算法是迭代的。上面讨论的大多数框架都通过一组库和 API 支持机器学习功能。 FlinkML 库包括 k-Means 聚类算法、逻辑回归和交替最小二乘法 (ALS) 的实现以进行推荐</li><li>Spark 拥有更高效的机器学习算法集，例如 Spark MLlib 和 MLI。 Spark MLlib 是一个可扩展且快速的库，适用于一般需求和机器学习的大多数领域。 关于 Hadoop 框架，Apache Mahout 旨在在 Hadoop 之上构建可扩展和高性能的机器学习应用程序</li></ul><h4 id="4-Big-graph-processing"><a href="#4-Big-graph-processing" class="headerlink" title="4. Big graph processing"></a>4. Big graph processing</h4><ul><li>Hadoop 不是图处理的最佳编程模型。Hadoop 使用粗粒度任务来完成它的工作，这对于图处理和迭代算法来说太重了。 此外，Hadoop 无法在内存中缓存中间数据以获得更快的性能</li><li>大多数大数据框架都提供了与图相关的库（例如，Spark Graphx 和 Flink Flinkgelly）。 此外，已经提出了许多图处理系统，包括 Pregel、Graphlab、Bladyg 和 Trinity</li></ul><h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><ul><li>本文调查了用于大规模数据处理的流行框架。 概述了大数据框架 Hadoop、Spark、Storm 和 Flink。根据一些主要特征对这些框架进行了分类，例如使用的编程模型、数据源的类型、支持的编程语言以及框架是否允许迭代处理</li><li>对上述框架在批处理和流处理场景中进行了比较研究，并给出了不同框架在不同应用场景中的最佳实践</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>Spark</tag>
      
      <tag>Flink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第2章  分区和采样</title>
    <link href="/2021/10/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC2%E7%AB%A0%20%E5%88%86%E5%8C%BA%E5%92%8C%E9%87%87%E6%A0%B7/"/>
    <url>/2021/10/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC2%E7%AB%A0%20%E5%88%86%E5%8C%BA%E5%92%8C%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-中心思想"><a href="#2-1-中心思想" class="headerlink" title="2.1 中心思想"></a>2.1 中心思想</h2><h3 id="2-1-1-为什么写这篇文章（Why）"><a href="#2-1-1-为什么写这篇文章（Why）" class="headerlink" title="2.1.1 为什么写这篇文章（Why）"></a>2.1.1 为什么写这篇文章（Why）</h3><ul><li>传统的数据处理方法无法处理大体量和复杂的数据，单机也不能进行大数据分析，因此可扩展的分布式计算架构已成为大数据分析框架的常见设计</li><li>而在这些框架中，数据分区和采样是两种基本策略，可用于扩展和加速计算，能够解决数据量大导致的无法进行数据分析的问题</li></ul><h3 id="2-1-2-文章的目的是什么（What）"><a href="#2-1-2-文章的目的是什么（What）" class="headerlink" title="2.1.2 文章的目的是什么（What）"></a>2.1.2 文章的目的是什么（What）</h3><p>帮助研究人员从数据采样和分区开始，进行大数据近似分析</p><h3 id="2-1-3-中心思想是什么（What）"><a href="#2-1-3-中心思想是什么（What）" class="headerlink" title="2.1.3 中心思想是什么（What）"></a>2.1.3 中心思想是什么（What）</h3><ul><li>概述两个常用的大数据分析框架： Hadoop、Spark</li><li>数据分区：概述、分区方法（描述、优缺点）、Hadoop clusters 中的数据分区方法</li><li>数据采样：概述、采样方法（描述、优缺点）、Hadoop clusters 中的数据采样方法</li><li>近似计算：概述、Hadoop clusters 中基于采样的近似（三角平衡模型）</li></ul><h2 id="2-2-中心内容"><a href="#2-2-中心内容" class="headerlink" title="2.2 中心内容"></a>2.2 中心内容</h2><h3 id="2-2-1-分区"><a href="#2-2-1-分区" class="headerlink" title="2.2.1 分区"></a>2.2.1 分区</h3><p><strong>作用：</strong>数据库查询；大数据分析框架中的数据密集型计算；高扩展性、并行计算（分治，divide and conquer）</p><p><strong>问题：</strong>分区不平衡的问题（数据倾斜），典型的分区方法没有考虑数据集的 class 或 key 的分布</p><p><strong>分类：</strong>垂直分区、水平分区、功能分区</p><table><thead><tr><th>垂直分区</th><th>公式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>轮询调度 Round-robin</td><td>i-th row to node (i mod n)</td><td>打乱顺序；顺序扫描，分区均衡</td><td>不适合点查询和范围查询</td></tr><tr><td>Hash</td><td>(k, v) to node h(k)</td><td>打乱顺序；顺序扫描，适合基于点查询</td><td>需要额外计算 Value，不适合范围查询和没有分区属性的点查询</td></tr><tr><td>Range</td><td>(k, v) to node that holds k’s interval</td><td>不打乱顺序；顺序扫描，分区均衡，适合点查询和范围查询（只需搜索一个或几个分区）</td><td>1. 选择分区边界是一个挑战；<br />2. 分区边界是由于一个或几个分区中的所有进程，可能会发生执行倾斜 Execution Skew</td></tr><tr><td>Random</td><td>rand(i) to node n</td><td>打乱顺序；顺序扫描，分区均衡</td><td>需要额外计算随机值，记录随机分布</td></tr></tbody></table><h3 id="2-2-2-Hadoop-clusters-中的分区"><a href="#2-2-2-Hadoop-clusters-中的分区" class="headerlink" title="2.2.2 Hadoop clusters 中的分区"></a>2.2.2 Hadoop clusters 中的分区</h3><p>在 Hadoop 中，HDFS 主要负责数据分区。 将大数据文件导入 HDFS 时，将文件依次划分为由字节范围确定的固定存储大小的小块。</p><p>在 Spark 中，第一步是将 HDFS 块导入 RDD 的内存数据结构中。可以使用不同的方法对 RDD 进行分区和重新分区，例如哈希、范围和自定义分区。</p><p>在 Hadoop clusters 中，关于分布式数据随机化的工作是 Cloud OnLine Aggregation（COLA）。它引入了一个预处理阶段</p><ul><li>使用 MapReduce 作业随机化 HDFS 中的数据。 在 Map 操作，一个介于 1 和 P（HDFS 块的数量）分配给每个记录在数据</li><li>然后，将每条记录写入Reduce 操作中分配的块。 在那之后，通过从 HDFS 顺序读取随机块，块级采样可用于在线聚合</li></ul><h4 id="1-HDFS-的问题"><a href="#1-HDFS-的问题" class="headerlink" title="1. HDFS 的问题"></a>1. HDFS 的问题</h4><ul><li>HDFS 没有考虑统计特性，如概率分布</li><li>Data Skew 数据倾斜：map 倾斜（不平衡的输入数据），reduce 倾斜（不平衡的中间数据）</li><li>采样与分区一起使用，可以减轻数据倾斜的影响并保证负载平衡</li></ul><h4 id="2-数据倾斜-Data-Skew"><a href="#2-数据倾斜-Data-Skew" class="headerlink" title="2. 数据倾斜 Data Skew"></a>2. 数据倾斜 Data Skew</h4><p><strong>数据倾斜：</strong>指数据集分布不均匀（uneven），大量相同的 key 被分配（partition）到同一个分区里，增加该分区的计算时间，最终降低整体的并行计算。因此负载均衡是提高并行计算效率的关键</p><p><strong>数据倾斜产生的原因</strong></p><ul><li>map 倾斜：输入文件的大小不均匀</li><li>reduce 倾斜：key 分布不均匀，导致 partition 不均匀</li></ul><p><strong>数据倾斜的解决办法</strong></p><ul><li>当出现小文件过多时，合并小文件。可以通过 set hive.merge.mapfiles=true 来解决</li><li>采样</li></ul><h3 id="2-2-3-采样"><a href="#2-2-3-采样" class="headerlink" title="2.2.3 采样"></a>2.2.3 采样</h3><p><strong>作用：</strong>采样部分数据作为一个子数据集，该子数据集与源数据集具有近似的数据分布，即能够通过子数据集近似得到源数据集的部分或全部信息</p><table><thead><tr><th>采样方法</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>伯努利采样 Bernoulli sampling</td><td>不放回抽样，每条记录至多被抽样一次</td><td>等概率抽样，抽样大小不固定</td><td>很难估计处理延迟，简单随机采样可以</td></tr><tr><td>简单随机采样 Simple random sampling</td><td>放回抽样，每条记录可能被多次抽样</td><td>等概率抽样，抽样大小固定</td><td>不能保证数据中的每组数据被等概率抽样，分层采样可以。不适用数据容量不知的情况</td></tr><tr><td>分层采样 Stratified sampling</td><td>数据集被分成多个层（分区），从每个组中等概率抽样一条记录</td><td>与简单随机采样相比，分层抽样有更高的统计精度和更低的抽样误差</td><td>在每个组中抽取一条记录耗时</td></tr><tr><td>蓄水池采样 Reservoir sampling</td><td>不放回抽样，抽样大小（蓄水池大小）固定。应用于数据监控中</td><td>在不知道数据容量时，每条记录被等概率抽样</td><td>不适合非等概率的场景</td></tr></tbody></table><h3 id="2-2-4-Hadoop-cluster-中的采样"><a href="#2-2-4-Hadoop-cluster-中的采样" class="headerlink" title="2.2.4 Hadoop cluster 中的采样"></a>2.2.4 Hadoop cluster 中的采样</h3><p>效率：block-level sampling &gt; record-level sampling</p><p>Spark 的采样函数可以分为两类：使用 sample() 函数的简单随机采样和使用 sampleByKey() 和 sampleByKeyExact() 的分层采样。</p><p>使用经典数据分区方法生成的数据块的块级采样不一定产生用于大数据近似计算的良好代表性样本</p><p>基于块级采样的 HDFS 块分区没考虑数据的统计特性，无法保证 HDFS 块是随机样本</p><h3 id="2-2-5-近似计算"><a href="#2-2-5-近似计算" class="headerlink" title="2.2.5 近似计算"></a>2.2.5 近似计算</h3><p><strong>作用：</strong>减少集群计算的开销，增加数据分析的效率</p><p><strong>关键：</strong>近似计算在准确性和效率之间进行权衡（trade-off）</p><p><strong>常见的近似计算方法：</strong>采样 sampling、素描 sketching、直方图 histograms 、在线聚合  online aggregation</p><h4 id="Hadoop-clusters-中基于采样的近似"><a href="#Hadoop-clusters-中基于采样的近似" class="headerlink" title="Hadoop clusters 中基于采样的近似"></a>Hadoop clusters 中基于采样的近似</h4><p><strong>三角平衡模型：</strong>Accuracy、Run-time、Resource usage </p><p><strong>ApproxHadoop：</strong>使用多阶段采样在 Hadoop MapReduce 中实现近似</p><p><strong>ApproxSpark：</strong>使用多阶段采样或自适应分层的水库采样在 Spark 中实现近似，它支持记录级和块级采样（也称为数据项级和分区级）。 然而，块级采样会导致更大的误差范围，因为 RDD 中的数据不一定是随机的</p><h2 id="2-3-总结和扩展"><a href="#2-3-总结和扩展" class="headerlink" title="2.3 总结和扩展"></a>2.3 总结和扩展</h2><h3 id="2-3-1-总结"><a href="#2-3-1-总结" class="headerlink" title="2.3.1 总结"></a>2.3.1 总结</h3><ul><li><p>分区和采样用于加速计算，具有高扩展性</p></li><li><p>分区和采样的数据质量直接影响近似计算的结果，应综合考虑三角平衡模型</p></li><li><p>Hadoop MapReduce 适合扫描整个大数据集一次的算法。由于繁重的 I/O 和通信成本，不适合迭代数据分析算法</p></li><li><p>Apache Spark 及其内存计算模型比 Hadoop MapReduce 中基于磁盘的集群计算要快得多，适合迭代算法</p></li></ul><h4 id="1-四个研究问题（Future-Work）"><a href="#1-四个研究问题（Future-Work）" class="headerlink" title="1. 四个研究问题（Future Work）"></a>1. 四个研究问题（Future Work）</h4><ul><li>考虑到内存可能永远不足以容纳整个数据集，因为数据增长速度快于技术扩展，如何从 Hadoop 集群上的大规模分布式数据集中抽取随机样本？</li><li>如何从大数据集中快速获取随机样本分区，以便数据科学家可以直接使用随机样本数据块，使用他们喜欢的技术和库来探索和分析大数据？</li><li>如何从大数据集的随机样本数据块中聚合本地结果，用于不同的数据分析和挖掘算法？</li><li>整个大数据集有多少数据才能近似得出与整个数据集结果相同的结果？</li></ul><h4 id="2-Challenges"><a href="#2-Challenges" class="headerlink" title="2. Challenges"></a>2. Challenges</h4><ul><li>在无共享架构的计算集群中，当考虑基于块的组织和内存、I/O 和通信的高成本时，采样是一项挑战</li><li>获取小的不相交的随机样本仍然是集群计算框架中的一个挑战</li><li>当不清楚数据集的统计信息时，不能随意进行随机抽样，建议同一数据集上的多种采样策略将能够更有效地评估数据集</li></ul><h4 id="3-My-Future-Work"><a href="#3-My-Future-Work" class="headerlink" title="3. My Future Work"></a>3. My Future Work</h4><ul><li>如何建立适合自己模型的三角平衡模型，</li><li>分区和采样的计算成本很大（遍历），有没有可能优化？</li><li>如何采样得到不相交的随机样本（至多被采样一次）</li></ul><h3 id="2-3-2-扩展"><a href="#2-3-2-扩展" class="headerlink" title="2.3.2 扩展"></a>2.3.2 扩展</h3><h4 id="1-随机样本划分-Random-Sample-Partition（RSP）"><a href="#1-随机样本划分-Random-Sample-Partition（RSP）" class="headerlink" title="1. 随机样本划分 Random Sample Partition（RSP）"></a>1. 随机样本划分 Random Sample Partition（RSP）</h4><p>随机抽样的计算成本很高，因为要对分布式数据块文件（如 HDFS）进行遍历才能获得随机样本数据，这一过程需要大量的磁盘读写操作和节点间的数据通信</p><p><strong>思考：</strong>如果分布式数据块可以直接当作样本数据来用，那么就不需要随机抽样了</p><p><strong>关键：</strong>每个数据块的样本数据分布与整个大数据的数据分布需保持一致，这样才能用一个数据块的样本数据估计整体的数据。选取的数据块越多，估计误差也越小</p><h4 id="2-RSP-模型"><a href="#2-RSP-模型" class="headerlink" title="2. RSP 模型"></a>2. RSP 模型</h4><p><strong>核心思想：</strong>将大数据文件划分成许多小的随机样本划分数据块文件，即每个数据块文件是大数据文件的一个随机样本数据。这样的划分给大数据分析带来两个好处：</p><ul><li>随机样本数据可以直接选取整个数据块文件（Block-Level Sampling，BLS 或 Partition-Level Sampling, PLS），不需要对大数据的单个记录进行抽样（Record-Level Sampling，RLS），避免了随机抽样的遍历操作。Spark 使用的是 PLS</li><li>通过对少量数据块文件的分析和建模即可得到大数据的统计估计结果和模型</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分区</tag>
      
      <tag>采样</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 递归与回溯</title>
    <link href="/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1%20%E5%9B%9E%E6%BA%AF/"/>
    <url>/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1%20%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-N-皇后"><a href="#1-1-N-皇后" class="headerlink" title="1.1 N 皇后"></a>1.1 N 皇后</h2><h3 id="1-1-1-题目"><a href="#1-1-1-题目" class="headerlink" title="1.1.1 题目"></a>1.1.1 题目</h3><p><a href="https://leetcode-cn.com/problems/n-queens/">LeetCode | 51. N 皇后</a></p><h3 id="1-1-2-Code"><a href="#1-1-2-Code" class="headerlink" title="1.1.2 Code"></a>1.1.2 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Set&lt;Integer&gt; cols = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    Set&lt;Integer&gt; diag1 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-comment">// 对角线：\</span><br>    Set&lt;Integer&gt; diag2 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-comment">// 对角线：/</span><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] queens = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(queens, -<span class="hljs-number">1</span>);<br>        backtrack(<span class="hljs-number">0</span>, queens, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span>[] queens, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            List&lt;String&gt; board = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">char</span>[] rowChars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>                Arrays.fill(rowChars, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                rowChars[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                board.add(<span class="hljs-keyword">new</span> String(rowChars));<br>            &#125;<br>            res.add(board);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>                <span class="hljs-keyword">if</span> (cols.contains(col)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> d1 = row - col;<br>                <span class="hljs-keyword">if</span> (diag1.contains(d1)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> d2 = row + col;<br>                <span class="hljs-keyword">if</span> (diag2.contains(d2)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                queens[row] = col;<br>                cols.add(col);<br>                diag1.add(d1);<br>                diag2.add(d2);<br><br>                backtrack(row + <span class="hljs-number">1</span>, queens, n);<br>                queens[row] = -<span class="hljs-number">1</span>;<br>                cols.remove(col);<br>                diag1.remove(d1);<br>                diag2.remove(d2);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-解数独"><a href="#1-2-解数独" class="headerlink" title="1.2 解数独"></a>1.2 解数独</h2><h3 id="1-2-1-题目"><a href="#1-2-1-题目" class="headerlink" title="1.2.1 题目"></a>1.2.1 题目</h3><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">LeetCode | 37. 解数独</a></p><h3 id="1-2-2-Code"><a href="#1-2-2-Code" class="headerlink" title="1.2.2 Code"></a>1.2.2 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">boolean</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">boolean</span>[][][] blocks = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">boolean</span> finished = <span class="hljs-keyword">false</span>;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> digit = board[i][j] - <span class="hljs-number">49</span>;<br>                    rows[i][digit] = cols[j][digit] = blocks[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        backtrack(board, <span class="hljs-number">0</span>);<br>show(board);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == spaces.size()) &#123;<br>            finished = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] space = spaces.get(pos);<br>        <span class="hljs-keyword">int</span> i = space[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> j = space[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> digit = <span class="hljs-number">0</span>; !finished &amp;&amp; digit &lt; <span class="hljs-number">9</span>; digit++) &#123;<br>            <span class="hljs-keyword">if</span> (!rows[i][digit] &amp;&amp; !cols[j][digit] &amp;&amp; !blocks[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit]) &#123;<br>                rows[i][digit] = cols[j][digit] = blocks[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-keyword">true</span>;<br>                board[i][j] = (<span class="hljs-keyword">char</span>) (digit + <span class="hljs-number">49</span>);<br>                backtrack(board, pos + <span class="hljs-number">1</span>);<br>                rows[i][digit] = cols[j][digit] = blocks[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] chars : board) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;<br>                System.out.print(c + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        Solution solution = <span class="hljs-keyword">new</span> Solution();<br>        solution.solveSudoku(board);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-汉诺塔"><a href="#1-3-汉诺塔" class="headerlink" title="1.3 汉诺塔"></a>1.3 汉诺塔</h2><h3 id="1-3-1-题目"><a href="#1-3-1-题目" class="headerlink" title="1.3.1 题目"></a>1.3.1 题目</h3><p><a href="https://leetcode-cn.com/problems/hanota-lcci/">面试题 08.06. 汉诺塔问题</a></p><h3 id="1-3-2-Code"><a href="#1-3-2-Code" class="headerlink" title="1.3.2 Code"></a>1.3.2 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题 08.06. 汉诺塔（分治 + 递归）</span><br><span class="hljs-comment"> * 时间：O(2^n - 1)</span><br><span class="hljs-comment"> * -------------------------</span><br><span class="hljs-comment"> * 设 n 个盘子的移动次数为 T(n)</span><br><span class="hljs-comment"> * T(n) = 2 T(n-1) + 1</span><br><span class="hljs-comment"> * T(1) = 1</span><br><span class="hljs-comment"> * -------------------------</span><br><span class="hljs-comment"> * T(n) = 2^n - 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanota</span><span class="hljs-params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;<br>    move(A.size(), A, B, C);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        C.add(A.remove(A.size() - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    move(n - <span class="hljs-number">1</span>, A, C, B);<br>    C.add(A.remove(A.size() - <span class="hljs-number">1</span>));<br>    move(n - <span class="hljs-number">1</span>, B, A, C);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本命令</title>
    <link href="/2021/08/17/MySQL/%E7%AC%AC2%E7%AB%A0%20%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/17/MySQL/%E7%AC%AC2%E7%AB%A0%20%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-数据库语言（增删改查-CRUD）"><a href="#2-1-数据库语言（增删改查-CRUD）" class="headerlink" title="2.1 数据库语言（增删改查 CRUD）"></a>2.1 数据库语言（增删改查 CRUD）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DDL-- 定义<br>DML-- 操作<br>DQL-- 查询<br>DCL-- 控制<br></code></pre></td></tr></table></figure><p>每个表必须包含 5 个字段，保证一个字段存在的意义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">id      -- 主键<br>version -- 乐观锁<br>is_delete-- 伪删除<br>gmt_create-- 创建时间<br>gmt_update-- 修改时间<br></code></pre></td></tr></table></figure><h2 id="2-2-数据库"><a href="#2-2-数据库" class="headerlink" title="2.2 数据库"></a>2.2 数据库</h2><p>MySQL 关键字不区分大小写，<code>[]</code> 是可选语句</p><h4 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create databases [if not exists] home;<br></code></pre></td></tr></table></figure><h4 id="2-删除"><a href="#2-删除" class="headerlink" title="2.  删除"></a>2.  删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop databases [if exists] home;<br></code></pre></td></tr></table></figure><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use home;-- 使用 &#96;home&#96;，数据库名可以是关键字，例如 use &#96;user&#96;;<br></code></pre></td></tr></table></figure><h4 id="4-查看"><a href="#4-查看" class="headerlink" title="4. 查看"></a>4. 查看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs `mysql">show databases;<br></code></pre></td></tr></table></figure><h2 id="2-3-数据库表"><a href="#2-3-数据库表" class="headerlink" title="2.3 数据库表"></a>2.3 数据库表</h2><h3 id="2-3-1-创建"><a href="#2-3-1-创建" class="headerlink" title="2.3.1 创建"></a>2.3.1 创建</h3><p><img src="https://e.im5i.com/2021/08/25/3G4BG.png" alt="Table"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS &#96;student&#96; (<br>&#96;id&#96; INT(4) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,<br>&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;华生&#39; COMMENT &#39;姓名&#39;,<br>&#96;password&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123&#39; COMMENT &#39;密码&#39;,<br>&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;,<br>&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,<br>&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭地址&#39;,<br>&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,<br>PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8<br><br>SHOW CREATE DATABASE shcool;-- 查看创建数据库的语句<br>SHOW CREATE TABLE student;-- 查看创建表的语句<br>DESC student;-- 查看表的结构<br></code></pre></td></tr></table></figure><p><img src="https://e.im5i.com/2021/08/25/3GInY.png" alt="Output"></p><h3 id="2-3-2-引擎"><a href="#2-3-2-引擎" class="headerlink" title="2.3.2 引擎"></a>2.3.2 引擎</h3><table><thead><tr><th></th><th>MyISAM（MySQL 5.5 之前）</th><th>InnoDB（现在的默认引擎）</th></tr></thead><tbody><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持行锁</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间大小</td><td>小</td><td>大，约为 2 倍</td></tr></tbody></table><ul><li>MyISAM：节约空间、速度快</li><li>InnoDB：安全性高、事务的处理、多表多用户操作</li></ul><h3 id="2-3-3-数据库的文件结构"><a href="#2-3-3-数据库的文件结构" class="headerlink" title="2.3.3 数据库的文件结构"></a>2.3.3 数据库的文件结构</h3><p>对于 Win，所有数据库都在 data 目录下，一个文件夹对应一个数据库</p><p>InnoDB</p><ul><li><code>.frm</code> 文件</li><li>上级目录中的 <code>ibdata1</code> 文件</li></ul><p>MyISAM</p><ul><li><code>.frm</code>：表结构的定义文件</li><li><code>.MYD</code>：数据文件 data</li><li><code>.MYI</code>：索引文件 index</li></ul><h3 id="2-3-4-操作"><a href="#2-3-4-操作" class="headerlink" title="2.3.4 操作"></a>2.3.4 操作</h3><h4 id="1-修改"><a href="#1-修改" class="headerlink" title="1. 修改"></a>1. 修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student RENAME AS student1;-- 重命名表名<br>ALTER TABLE student1 ADD age INT(10);-- 增加字段<br><br>ALTER TABLE student1 MODIFY age VARCHAR(10);-- 修改约束<br>ALTER TABLE student1 CHANGE age age1 INT(10);-- 重命名字段<br><br>ALTER TABLE student1 DROP age1;-- 删除字段<br></code></pre></td></tr></table></figure><h4 id="2-删除-1"><a href="#2-删除-1" class="headerlink" title="2. 删除"></a>2. 删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS runoob_tbl;<br></code></pre></td></tr></table></figure><h2 id="2-3-数据管理"><a href="#2-3-数据管理" class="headerlink" title="2.3 数据管理"></a>2.3 数据管理</h2><h3 id="2-3-1-外键"><a href="#2-3-1-外键" class="headerlink" title="2.3.1 外键"></a>2.3.1 外键</h3><p>阿里 Java 规范</p><blockquote><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决</p></blockquote><p>原因</p><blockquote><p>每次做 delete 或者 update 都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便</p></blockquote><p>下面是两种物理外键：数据库级别的外键，不建议使用（了解即可）</p><p>法一：创建表时增加外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 删除 grade 表（主表）之前，必须先删除 student 表（从表）<br>CREATE TABLE &#96;grade&#96; (<br>&#96;gradeID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级id&#39;,<br>&#96;gradeName&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,<br>PRIMARY KEY (&#96;gradeID&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;-- ; 号不能少<br><br>-- 学生表的 gradeID 字段引用年级表的 gradeID<br>-- 1. 定义外键 FK_gradeID<br>-- 2. 给 FK_gradeID 添加约束（执行引用）<br>CREATE TABLE IF NOT EXISTS &#96;student&#96; (<br>&#96;id&#96; INT(4) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,<br>&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;华生&#39; COMMENT &#39;姓名&#39;,<br>&#96;password&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123&#39; COMMENT &#39;密码&#39;,<br>&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;,<br>&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,<br>&#96;gradeID&#96; INT(10) NOT NULL COMMENT &#39;年级id&#39;,-- 不能是 AUTO_INCREMENT，一个表中只能有一个 AUTO_INCREMENT<br>&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭地址&#39;,<br>&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,<br>PRIMARY KEY (&#96;id&#96;),<br>KEY &#96;FK_gradeID&#96; (&#96;gradeID&#96;),<br>CONSTRAINT &#96;FK_gradeID&#96; FOREIGN KEY (&#96;gradeID&#96;) REFERENCES &#96;grade&#96;(&#96;gradeID&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;<br></code></pre></td></tr></table></figure><p>法二：创建表时不增加外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS &#96;grade&#96; (<br>&#96;gradeID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级id&#39;,<br>&#96;gradeName&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,<br>PRIMARY KEY (&#96;gradeID&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;<br><br>-- 创建表时不增加外键<br>CREATE TABLE IF NOT EXISTS &#96;student&#96; (<br>&#96;id&#96; INT(4) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,<br>&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;华生&#39; COMMENT &#39;姓名&#39;,<br>&#96;password&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123&#39; COMMENT &#39;密码&#39;,<br>&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;,<br>&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,<br>&#96;gradeID&#96; INT(10) NOT NULL COMMENT &#39;年级id&#39;,<br>&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭地址&#39;,<br>&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,<br>PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;<br><br>-- 增加外键<br>ALTER TABLE &#96;student&#96; ADD CONSTRAINT &#96;FK_gradeID&#96; FOREIGN KEY(&#96;gradeID&#96;) REFERENCES &#96;grade&#96;(&#96;gradeID&#96;);<br></code></pre></td></tr></table></figure><h3 id="2-3-2-DML-语言（记）"><a href="#2-3-2-DML-语言（记）" class="headerlink" title="2.3.2 DML 语言（记）"></a>2.3.2 DML 语言（记）</h3><p>DML（Data Manipulation Language）</p><h4 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 单字段，单值<br>INSERT INTO &#96;grade&#96;(&#96;gradeName&#96;) VALUES (&#39;大四&#39;);-- id 自增，可以省略<br><br>-- 单字段，多值<br>INSERT INTO &#96;grade&#96;(&#96;gradeName&#96;) VALUES (&#39;大一&#39;), (&#39;大二&#39;);<br><br>-- 多字段，多值<br>INSERT INTO &#96;student&#96;(&#96;name&#96;, &#96;password&#96;, &#96;sex&#96;) VALUES (&#39;浮梁&#39;, &#39;123456&#39;, &#39;男&#39;), (&#39;Apache&#39;, &#39;666666&#39;, &#39;女&#39;);<br><br>-- 可以省略字段，但必须与所有字段一一对应<br>INSERT INTO &#96;student&#96; VALUES (100, &#39;浮梁&#39;, &#39;123456&#39;, &#39;男&#39;, &#39;2021-08-29&#39;, &#39;101&#39;, &#39;东莞&#39;, &#39;email&#39;);<br><br>-- 错误，必须保证字段和值一一对应<br>INSERT INTO &#96;grade&#96; VALUES (&#39;大四&#39;);<br></code></pre></td></tr></table></figure><h4 id="2-更新"><a href="#2-更新" class="headerlink" title="2. 更新"></a>2. 更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 带条件<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;Docker&#39; WHERE id &#x3D; 1; -- 等于<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;Docker000&#39; WHERE id !&#x3D; 1;-- 不等于，也可以使用 &lt;&gt;<br>UPDATE &#96;student&#96; SET &#96;birthday&#96;&#x3D;CURRENT_TIME WHERE id &gt; 2;-- 设置变量<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;Docker111&#39; WHERE id BETWEEN 1 AND 3;-- [1, 3]<br><br>-- 不带条件，修改所有<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;Spark&#39;;<br><br>-- 多字段<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;Apache&#39;, &#96;password&#96;&#x3D;&#39;0xffff&#39; WHERE id &lt;&#x3D; 100;<br><br>-- 多条件<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;张三&#39; WHERE &#96;name&#96;&#x3D;&#39;Hadoop&#39; AND &#96;sex&#96;&#x3D;&#39;女&#39;;<br>UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&#39;张三&#39; WHERE &#96;name&#96;&#x3D;&#39;Hadoop&#39; OR &#96;sex&#96;&#x3D;&#39;女&#39;;<br></code></pre></td></tr></table></figure><h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h4><p>（1）delete 和 truncate 的异同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE &#96;test&#96; (<br>&#96;id&#96; INT(4) NOT NULL AUTO_INCREMENT,<br>&#96;coll&#96; VARCHAR(20) NOT NULL,<br>PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;<br><br>INSERT INTO &#96;test&#96;(&#96;coll&#96;) VALUES (&#39;1&#39;),(&#39;2&#39;);<br><br>DELETE FROM &#96;test&#96; WHERE &#96;id&#96; &#x3D; 1;<br>DELETE FROM &#96;test&#96;;-- AUTO_INCREMENT 不清零<br>TRUNCATE TABLE &#96;test&#96;;-- AUTO_INCREMENT 清零<br></code></pre></td></tr></table></figure><ul><li>同：都能删除数据，不删除表结构（保留字段名）</li><li>异：<code>truncate</code> 自增变量 <code>auto_increment</code> 清零，不会影响事务；<code>delete</code> 不清零（不重启）</li></ul><p>（2）delete 的注意事项</p><ul><li>使用 InnoDB 引擎：<code>auto_increment</code> 重启后清零，因为变量存在内存中（未持久化）</li><li>使用 MyISAM 引擎：<code>auto_increment</code> 重启不清零，因为变量存在文件中</li></ul><h3 id="2-3-3-DQL-查询（最重要）"><a href="#2-3-3-DQL-查询（最重要）" class="headerlink" title="2.3.3 DQL 查询（最重要）"></a>2.3.3 DQL 查询（最重要）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS &#96;school&#96;;<br>USE &#96;school&#96;;<br><br>-- 学生<br>DROP TABLE IF EXISTS &#96;student&#96;;<br>CREATE TABLE &#96;student&#96; (<br>    &#96;StudentNum&#96; INT(4) NOT NULL COMMENT &#39;学号&#39;,<br>    &#96;Password&#96; VARCHAR(20) DEFAULT NULL COMMENT &#39;登录密码&#39;,<br>    &#96;StudentName&#96; VARCHAR(20) DEFAULT NULL COMMENT &#39;姓名&#39;,<br>    &#96;Sex&#96; TINYINT(1) DEFAULT NULL COMMENT &#39;性别，0或1&#39;,<br>    &#96;GradeID&#96; INT(11) DEFAULT NULL COMMENT &#39;年级编号&#39;,<br>    &#96;Phone&#96; VARCHAR(50) NOT NULL COMMENT &#39;联系电话，允许为空&#39;,<br>    &#96;Address&#96; VARCHAR(255) NOT NULL COMMENT &#39;地址，允许为空&#39;,<br>    &#96;Birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,<br>    &#96;Email&#96; VARCHAR (50) NOT NULL COMMENT &#39;邮箱账号允许为空&#39;,<br>    &#96;IDCard&#96; VARCHAR(18) DEFAULT NULL COMMENT &#39;身份证号&#39;,<br>    PRIMARY KEY (&#96;StudentNum&#96;),<br>    UNIQUE KEY &#96;IDCard&#96;(&#96;IDCard&#96;),<br>    KEY &#96;Email&#96;(&#96;Email&#96;)<br>) ENGINE &#x3D; MYISAM DEFAULT CHARSET &#x3D; utf8;<br><br>INSERT INTO &#96;student&#96;(&#96;StudentNum&#96;, &#96;Password&#96;, &#96;StudentName&#96;, &#96;Sex&#96;, &#96;GradeID&#96;, &#96;Phone&#96;, &#96;Address&#96;, &#96;Birthday&#96;, &#96;Email&#96;,&#96;IDCard&#96;) VALUES<br>    (1000, &#39;123456&#39;, &#39;张伟&#39;, 0 , 2, &#39;13800001234&#39;, &#39;北京&#39;, &#39;1980-1-31&#39;, &#39;text123@qq.com&#39;, &#39;123456198001011234&#39;),<br>    (1001, &#39;123456&#39;, &#39;中二&#39;, 1 , 3, &#39;13800002222&#39;, &#39;广东&#39;, &#39;1990-1-25&#39;, &#39;text111@qq.com&#39;, &#39;123456199009576867&#39;),<br>    (1002, &#39;666666&#39;, &#39;张大江&#39;, 0 , 2, &#39;13800001654&#39;, &#39;四川&#39;, &#39;1998-2-1&#39;, &#39;text666@qq.com&#39;, &#39;123456198008765867&#39;),<br>    (1003, &#39;000000&#39;, &#39;张三&#39;, 0 , 1, &#39;13800001111&#39;, &#39;四川&#39;, &#39;2000-7-28&#39;, &#39;text922@qq.com&#39;, &#39;123456198008678567&#39;),<br>    (1004, &#39;222222&#39;, &#39;李四&#39;, 1 , 4, &#39;13800006666&#39;, &#39;广东&#39;, &#39;2001-6-14&#39;, &#39;text156@qq.com&#39;, &#39;123456199006747456&#39;),<br>    (1005, &#39;555555&#39;, &#39;王五&#39;, 0 , 4, &#39;13800008888&#39;, &#39;上海&#39;, &#39;2010-4-29&#39;, &#39;text234@qq.com&#39;, &#39;123456198004535235&#39;);<br><br><br><br>-- 年级<br>DROP TABLE IF EXISTS &#96;grade&#96;;<br>CREATE TABLE &#96;grade&#96; (<br>&#96;GradeID&#96; INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;年级编号&#39;,<br>&#96;GradeName&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,<br>    PRIMARY KEY (&#96;GradeID&#96;)<br>) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 6 DEFAULT CHARSET &#x3D; utf8;<br><br>INSERT INTO &#96;grade&#96;(&#96;GradeID&#96;,&#96;GradeName&#96;) VALUES<br>    (1, &#39;大一&#39;),<br>    (2, &#39;大二&#39;),<br>    (3, &#39;大三&#39;),<br>    (4, &#39;大四&#39;);<br><br><br>-- 课程<br>DROP TABLE IF EXISTS &#96;subject&#96;;<br>CREATE TABLE &#96;subject&#96; (<br>&#96;SubjectNum&#96;INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;课程编号&#39;,<br>    &#96;SubjectName&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;课程名称&#39;,<br>    &#96;ClassHour&#96; INT(4) DEFAULT NULL COMMENT &#39;学时&#39;,<br>    &#96;GradeID&#96; INT(4) DEFAULT NULL COMMENT &#39;年级编号&#39;,<br>    PRIMARY KEY (&#96;SubjectNum&#96;)<br>) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 18 DEFAULT CHARSET &#x3D; utf8;   -- 课程编号最大为 17<br><br>INSERT INTO &#96;subject&#96;(&#96;SubjectNum&#96;, &#96;SubjectName&#96;, &#96;ClassHour&#96;, &#96;GradeID&#96;) VALUES<br>    (1, &#39;高等数学-1&#39;, 110,1),<br>    (2, &#39;高等数学-2&#39;, 110,2),<br>    (3, &#39;高等数学-3&#39;, 100,3),<br>    (4, &#39;高等数学-4&#39;, 130,4),<br>    (5, &#39;C语言-1&#39;, 110,1),<br>    (6, &#39;C语言-2&#39;, 110,2),<br>    (7, &#39;C语言-3&#39;, 100,3),<br>    (8, &#39;C语言-4&#39;, 130,4),<br>    (9, &#39;Java程序设计-1&#39;, 110,1),<br>    (10, &#39;Java程序设计-2&#39;, 110,2),<br>    (11, &#39;Java程序设计-3&#39;, 100,3),<br>    (12, &#39;Java程序设计-4&#39;, 130,4),<br>    (13, &#39;数据库结构-1&#39;, 110,1),<br>    (14, &#39;数据库结构-2&#39;, 110,2),<br>    (15, &#39;数据库结构-3&#39;, 100,3),<br>    (16, &#39;数据库结构-4&#39;, 130,4),<br>    (17, &#39;C#基础&#39;, 130,1);<br><br><br>-- 成绩<br>DROP TABLE IF EXISTS &#96;score&#96;;<br>CREATE TABLE &#96;score&#96; (<br>&#96;StudentNum&#96; INT(4) NOT NULL COMMENT &#39;学号&#39;,<br>    &#96;SubjectNum&#96; INT(4) NOT NULL COMMENT &#39;课程编号&#39;,<br>    &#96;ExamData&#96; DATETIME NOT NULL COMMENT &#39;考试日期&#39;,<br>    &#96;Score&#96; INT (4) NOT NULL COMMENT &#39;考试成绩&#39;,<br>    KEY &#96;SubjectNum&#96; (&#96;SubjectNum&#96;)<br>) ENGINE &#x3D; INNODB DEFAULT CHARSET &#x3D; utf8;<br><br>INSERT INTO &#96;score&#96;(&#96;StudentNum&#96;, &#96;SubjectNum&#96;, &#96;ExamData&#96;, &#96;Score&#96;) VALUES<br>    (1000, 1, &#39;2013-11-11 16:00:00&#39;, 85),<br>    (1000, 2, &#39;2013-11-12 16:00:00&#39;, 70),<br>    (1000, 5, &#39;2013-11-13 09:00:00&#39;, 68),<br>        <br>    (1001, 4, &#39;2015-11-11 16:00:00&#39;, 90),<br>    (1001, 5, &#39;2015-11-12 16:00:00&#39;, 85),<br>    (1001, 7, &#39;2015-11-13 09:00:00&#39;, 55),<br><br>    (1002, 5, &#39;2015-11-11 16:00:00&#39;, 99),<br>    (1002, 2, &#39;2015-11-12 16:00:00&#39;, 75),<br>    (1002, 8, &#39;2015-11-13 09:00:00&#39;, 95),<br><br>    (1003, 5, &#39;2015-11-11 16:00:00&#39;, 60),<br>    (1003, 9, &#39;2015-11-12 16:00:00&#39;, 88),<br>    (1003, 14, &#39;2015-11-13 09:00:00&#39;, 69),<br><br>    (1004, 17, &#39;2015-11-11 16:00:00&#39;, 80),<br>    (1004, 5, &#39;2015-11-12 16:00:00&#39;, 76),<br>    (1004, 8, &#39;2015-11-13 09:00:00&#39;, 66),<br>    <br>    (1005, 1, &#39;2015-11-11 16:00:00&#39;, 99),<br>    (1005, 5, &#39;2015-11-12 16:00:00&#39;, 84),<br>    (1005, 3, &#39;2015-11-13 09:00:00&#39;, 82);<br></code></pre></td></tr></table></figure><h4 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h4><p>模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [ALL | DISTINCT]<br>* | table.* | [table.field1 [AS alias1], table.field2 [AS alias2], ...]<br>FROM table_name [AS table_alias]<br>[LEFT | RIGHT | INNER JOIN Table1 ON Table2]-- 连接查询，Table1 连接 Table2<br>[WHERE ...]-- 条件<br>[GROUP BY ...]-- 分组<br>[HAVING ...]-- 分组条件，与 where 一样，只是位置不同<br>[ORDER BY ...]-- 排序<br>[LIMIT begPos len]-- 查询从第 begPos（从 0 开始） 开始的 len 条记录<br></code></pre></td></tr></table></figure><p>（1）实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM student;                              -- 查询全部学生<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96;;   -- 查询全部学生的学号和姓名<br>SELECT &#96;StudentNum&#96; AS 学号, &#96;StudentName&#96; AS 姓名 FROM &#96;student&#96; AS s;   -- 取别名<br>SELECT CONCAT(&#39;姓名：&#39;, &#96;StudentName&#96;) AS 新名字 FROM &#96;student&#96;;       -- Concat(a, b) 函数<br></code></pre></td></tr></table></figure><p>（2）去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#96;StudentNum&#96; FROM &#96;score&#96;;<br>SELECT DISTINCT &#96;StudentNum&#96; FROM &#96;score&#96;;-- 去重，哪些同学参加了考试（有成绩）<br></code></pre></td></tr></table></figure><p>（3）表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT VERSION();-- 数据库版本<br>SELECT 100 * 2 - 1;-- 计算表达式<br>SELECT @@auto_increment_increment;  -- 变量：自增步长<br><br>-- 所有成绩都 +1<br>SELECT &#96;StudentNum&#96;, &#96;Score&#96; + 1 AS 提分后 FROM &#96;score&#96;;<br></code></pre></td></tr></table></figure><h4 id="2-where"><a href="#2-where" class="headerlink" title="2. where"></a>2. where</h4><p>（1）逻辑运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">AND   &amp;&amp;<br>OR    ||<br>NOT   !&#x3D;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 区间<br>SELECT &#96;StudentNum&#96;, &#96;Score&#96; FROM &#96;score&#96; WHERE &#96;Score&#96; &gt;&#x3D; 90 AND &#96;Score&#96; &lt;&#x3D; 100;<br>SELECT &#96;StudentNum&#96;, &#96;Score&#96; FROM &#96;score&#96; WHERE &#96;Score&#96; BETWEEN 90 AND 100;<br><br>-- 除了 1000 号之外的成绩<br>SELECT &#96;StudentNum&#96;, &#96;Score&#96; FROM &#96;score&#96; WHERE &#96;StudentNum&#96; !&#x3D; 1000;<br>SELECT &#96;StudentNum&#96;, &#96;Score&#96; FROM &#96;score&#96; WHERE NOT &#96;StudentNum&#96; &#x3D; 1000;<br></code></pre></td></tr></table></figure><p>（2）模糊查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">a IS NULL-- a 为 NULL<br>a IS NOT NULL-- a 不为 NULL<br>a BETWEEN b AND C-- a 在 [b, c]<br>a Like b-- a 匹配 b<br>a In (a1, a2, a3)-- a 在 (a1, a2, a3) 中<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ---------------- LIKE -----------------<br><br>-- 查询 “张” 姓同学<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentName&#96; LIKE &#39;张%&#39;;    -- % 表示任意个字符<br><br>-- 查询 “张” 姓的两字同学<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentName&#96; LIKE &#39;张_&#39;;    -- _ 表示一个字符<br><br>-- 查询 “张” 姓的三字同学<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentName&#96; LIKE &#39;张__&#39;;<br><br>-- 查询名字中有 “大” 的同学<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentName&#96; LIKE &#39;%大%&#39;;<br><br><br>-- ---------------- IN -----------------<br><br>-- 查询 1000, 1001 号同学<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentNum&#96; IN (1000, 1001);<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;StudentNum&#96; &#x3D; 1000 OR &#96;StudentNum&#96; &#x3D; 1001;<br><br>-- 查询地址为空 <br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;Address&#96; &#x3D; &#39;&#39; OR &#96;Address&#96; IS NULL;<br><br>-- 查询有出生日期的同学（is not null）<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96; FROM &#96;student&#96; WHERE &#96;Birthday&#96; IS NOT NULL;<br></code></pre></td></tr></table></figure><h4 id="3-连接查询"><a href="#3-连接查询" class="headerlink" title="3.  连接查询"></a>3.  连接查询</h4><p><img src="https://e.im5i.com/2021/09/03/A0YeM.png" alt="7 种 join"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;** 基本思路<br> 1. 确定字段分别来自哪些表<br> 2. 确定使用哪种查询？（7 种）<br> 3. 哪些字段是各表中共有的？<br> *&#x2F;<br> <br>-- Join On 连接查询<br>-- Where   等值查询<br><br>-- 1. 查询参加了考试的同学（学号，姓名，科目编号，分数）<br><br>&#x2F;**<br> 学号：    student, score<br> 姓名：    student<br> 科目编号：score<br> 分数：    score <br> *&#x2F;<br><br>-- Inner Join<br>-- StudentNum 是 student 和 socre 中共有的，必须指定一个，如 s.StudentNum<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectNum&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; AS s<br>INNER JOIN &#96;score&#96; AS r<br>ON s.StudentNum &#x3D; r.StudentNum; -- 也可以用 where<br><br>-- Right Join（返回右表 r 中的所有 StudentNum，即使左表 s 中没有匹配项）<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectNum&#96;, &#96;Score&#96;<br>FROM student s                          -- 可以省略 AS<br>RIGHT JOIN score r<br>ON r.&#96;StudentNum&#96; &#x3D; s.&#96;StudentNum&#96;;<br><br>-- Left Join（返回左表 s 中的所有 StudentNum，即使右表 r 中没有匹配项）<br>-- 仍然显示未参加考试的同学：小明<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectNum&#96;, &#96;Score&#96;<br>FROM student s<br>LEFT JOIN score r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;;<br><br>-- 查询缺考的同学（student 中包含了所有的同学，应使用 Left Join）<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectNum&#96;, &#96;Score&#96;<br>FROM student s<br>LEFT JOIN score r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;<br>WHERE &#96;score&#96; IS NULL;<br><br><br>-- 2. 查询参加了考试的同学（学号，姓名，科目名，分数）<br><br>&#x2F;**<br> 学号：  student, score<br> 姓名：  student<br> 科目名：subject（通过 SubjectNum 连接 [subject, score] 得到 SubjectName）<br> 分数：  score <br> *&#x2F;<br><br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectName&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; s<br>RIGHT JOIN &#96;score&#96; r<br>ON r.&#96;StudentNum&#96; &#x3D; s.&#96;StudentNum&#96;     -- StudentNum 在 score, subject 中<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;;<br><br>-- 3. 查询同学所属的年级（学号，学生姓名，年级名称）<br>SELECT &#96;StudentName&#96;, &#96;GradeName&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;grade&#96; g<br>ON s.&#96;GradeID&#96; &#x3D; g.&#96;GradeID&#96;;<br><br>-- 4. 查询科目所属的年级（科目名称，年级名称）<br>SELECT &#96;SubjectName&#96;, &#96;GradeName&#96;<br>FROM &#96;subject&#96; sub<br>INNER JOIN &#96;grade&#96; g<br>ON sub.&#96;GradeID&#96; &#x3D; g.&#96;GradeID&#96;;<br><br>-- 5. 查询参加 [高等数学] 考试的同学信息（学号，学生姓名，科目名，分数）<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectName&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;score&#96; r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;<br>WHERE &#96;SubjectName&#96; LIKE &#39;高等数学-_&#39;;<br></code></pre></td></tr></table></figure><p><strong>自链接</strong></p><p>核心：一张表拆成两张一样的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS &#96;category&#96;;<br>CREATE TABLE &#96;category&#96; (<br>&#96;CategoryID&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;类别 ID&#39;,<br>    &#96;PID&#96; INT(10) NOT NULL COMMENT &#39;父 ID&#39;,<br>    &#96;CategoryName&#96; VARCHAR(50) NOT NULL COMMENT &#39;类别名&#39;,<br>    PRIMARY KEY (&#96;CategoryID&#96;)<br>) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 9 DEFAULT CHARSET &#x3D; utf8;<br><br>INSERT INTO &#96;category&#96; (&#96;CategoryID&#96;, &#96;PID&#96;, &#96;CategoryName&#96;)<br>VALUES<br>    (2, 1, &#39;信息技术&#39;),<br>    (3, 1, &#39;软件开发&#39;),<br>    (4, 3, &#39;数据库&#39;),<br>    (5, 1, &#39;美术设计&#39;),<br>    (6, 3, &#39;Web 开发&#39;),<br>    (7, 5, &#39;PS 技术&#39;),<br>    (8, 2, &#39;办公信息&#39;);<br>    <br>    <br>SELECT father.&#96;CategoryName&#96; AS &#39;Father&#39;, son.&#96;CategoryName&#96; AS &#39;Son&#39;<br>FROM &#96;category&#96; AS father, &#96;category&#96; AS son<br>WHERE father.&#96;CategoryID&#96; &#x3D; son.&#96;PID&#96;<br></code></pre></td></tr></table></figure><p>父类</p><table><thead><tr><th>CategoryID</th><th>CategoryName</th></tr></thead><tbody><tr><td>2</td><td>信息技术</td></tr><tr><td>3</td><td>软件开发</td></tr><tr><td>5</td><td>美术设计</td></tr></tbody></table><p>子类</p><table><thead><tr><th>PID</th><th>CategoryID</th><th>CategoryName</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>数据库</td></tr><tr><td>2</td><td>8</td><td>办公信息</td></tr><tr><td>3</td><td>6</td><td>Web 开发</td></tr><tr><td>5</td><td>7</td><td>PS 技术</td></tr></tbody></table><p>查询父类对应的子类关系</p><table><thead><tr><th>Father</th><th>Son</th></tr></thead><tbody><tr><td>信息技术</td><td>办公信息</td></tr><tr><td>软件开发</td><td>数据库</td></tr><tr><td>软件开发</td><td>Web 开发</td></tr><tr><td>美术设计</td><td>PS 技术</td></tr></tbody></table><h4 id="4-分页和排序"><a href="#4-分页和排序" class="headerlink" title="4. 分页和排序"></a>4. 分页和排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 排序：升序 ASC，降序 DESC<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectName&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;score&#96; r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;<br>WHERE sub.&#96;SubjectName&#96; LIKE &#39;高等数学-_&#39;<br>ORDER BY &#96;score&#96; DESC;<br><br>-- 分页，每页只显示 5 条数据<br><br>&#x2F;**<br> 第1页：limit 0, 5 (pageSize &#x3D; 5)<br> 第2页：limit 5, 5<br> 第n页：limit (n-1) *5, 5<br><br> 当前页：n<br> 页面大小: pageSize<br> 总页数: n * pageSize<br> *&#x2F;<br><br>-- 查询高等数学排名前 3 且分数 &gt;&#x3D; 90 的同学信息（学号，学生姓名，课程名称，分数）<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;SubjectName&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;score&#96; r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;<br>WHERE sub.&#96;SubjectName&#96; LIKE &#39;高等数学-_&#39; AND &#96;score&#96; &gt;&#x3D; 90<br>ORDER BY &#96;score&#96; DESC<br>LIMIT 0, 3;              -- 从第 0 个数据开始后的 3 条数据<br></code></pre></td></tr></table></figure><h4 id="5-子查询"><a href="#5-子查询" class="headerlink" title="5. 子查询"></a>5. 子查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询参加 [高等数学-1] 考试的同学信息（学号，科目编号，分数）<br>-- 法一：连接查询<br>SELECT &#96;StudentNum&#96;, r.&#96;StudentNum&#96;, &#96;Score&#96;<br>FROM &#96;score&#96; r<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;<br>WHERE sub.&#96;SubjectName&#96; &#x3D; &#39;高等数学-1&#39;<br>ORDER BY &#96;score&#96; DESC;<br><br>-- 法二：子查询<br>SELECT &#96;StudentNum&#96;, &#96;StudentNum&#96;, &#96;Score&#96;<br>FROM &#96;score&#96;<br>WHERE &#96;SubjectNum&#96; &#x3D; (<br>    SELECT &#96;SubjectNum&#96;<br>    FROM &#96;subject&#96;<br>    WHERE &#96;SubjectName&#96; &#x3D; &#39;高等数学-1&#39;<br>)<br>ORDER BY &#96;score&#96; DESC;<br><br><br>-- 2. 查询 [高等数学-1] 分数不小于 80 分的学生信息（学号，学生姓名）<br>-- 子查询 1<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;score&#96; r<br>ON r.&#96;StudentNum&#96; &#x3D; s.&#96;StudentNum&#96;<br>WHERE &#96;score&#96; &gt;&#x3D; 80 AND &#96;SubjectNum&#96; &#x3D; (<br>    SELECT &#96;SubjectNum&#96;<br>    FROM &#96;subject&#96;<br>    WHERE &#96;SubjectName&#96; &#x3D; &#39;高等数学-1&#39;<br>);<br><br>-- 子查询 2<br>SELECT &#96;StudentNum&#96;, &#96;StudentName&#96;<br>FROM &#96;student&#96;<br>WHERE &#96;StudentNum&#96;<br>IN (<br>    SELECT &#96;StudentNum&#96; FROM &#96;score&#96; WHERE &#96;Score&#96; &gt;&#x3D; 80 AND &#96;SubjectNum&#96; &#x3D; (<br>       SELECT &#96;SubjectNum&#96; FROM &#96;subject&#96; WHERE &#96;SubjectName&#96; &#x3D; &#39;高等数学-1&#39;<br>    )<br>);<br><br>-- 3. 查询 [C语言-1] 前 3 名学生的信息（学号，学生姓名，分数）<br>SELECT s.&#96;StudentNum&#96;, &#96;StudentName&#96;, &#96;Score&#96;<br>FROM &#96;student&#96; s<br>INNER JOIN &#96;score&#96; r<br>ON s.&#96;StudentNum&#96; &#x3D; r.&#96;StudentNum&#96;<br>WHERE &#96;SubjectNum&#96; &#x3D; (<br>    SELECT &#96;SubjectNum&#96; FROM &#96;subject&#96; WHERE &#96;SubjectName&#96; &#x3D; &#39;C语言-1&#39;<br>)<br>ORDER BY &#96;score&#96; DESC<br>LIMIT 0, 3;<br></code></pre></td></tr></table></figure><h3 id="2-3-4-MySQL-函数"><a href="#2-3-4-MySQL-函数" class="headerlink" title="2.3.4 MySQL 函数"></a>2.3.4 MySQL 函数</h3><p>（1）count 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">count(*)    -- 包括所有列，返回表中的记录数，相当于统计表的行数，不忽略值为 NULL 的记录<br><br>count(1)    -- 忽略所有列，1 表示一个固定值，也可以用 count(2)、count(3) 代替，不忽略值为 NULL 的记录<br><br>count(列名)  -- 只包括列名指定列，返回指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内<br><br>（4）count(distinct 列名) -- 只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内<br><br>3.count(*)&amp;count(1)&amp;count(列名)执行效率比较：<br><br>（1）如果列为主键，count(列名)效率优于count(1)<br><br>（2）如果列不为主键，count(1)效率优于count(列名)<br><br>（3）如果表中存在主键，count(主键列名)效率最优<br><br>（4）如果表中只有一列，则count(*)效率最优<br><br>（5）如果表有多列，且不存在主键，则count(1)效率优于count(*)<br> <br><br>4.因为count(*)和count(1)统计过程中不会忽略列值为NULL的记录，所以可以通过以下两种方式来统计列值为NULL的记录数:<br><br>（1）select count(*) from table where is_active is null;<br>（2）select count(1) from table where is_active is null;<br><br><br>5.特例：<br><br>（1）select count(&#39;&#39;) from table;-返回表的记录数<br>（2）select count(0) from table;-返回表的记录数<br>（3）select count(null) from table;-返回0<br></code></pre></td></tr></table></figure><p>聚合函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(&#96;Score&#96;) AS 总和 FROM &#96;score&#96;;<br>SELECT AVG(&#96;Score&#96;) AS 平均分 FROM &#96;score&#96;;<br>SELECT MAX(&#96;Score&#96;) AS 最高分 FROM &#96;score&#96;;<br>SELECT MIN(&#96;Score&#96;) AS 最低分 FROM &#96;score&#96;;<br><br>-- 查询不同课程的（平均分，最高分，最低分）平均分 &gt; 80<br>-- 考点：根据不同的课程分组<br>SELECT &#96;SubjectName&#96;, AVG(&#96;Score&#96;) AS 平均分, MAX(&#96;Score&#96;) AS 最高分, MIN(&#96;Score&#96;) AS 最低分<br>FROM &#96;score&#96; r<br>INNER JOIN &#96;subject&#96; sub<br>ON r.&#96;SubjectNum&#96; &#x3D; sub.&#96;SubjectNum&#96;<br>GROUP BY r.&#96;SubjectNum&#96;                 -- 分组<br>HAVING 平均分 &gt; 80                       -- 分组条件<br></code></pre></td></tr></table></figure><h2 id="2-4-事务"><a href="#2-4-事务" class="headerlink" title="2.4 事务"></a>2.4 事务</h2><h3 id="ACID-原则"><a href="#ACID-原则" class="headerlink" title="ACID 原则"></a>ACID 原则</h3><p>原子性 Atomicity（不可分割性）：要么都成功，要么都失败</p><p>一致性 Consistency：总数不变</p><p>隔离性 Isolation（独立性）：多个进程互补干扰</p><p>持久性（Durability）：提交后不可逆，持久化到数据库</p><h3 id="隔离性的问题"><a href="#隔离性的问题" class="headerlink" title="隔离性的问题"></a>隔离性的问题</h3><p>脏读：一个事务读取了另一个没有提交的事务</p><p>不可重复读：在同一个事务中，重复读取表中的数据，数据发生了改变</p><p>虚读（幻读）：在同一个事物中，读取了别人插入的数据，导致前后读取的结果不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- MySQL 默认开启事务自动提交<br>SET autocommit &#x3D; 0  -- 关闭事务<br>SET autocommit &#x3D; 1  -- 开启事务（默认）<br><br><br>-- 手动处理事务<br>SET autocommit &#x3D; 0<br><br>-- 事务，后面的 sql 都在该事务中<br>START TRANSACTION      <br> <br>INSERT xx<br><br>COMMIT      -- 提交，持久化（成功）<br><br>ROLLBACK    -- 回滚（失败）<br><br>-- 事务结束<br>SET autocommit &#x3D; 1  -- 开启自动提交<br><br><br>-- 了解<br>SAVEPOINT 保存点名                  -- 设置一个事务的保存点<br>ROLLBACK TO SAVEPOINT 保存点名      -- 回滚到保存点<br>RELEASE SAVEPOINT 保存点名          -- 撤销保存点<br></code></pre></td></tr></table></figure><p>模拟转账：事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS &#96;school&#96;;<br>USE &#96;school&#96;;<br>CREATE TABLE &#96;account&#96; (<br>    &#96;id&#96; INT(3) NOT NULL AUTO_INCREMENT,<br>    &#96;name&#96; VARCHAR(30) NOT NULL,<br>    &#96;money&#96; DECIMAL(9, 2) NOT NULL,<br>    PRIMARY KEY (&#96;id&#96;)<br>) ENGINE &#x3D; INNODB DEFAULT CHARSET &#x3D; utf8;<br><br>INSERT INTO &#96;account&#96;(&#96;name&#96;, &#96;money&#96;) VALUES<br>    (&#39;A&#39;, 2000.00),<br>    (&#39;B&#39;, 10000.00);<br><br><br>-- 模拟转账：事务<br>SET autocommit &#x3D; 0;     -- 关闭自动提交<br>START TRANSACTION<br><br>UPDATE &#96;account&#96; SET &#96;money&#96; &#x3D; &#96;money&#96; - 500 WHERE &#96;name&#96; &#x3D; &#39;A&#39;;<br>UPDATE &#96;account&#96; SET &#96;money&#96; &#x3D; &#96;money&#96; + 500 WHERE &#96;name&#96; &#x3D; &#39;B&#39;;<br><br>&#x2F;** 提交事务后，事务被持久化<br> * 1. 回滚只能回到提交后的状态 A:1500, B:10500<br> * 2. 若不提交，直接回滚到 A:2000, B:10000<br> *&#x2F;<br>COMMIT;     -- 手动提交事务<br><br>ROLLBACK;   -- 回滚<br><br>SET autocommit &#x3D; 1;     -- 开启自动提交<br></code></pre></td></tr></table></figure><h2 id="2-5-索引"><a href="#2-5-索引" class="headerlink" title="2.5 索引"></a>2.5 索引</h2><h3 id="2-5-1-索引的分类"><a href="#2-5-1-索引的分类" class="headerlink" title="2.5.1 索引的分类"></a>2.5.1 索引的分类</h3><p>在一个表中，主键索引只能有一个，唯一索引可以有多个</p><table><thead><tr><th>索引</th><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>主键索引</td><td>Primary Key</td><td>唯一的标识，主键索引只能有一个</td></tr><tr><td>唯一索引</td><td>Unique Key</td><td>避免重复的列出现，唯一索引可以有多个</td></tr><tr><td>常规索引</td><td>Key/Index</td><td>默认索引</td></tr><tr><td>全文索引</td><td>FullText</td><td>特定的数据库引擎才有</td></tr></tbody></table><h2 id="2-6-权限管理和备份"><a href="#2-6-权限管理和备份" class="headerlink" title="2.6 权限管理和备份"></a>2.6 权限管理和备份</h2><h3 id="2-6-1-权限管理"><a href="#2-6-1-权限管理" class="headerlink" title="2.6.1 权限管理"></a>2.6.1 权限管理</h3><p>对用户权限的修改本质是对表 mysql.user 进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建用户<br>CREATE USER Docker IDENTIFIED BY &#39;111&#39;;<br><br>-- 删除用户<br>DROP USER Docker;<br><br>-- 修改密码（当前用户）<br>SET PASSWORD &#x3D; PASSWORD(&#39; &#39;);<br><br>-- 修改密码（指定用户）<br>SET PASSWORD FOR Docker &#x3D; PASSWORD(&#39;999&#39;);<br><br>-- 重命名<br>RENAME USER Docker TO Apache;<br><br>-- 用户授权<br>-- ALL PRIVILEGES：给所有库的所有表授权（除了给别人授权的 grant 权限）<br>GRANT ALL PRIVILEGES ON *.* TO Apache;<br><br>-- 查看权限<br>SHOW GRANTS FOR Apache;<br>SHOW GRANTS FOR root@localhost;<br><br>-- 撤销权限<br>REVOKE ALL PRIVILEGES ON *.* FROM Apache;<br></code></pre></td></tr></table></figure><h3 id="2-6-2-备份"><a href="#2-6-2-备份" class="headerlink" title="2.6.2 备份"></a>2.6.2 备份</h3><p>作用：避免数据丢失；数据转移</p><p>备份方式</p><ul><li>直接备份物理文件；data 文件</li><li>在 SQLyog 中右键「数据库/表」，选择「备份/导出」</li><li>使用命令行 mysqldump</li></ul><h2 id="2-7-数据库设计三大范式"><a href="#2-7-数据库设计三大范式" class="headerlink" title="2.7 数据库设计三大范式"></a>2.7 数据库设计三大范式</h2><p><a href="https://zhuanlan.zhihu.com/p/72197799">知乎文章</a></p><p>目前关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。一般来说，数据库只需要满足第三范式就行了</p><h3 id="第一范式：保证每列的原子性"><a href="#第一范式：保证每列的原子性" class="headerlink" title="第一范式：保证每列的原子性"></a>第一范式：保证每列的原子性</h3><p>例如「地址」一列的字段：广东省东莞市 xxx 路 xxx 号。不能将该地址作为一个整体的字段，因为若频繁查询地址属于哪个省，那个市，则还需将查询到的地址再切片，<strong>不能做到所查即所得</strong></p><p>正确的做法是将地址再切分为多个字段：省（广东省）、市（东莞市）、详细地址（xxx 路 xxx 号），保证每一列都不可再分（原子性）</p><h3 id="第二范式：保证一张表只描述一件事情"><a href="#第二范式：保证一张表只描述一件事情" class="headerlink" title="第二范式：保证一张表只描述一件事情"></a>第二范式：保证一张表只描述一件事情</h3><h3 id="第三范式：保证每列都和主键直接相关"><a href="#第三范式：保证每列都和主键直接相关" class="headerlink" title="第三范式：保证每列都和主键直接相关"></a>第三范式：保证每列都和主键直接相关</h3><h3 id="规范与性能之间的平衡"><a href="#规范与性能之间的平衡" class="headerlink" title="规范与性能之间的平衡"></a>规范与性能之间的平衡</h3><p>关联查询的表不得超过三个（阿里）</p><ul><li>考虑商业化的需求和目标（成本、用户体验），数据库的性能更加重要</li><li>故意增加一些冗余字段（多表查询 -&gt; 单表查询）</li><li>故意增加一些计算列（索引）</li></ul><h2 id="2-8-JDBC（重点）"><a href="#2-8-JDBC（重点）" class="headerlink" title="2.8 JDBC（重点）"></a>2.8 JDBC（重点）</h2><p>Java 数据库连接 JDBC（Java Database Connectivity）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;<br>        <span class="hljs-comment">// 1. 加载驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 连接数据库 student</span><br>        String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;</span>;<br>        String userName = <span class="hljs-string">&quot;root&quot;</span>;<br>        String password = <span class="hljs-string">&quot;0000&quot;</span>;<br>        <br>        <span class="hljs-comment">// connection 代表数据库，可以进行事务操作（事务提交、事务回滚）</span><br>        Connection connection = DriverManager.getConnection(url, userName, password);<br><br>        <span class="hljs-comment">/* 3. 执行 SQL 对象 statement，获得结果集 resultSet</span><br><span class="hljs-comment">           statement.execute();        // 执行任何 sql</span><br><span class="hljs-comment">           statement.executeUpdate();  // 更新、插入、删除。返回受影响的行数</span><br><span class="hljs-comment">           statement.executeBatch();   // 执行多个 sql</span><br><span class="hljs-comment">         */</span><br>        Statement statement = connection.createStatement();<br>        ResultSet resultSet = statement.executeQuery(<span class="hljs-string">&quot;select * from score&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;StudentNum\tSubjectNum\tExamData\t\t\t\tScore&quot;</span>);<br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            System.out.print(resultSet.getObject(<span class="hljs-string">&quot;StudentNum&quot;</span>) + <span class="hljs-string">&quot;\t\t&quot;</span>);<br>            System.out.print(resultSet.getObject(<span class="hljs-string">&quot;SubjectNum&quot;</span>) + <span class="hljs-string">&quot;\t\t\t&quot;</span>);<br>            System.out.print(resultSet.getObject(<span class="hljs-string">&quot;ExamData&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);<br>            System.out.println(resultSet.getObject(<span class="hljs-string">&quot;Score&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 释放连接（必须）</span><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="增删改查-CRUD"><a href="#增删改查-CRUD" class="headerlink" title="增删改查 CRUD"></a>增删改查 CRUD</h3><p>配置文件 db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span><br><span class="hljs-attr">userName</span> = <span class="hljs-string">root</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">0000</span><br></code></pre></td></tr></table></figure><p>核心类 <code>JdbcUtils</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String userName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 反射，加载配置文件 db.properties </span><br>            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>            Properties properties = <span class="hljs-keyword">new</span> Properties();<br>            properties.load(inputStream);<br><br>            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            userName = properties.getProperty(<span class="hljs-string">&quot;userName&quot;</span>);<br>            password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><br>            <span class="hljs-comment">// 加载驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, userName, password);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Connection conn, Statement st, ResultSet res)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) &#123;<br>            res.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st != <span class="hljs-keyword">null</span>) &#123;<br>            st.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;<br>            conn.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CRUD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** CRUD</span><br><span class="hljs-comment"> * 增加 Create、检索 Retrieve、更新 Update、删除 Delete</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Crud</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Connection connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">static</span> Statement statement = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">static</span> ResultSet resultSet = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();<br>            statement = connection.createStatement();<br><br>            <span class="hljs-keyword">int</span> i = statement.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;已插入 &quot;</span> + i + <span class="hljs-string">&quot; 行数据&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();<br>            statement = connection.createStatement();<br><br>            <span class="hljs-keyword">int</span> i = statement.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;已删除 &quot;</span> + i + <span class="hljs-string">&quot; 行数据&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();<br>            statement = connection.createStatement();<br><br>            <span class="hljs-keyword">int</span> i = statement.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;已更新 &quot;</span> + i + <span class="hljs-string">&quot; 行数据&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();<br>            statement = connection.createStatement();<br>            resultSet = statement.executeQuery(sql);<br><br>            System.out.println(<span class="hljs-string">&quot;StudentNum\tStudentName\tSubjectName\t\tScore&quot;</span>);<br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                System.out.print(resultSet.getObject(<span class="hljs-string">&quot;StudentNum&quot;</span>) + <span class="hljs-string">&quot;\t\t&quot;</span>);<br>                System.out.print(resultSet.getObject(<span class="hljs-string">&quot;StudentName&quot;</span>) + <span class="hljs-string">&quot;\t\t\t&quot;</span>);<br>                System.out.print(resultSet.getObject(<span class="hljs-string">&quot;SubjectName&quot;</span>) + <span class="hljs-string">&quot;\t\t&quot;</span>);<br>                System.out.println(resultSet.getObject(<span class="hljs-string">&quot;Score&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">// 插入多行数据时，「,」号不能省</span><br>        String sqlInsert = <span class="hljs-string">&quot;insert into `score`(`StudentNum`, `SubjectNum`, `ExamData`, `Score`) values&quot;</span> +<br>                <span class="hljs-string">&quot;(1010, 2, &#x27;2013-11-09 16:00:00&#x27;, 100),&quot;</span> +<br>                <span class="hljs-string">&quot;(1011, 6, &#x27;2013-10-09 16:00:00&#x27;, 98),&quot;</span> +<br>                <span class="hljs-string">&quot;(1012, 8, &#x27;2013-12-09 16:00:00&#x27;, 95);&quot;</span>;<br><span class="hljs-comment">//        insert(sqlInsert);</span><br><br>        <span class="hljs-comment">// 删除</span><br>        String sqlDelete = <span class="hljs-string">&quot;delete from `score` where `StudentNum` = 1010&quot;</span>;<br><span class="hljs-comment">//        delete(sqlDelete);</span><br><br>        <span class="hljs-comment">// 更新</span><br>        String sqlUpdate = <span class="hljs-string">&quot;update `score` set `StudentNum` = 1018, `Score` = 10 &quot;</span> +<br>                <span class="hljs-string">&quot;where `StudentNum` = 1011 or `StudentNum` = 1012&quot;</span>;<br><span class="hljs-comment">//        update(sqlUpdate);</span><br><br>        <span class="hljs-comment">// 查询，直接把 sql 语句复制过来，不要删 \n</span><br>        String sqlSelect = <span class="hljs-string">&quot;SELECT s.`StudentNum`, `StudentName`, `SubjectName`, `Score`\n&quot;</span> +<br>                <span class="hljs-string">&quot;FROM `student` s\n&quot;</span> +<br>                <span class="hljs-string">&quot;INNER JOIN `score` r\n&quot;</span> +<br>                <span class="hljs-string">&quot;ON r.`StudentNum` = s.`StudentNum`\n&quot;</span> +<br>                <span class="hljs-string">&quot;INNER JOIN `subject` sub\n&quot;</span> +<br>                <span class="hljs-string">&quot;ON r.`SubjectNum` = sub.`SubjectNum`;&quot;</span>;<br>        select(sqlSelect);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-9-SQL-注入漏洞"><a href="#2-9-SQL-注入漏洞" class="headerlink" title="2.9 SQL 注入漏洞"></a>2.9 SQL 注入漏洞</h2><p>sql 使用非法拼接，导致数据泄露</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5 位运算</title>
    <link href="/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>$x &amp; (−x)$：得到 $x$ 的二进制的最低位的 $1$ 的位置</p><p>$x&amp;(x-1)$：将 $x$ 的二进制的最低位的 $1$ 置成 $0$</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章 自动内存管理</title>
    <link href="/2021/07/13/JVM/%E7%AC%AC1%E7%AB%A0%20%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/07/13/JVM/%E7%AC%AC1%E7%AB%A0%20%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-Java-内存区域"><a href="#1-1-Java-内存区域" class="headerlink" title="1.1 Java 内存区域"></a>1.1 Java 内存区域</h2><h3 id="1-1-1-运行时数据区域"><a href="#1-1-1-运行时数据区域" class="headerlink" title="1.1.1 运行时数据区域"></a>1.1.1 运行时数据区域</h3><p><img src="https://e.im5i.com/2021/07/14/weAbd.jpg" alt="运行时数据区域"></p><h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h4><p>字节码解释器通过改变程序计数器 PC 的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</p><p>每条线程都需要有一个独立的程序计数器（它的生命周期与线程相同），各线程之间计数器互不影响，独立存储</p><ul><li>如果线程正在执行的是 Java 方法，这个计数器的值是正在执行的虚拟机字节码指令的地址</li><li>如果线程正在执行的是本地（Native）方法，这个计数器的值则应为空（Undefined）</li><li>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 OutOfMemoryErro 情况的区域</li></ul><h4 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h4><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型。与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同</p><h5 id="（1）栈帧"><a href="#（1）栈帧" class="headerlink" title="（1）栈帧"></a>（1）栈帧</h5><p>每个 Java 方法被执行的时候，Java 虚拟机都会同步创建一个<strong>「栈帧」</strong>（Stack Frame）用于存储「局部变量表、操作数栈、动态连接、方法出口」等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p><h5 id="（2）局部变量表"><a href="#（2）局部变量表" class="headerlink" title="（2）局部变量表"></a>（2）局部变量表</h5><p>栈通常就是指这里的虚拟机栈，或者更多的情况下只是指「虚拟机栈中的局部变量表」，它存放了编译期可知的数据类型：</p><ul><li>基本数据类型：boolean、byte、char、short、int、float、long、double）</li><li>对象引用：reference 类型，它并不等同于对象本身。可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置</li><li>returnAddress 类型：指向了一条字节码指令的地址</li></ul><h5 id="（3）局部变量槽"><a href="#（3）局部变量槽" class="headerlink" title="（3）局部变量槽"></a>（3）局部变量槽</h5><p>这些数据类型在局部变量表中的存储空间用<strong>「局部变量槽」</strong>（Slot）来表示，其中 64 位的 long 和 double 类型的数据占两个变量槽，其余的数据类型只占用一个</p><ul><li>局部变量表所需的内存空间在编译期间完成分配</li><li>当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</li></ul><h5 id="（5）两类异常：SOE-和-OOM"><a href="#（5）两类异常：SOE-和-OOM" class="headerlink" title="（5）两类异常：SOE 和 OOM"></a>（5）两类异常：SOE 和 OOM</h5><p>在《Java虚拟机规范》中，对 Java 虚拟机栈规定了两类异常</p><ul><li>栈深度溢出：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出 <code>StackOverflowError</code> 异常</li><li>栈扩展失败：如果 Java 虚拟机栈容量支持动态扩展（HotSpot 不支持），当扩展栈时无法申请到足够的内存时，抛出 <code>OutOfMemoryError</code> 异常。除了程序计数器外，虚拟机内存的其他几个运行时区域都可能发生 <code>OOM</code>异常</li></ul><h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h4><p>虚拟机栈为虚拟机提供 Java 方法（字节码）服务，而本地方法栈为虚拟机提供本地（Native）方法服务</p><p>HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出时抛出 <code>SOE</code> 异常，在栈扩展失败时抛出 <code>OOM</code> 异常</p><h4 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h4><p>Java 堆是虚拟机所管理的内存中最大的一块，是垃圾收集器管理的内存区域，因此也被称作<strong>「GC 堆」</strong></p><ul><li><p>Java 堆可以是物理上不连续的内存空间，但逻辑上必须是连续的</p></li><li><p>Java 堆可以被实现成固定大小的，也可以是可扩展的</p></li><li><p>Java 堆被所有线程共享，在虚拟机启动时创建</p></li><li><p>Java 堆只能存放<strong>「对象实例」</strong>，“几乎” 所有的对象实例都在这里分配内存。“几乎”：由于「即时编译技术」的进步，尤其是「逃逸分析技术」的日渐强大，栈上分配、标量替换优化手段使得对象实例分配在堆上并不是绝对的</p></li></ul><p>从分配内存的角度看，所有线程共享的 Java 堆可以划分出多个线程私有的<strong>「本地线程分配缓冲区」</strong>（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。将 Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存</p><h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h4><p>虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它有一个别名叫作「非堆」，目的是与 Java 堆区分开来</p><ul><li><p>方法区与 Java 堆一样，被所有线程共享</p></li><li><p>方法区用于存放「已被虚拟机加载」的「类型信息、常量、静态变量、即时编译器编译后的代码缓存」等数据</p></li><li><p>方法区的「内存回收」目标主要是针对「常量池的回收和对类型的卸载」</p></li></ul><h5 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h5><p>JDK 8 以前，方法区被为 「永久代」</p><p>但本质上这两者并不是等价的，因为仅仅是当时的 HotSpot 虚拟机把收集器的「分代设计」扩展至「方法区」，或者说「使用永久代来实现方法区」，使得 HotSpot 的「垃圾收集器」能够像管理 Java 堆一样管理这部分内存，不必专门为方法区编写内存管理代码。然而，使用永久代来实现方法区导致 Java 应用更容易发生内存溢出</p><p>JDK 7 的 HotSpot，已经把原本放在永久代中的字符串常量池、静态变量等移出。到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的「元空间」（Metaspace）来代替，把 JDK 7 中永久代剩余的内容（主要是类型信息）全部移到元空间中</p><h4 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h4><p>运行时常量池是方法区的一部分。Class 文件中除了有「类的版本、字段、方法、接口」等描述信息外，还有<strong>「常量池表」</strong>（Constant Pool Table），用于存放「编译期生成的字面量和符号引用，以及用符号引用翻译出来的直接引用」，这部分内容将在类加载后存放到方法区的运行时常量池中</p><h4 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h4><p>直接内存（Direct Memory）不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存被频繁使用，而且也可能发生 <code>OOM</code> 异常</p><h3 id="1-1-2-HotSpot-虚拟机对象"><a href="#1-1-2-HotSpot-虚拟机对象" class="headerlink" title="1.1.2 HotSpot 虚拟机对象"></a>1.1.2 HotSpot 虚拟机对象</h3><h4 id="1-对象创建"><a href="#1-对象创建" class="headerlink" title="1. 对象创建"></a>1. 对象创建</h4><p>当 Java 虚拟机遇到一条字节码 new 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的「符号引用」，并检查这个符号引用代表的「类是否已被加载、解析和初始化过」。如果没有，那么必须先执行相应的类加载过程</p><p>类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上等同于把一块确定大小的内存块从 Java 堆中划分出来</p><h5 id="（1）堆内存分配方式"><a href="#（1）堆内存分配方式" class="headerlink" title="（1）堆内存分配方式"></a>（1）堆内存分配方式</h5><p>选择哪种分配方式由 Java 堆「是否规整」决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有「空间压缩整理」（Compact）的能力决定。两种分配方式</p><ul><li><strong>指针碰撞</strong>（Bump The Pointer）：如果 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那么所分配内存就是把该指针向空闲空间方向挪动一段与对象大小相等的距离</li><li><strong>空闲列表</strong>（Free List）：如果 Java 堆中内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，虚拟机维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li></ul><h5 id="（2）本地线程分配缓冲区"><a href="#（2）本地线程分配缓冲区" class="headerlink" title="（2）本地线程分配缓冲区"></a>（2）本地线程分配缓冲区</h5><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。可能出现正在给对象<br>A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存。解决这个问题有两种可选方案：</p><ul><li>一种是对分配内存空间的动作进行同步处理。实际上虚拟机是采用 CAS 配上失败重试的方式保证更新操作的原子性</li><li>本地线程分配缓冲区（Thread Local Allocation Buffer，TLAB）：另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存。哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完<br>了，分配新的缓存区时才需要同步锁定。虚拟机是否使用 TLAB，可以通过 <code>-XX：+/-UseTLAB</code> 参数来设定</li></ul><h4 id="2-对象的堆内存布局"><a href="#2-对象的堆内存布局" class="headerlink" title="2. 对象的堆内存布局"></a>2. 对象的堆内存布局</h4><p>HotSpot 中的对象在堆内存中的布局被划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p><h5 id="（1）对象头"><a href="#（1）对象头" class="headerlink" title="（1）对象头"></a>（1）对象头</h5><p>对象头包括两类信息</p><ul><li>第一类是用于存储对象自身的<strong>「运行时数据」</strong>，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为<strong>「Mark Word」</strong></li><li>第二类是<strong>「类型指针」</strong>，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例</li><li>如果对象是一个 Java 数组，那对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的「元数据」确定 Java 对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小</li></ul><h5 id="（2）实例数据"><a href="#（2）实例数据" class="headerlink" title="（2）实例数据"></a>（2）实例数据</h5><p>实例数据是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数 <code>-XX：FieldsAllocationStyle</code> 和字段在 Java 源码中定义顺序的影响</p><h5 id="（3）对齐填充"><a href="#（3）对齐填充" class="headerlink" title="（3）对齐填充"></a>（3）对齐填充</h5><p>对齐填充不是必须的，也没有特别的含义，仅仅起着占位符的作用。因为 HotSpot 虚拟机的自动内存管理系统要求<strong>「对象起始地址必须是 8 字节的整数倍」</strong></p><h4 id="3-对象访问"><a href="#3-对象访问" class="headerlink" title="3. 对象访问"></a>3. 对象访问</h4><p>通过栈上的 reference 数据来访问堆上的对象。有「句柄访问」和「直接指针访问」两种访问方式</p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</p><h5 id="（1）句柄访问"><a href="#（1）句柄访问" class="headerlink" title="（1）句柄访问"></a>（1）句柄访问</h5><p>在 Java 堆中划分一块内存来作为「句柄池」，reference 中存放的是「对象的句柄地址」，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</p><p><img src="https://e.im5i.com/2021/07/16/NxVRY.png" alt="句柄访问"></p><h5 id="（2）直接指针访问"><a href="#（2）直接指针访问" class="headerlink" title="（2）直接指针访问"></a>（2）直接指针访问</h5><p>reference 中存放的是对象地址。HotSpot 虚拟机主要使用这种方式进行对象访问</p><p><img src="https://e.im5i.com/2021/07/16/NxFWG.jpg" alt="直接指针访问"></p><h3 id="1-1-3-实战：OOM-异常"><a href="#1-1-3-实战：OOM-异常" class="headerlink" title="1.1.3 实战：OOM 异常"></a>1.1.3 实战：OOM 异常</h3><h4 id="1-Java-堆溢出"><a href="#1-Java-堆溢出" class="headerlink" title="1.  Java 堆溢出"></a>1.  Java 堆溢出</h4><p><code>VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code></p><ul><li>限制 Java 堆的大小为 20MB</li><li>将堆的最小值 <code>-Xms</code> 参数与最大值 <code>-Xmx</code> 参数设置为一样可避免堆自动扩展</li><li>参数 <code>-XX：+HeapDumpOnOutOfMemoryError</code>：当虚拟机出现内存溢出异常时，Dump 出当前的「内存堆转储快照」</li></ul><h4 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h4><p>HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此对于 HotSpot 来说，<code>-Xoss</code> 参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的</p><p>栈容量只能由 <code>-Xss</code> 参数来设定（没有 <code>-Xsm</code> 参数），对于 64 位 Windows 系统下的 JDK 16，栈容量不能低于 180K，Linux 下这个值可能是 228K</p><p>对于虚拟机栈和本地方法栈，《Java虚拟机规范》规定了两类异常：<code>SOE</code> 和 <code>OOM </code></p><ul><li>HotSpot 不支持扩展，因此只可能在创建线程申请内存时，因无法申请到足够内存而发生 <code>OOM</code> 异常</li><li>在栈容量无法容纳新的栈帧时发生 <code>SOE</code> 异常</li></ul><h4 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3. 方法区和运行时常量池溢出"></a>3. 方法区和运行时常量池溢出</h4><ul><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值，默认是 -1，即不限制，或者说只受限于本地内存大小</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 <code>-XX：MaxMetaspaceSize</code>（如果设置了的话）的情况下，适当提高该值</li><li><code>XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有 <code>-XX：Max-MetaspaceFreeRatio</code>，用于控制最大的元空间剩余容量的百分比</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存区域</tag>
      
      <tag>内存溢出异常</tag>
      
      <tag>垃圾收集器</tag>
      
      <tag>内存分配策略</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 Java 集合</title>
    <link href="/2021/07/05/LeetCode/1%20%20Java%20%E9%9B%86%E5%90%88/"/>
    <url>/2021/07/05/LeetCode/1%20%20Java%20%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-值转换"><a href="#1-1-值转换" class="headerlink" title="1.1 值转换"></a>1.1 值转换</h2><h3 id="1-1-1-int-转-String"><a href="#1-1-1-int-转-String" class="headerlink" title="1.1.1 int 转 String"></a>1.1.1 int 转 String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>Integer i = <span class="hljs-number">100</span>;<br>String s = String.valueOf(i);<br></code></pre></td></tr></table></figure><h3 id="1-1-2-String-转-int"><a href="#1-1-2-String-转-int" class="headerlink" title="1.1.2 String 转 int"></a>1.1.2 String 转 int</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> v = Integer.parseInt(s);<br>Integer v = Integer.parseInt(s);<br></code></pre></td></tr></table></figure><h2 id="2-1-数组转换"><a href="#2-1-数组转换" class="headerlink" title="2.1 数组转换"></a>2.1 数组转换</h2><h3 id="2-1-1-int-转-Integer"><a href="#2-1-1-int-转-Integer" class="headerlink" title="2.1.1  int[] 转 Integer[]"></a>2.1.1  int[] 转 Integer[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>Integer[] numsInt = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><h3 id="2-1-2-int-转-List-lt-Integer-gt"><a href="#2-1-2-int-转-List-lt-Integer-gt" class="headerlink" title="2.1.2 int[] 转 List&lt;Integer&gt;"></a>2.1.2 int[] 转 List&lt;Integer&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="2-1-3-Integer-转-int"><a href="#2-1-3-Integer-转-int" class="headerlink" title="2.1.3 Integer[] 转 int[]"></a>2.1.3 Integer[] 转 int[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = Arrays.stream(numsInt).mapToInt(i -&gt; i).toArray();<br><span class="hljs-keyword">int</span>[] nums = Arrays.stream(numsInt).mapToInt(Integer::valueOf).toArray();<br></code></pre></td></tr></table></figure><h3 id="2-1-4-Integer-转-List-lt-Integer-gt"><a href="#2-1-4-Integer-转-List-lt-Integer-gt" class="headerlink" title="2.1.4 Integer[] 转 List&lt;Integer&gt;"></a>2.1.4 Integer[] 转 List&lt;Integer&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(numsInt);<br>List&lt;Integer&gt; list = Arrays.stream(numsInt).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="2-1-5-List-lt-Integer-gt-转-int"><a href="#2-1-5-List-lt-Integer-gt-转-int" class="headerlink" title="2.1.5 List&lt;Integer&gt; 转 int[]"></a>2.1.5 List&lt;Integer&gt; 转 int[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = list.stream().mapToInt(Integer::valueOf).toArray();<br></code></pre></td></tr></table></figure><h3 id="2-1-6-List-lt-Integer-gt-转-Integer"><a href="#2-1-6-List-lt-Integer-gt-转-Integer" class="headerlink" title="2.1.6 List&lt;Integer&gt; 转 Integer[]"></a>2.1.6 List&lt;Integer&gt; 转 Integer[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] numsInt = list.toArray(Integer[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><h3 id="2-1-7-String-转-List-lt-String-gt"><a href="#2-1-7-String-转-List-lt-String-gt" class="headerlink" title="2.1.7 String[] 转 List&lt;String&gt;"></a>2.1.7 String[] 转 List&lt;String&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strArray = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (String s : str) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>        System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strList = Arrays.asList(strArray);<br></code></pre></td></tr></table></figure><h3 id="2-1-8-List-lt-String-gt-转-String"><a href="#2-1-8-List-lt-String-gt-转-String" class="headerlink" title="2.1.8 List&lt;String&gt; 转 String[]"></a>2.1.8 List&lt;String&gt; 转 String[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strArray = strList.toArray(String[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><h3 id="2-1-9-int-转-List-lt-int-gt-、Set-lt-int-gt"><a href="#2-1-9-int-转-List-lt-int-gt-、Set-lt-int-gt" class="headerlink" title="2.1.9 int[][] 转 List&lt;int[]&gt;、Set&lt;int[]&gt;"></a>2.1.9 int[][] 转 List&lt;int[]&gt;、Set&lt;int[]&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;&#125;;<br>List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Set&lt;<span class="hljs-keyword">int</span>[]&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>Collections.addAll(list, matrix);<br>Collections.addAll(set, matrix);<br></code></pre></td></tr></table></figure><h2 id="3-2-Set"><a href="#3-2-Set" class="headerlink" title="3.2 Set"></a>3.2 Set</h2><h3 id="3-2-1-int-去除重复元素"><a href="#3-2-1-int-去除重复元素" class="headerlink" title="3.2.1 int[] 去除重复元素"></a>3.2.1 int[] 去除重复元素</h3><h4 id="1-IntStream：distinct"><a href="#1-IntStream：distinct" class="headerlink" title="1. IntStream：distinct"></a>1. IntStream：distinct</h4><p><code>[1, 2, 2, 4]</code> 去除重复元素：<code>[1, 2, 4]</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span>[] distNums = Arrays.stream(nums).distinct().toArray();<br></code></pre></td></tr></table></figure><h4 id="2-int-gt-Set-lt-Integer-gt-gt-Int"><a href="#2-int-gt-Set-lt-Integer-gt-gt-Int" class="headerlink" title="2. int[] -&gt; Set&lt;Integer&gt; -&gt; Int[]"></a>2. int[] -&gt; Set&lt;Integer&gt; -&gt; Int[]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set = Arrays.stream().boxed().collect(Collectors.toSet());<br><span class="hljs-keyword">int</span>[] nums = set.stream().mapToInt(i -&gt; i).toArray();<br></code></pre></td></tr></table></figure><h2 id="3-3-Map"><a href="#3-3-Map" class="headerlink" title="3.3 Map"></a>3.3 Map</h2><h3 id="3-3-1-map-keySet-转-List，按-Value-降序"><a href="#3-3-1-map-keySet-转-List，按-Value-降序" class="headerlink" title="3.3.1 map.keySet() 转 List，按 Value 降序"></a>3.3.1 map.keySet() 转 List，按 Value 降序</h3><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LeetCode | 451. 根据字符出现频率排序</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.keySet());<br>        list.sort((k1, k2) -&gt; map.get(k2) - map.get(k1));<span class="hljs-comment">// 按 Value 降序排序</span><br>        list.sort((k1, k2) -&gt; map.get(k2).compareTo(map.get(k1)));<span class="hljs-comment">// 等价</span><br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : list) &#123;<br>            sb.append(String.valueOf(c).repeat(map.get(c)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String str = <span class="hljs-string">&quot;Aabb&quot;</span>;<br>        System.out.println(frequencySort(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bbAa<br></code></pre></td></tr></table></figure><h3 id="3-3-2-Stack-lt-Map-gt"><a href="#3-3-2-Stack-lt-Map-gt" class="headerlink" title="3.3.2 Stack&lt;Map&gt;"></a>3.3.2 Stack&lt;Map&gt;</h3><h4 id="1-TreeSet-按-Key-排序，Stream-按-Key、Value-排序"><a href="#1-TreeSet-按-Key-排序，Stream-按-Key、Value-排序" class="headerlink" title="1. TreeSet 按 Key 排序，Stream 按 Key、Value 排序"></a>1. TreeSet 按 Key 排序，Stream 按 Key、Value 排序</h4><p><a href="https://leetcode-cn.com/problems/number-of-atoms/">LeetCode | 726. 原子的数量</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, n;<br>    String formula;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">parseAtom</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(formula.charAt(i++));<br><br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Character.isLowerCase(formula.charAt(i))) &#123;<br>            sb.append(formula.charAt(i++));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n || !Character.isDigit(formula.charAt(i))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(formula.charAt(i))) &#123;<br>            num = num * <span class="hljs-number">10</span> + formula.charAt(i++) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countOfAtoms</span><span class="hljs-params">(String formula)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.n = formula.length();<br>        <span class="hljs-keyword">this</span>.formula = formual;<br><br>        Stack&lt;Map&lt;String, Integer&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack();<br>        stack.push(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">char</span> c = formula.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                i++;<br>                stack.push(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                i++;<br>                <span class="hljs-keyword">int</span> num = parseNum();<br>                Map&lt;String, Integer&gt; popMap = stack.pop();<br>                Map&lt;String, Integer&gt; topMap = stack.peek();<br>                <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : popMap.entrySet()) &#123;<br>                    String atom = entry.getKey();<br>                    <span class="hljs-keyword">int</span> v = entry.getValue();<br>                    topMap.put(atom, topMap.getOrDefault(atom, <span class="hljs-number">0</span>) + v * num);<br>                &#125;<br>                System.out.println(stack);<span class="hljs-comment">// 调试</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                String atom = parseAtom();<br>                <span class="hljs-keyword">int</span> num = parseNum();<br>                Map&lt;String, Integer&gt; topMap = stack.peek();<br>                topMap.put(atom, topMap.getOrDefault(atom, <span class="hljs-number">0</span>) + num);<br>                System.out.println(stack);<span class="hljs-comment">// 调试</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// -------------------------------- TreeMap ------------------------------------</span><br>        Map&lt;String, Integer&gt; map = stack.pop();<br><br>        <span class="hljs-comment">// 按 key 升序</span><br>        TreeMap&lt;String, Integer&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(map);<span class="hljs-comment">// 默认按 key 升序</span><br>        System.out.println(<span class="hljs-string">&quot;\nTreeSet, 按 key 升序:\t&quot;</span> + treeMap);<br><br>        <span class="hljs-comment">// 按 key 降序</span><br>        TreeMap&lt;String, Integer&gt; treeMapReverse = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(Comparator.reverseOrder());<span class="hljs-comment">// 按 value 升序</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>            String atom = entry.getKey();<br>            <span class="hljs-keyword">int</span> num = entry.getValue();<br>            treeMapReverse.put(atom, num);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;TreeSet, 按 key 降序:\t&quot;</span> + treeMapReverse);<br><br>        <span class="hljs-comment">// --------------------------------- Stream ------------------------------------</span><br>        <span class="hljs-comment">// 按 key 升序</span><br>        Map&lt;String, Integer&gt; sortedByKey = map.entrySet().stream()<br>            .sorted((e1, e2) -&gt; e1.getKey().compareTo(e2.getKey()))<br>            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,<br>                                      (v1, v2) -&gt; v1, LinkedHashMap::<span class="hljs-keyword">new</span>));<span class="hljs-comment">// 不能是 HashMap</span><br>        System.out.println(<span class="hljs-string">&quot;\nStream,  按 key 升序:\t&quot;</span> + sortedByKey);<br><br>        <span class="hljs-comment">// 按 key 降序</span><br>        Map&lt;String, Integer&gt; sortedByKeyReverse =  map.entrySet().stream()<br>            .sorted((e1, e2) -&gt; e2.getKey().compareTo(e1.getKey()))<br>            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,<br>                                      (v1, v2) -&gt; v2, LinkedHashMap::<span class="hljs-keyword">new</span>));<span class="hljs-comment">// 这里 -&gt; v1, v2 都行</span><br>        System.out.println(<span class="hljs-string">&quot;Stream,  按 key 降序:\t&quot;</span> + sortedByKeyReverse);<br><br>        <span class="hljs-comment">// 按 value 升序</span><br>        Map&lt;String, Integer&gt; sortedByValue =  map.entrySet().stream()<br>            .sorted((e1, e2) -&gt; e1.getValue() - e2.getValue())<span class="hljs-comment">// 也可以用 compareTo</span><br>            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,<br>                                      (v1, v2) -&gt; v1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br>        System.out.println(<span class="hljs-string">&quot;Stream,  按 value 升序:\t&quot;</span> + sortedByValue);<br><br>        <span class="hljs-comment">// 按 value 降序</span><br>        Map&lt;String, Integer&gt; sortedByValueReverse =  map.entrySet().stream()<br>            .sorted((e1, e2) -&gt; e2.getValue() - e1.getValue())<br>            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,<br>                                      (v1, v2) -&gt; v1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br>        System.out.println(<span class="hljs-string">&quot;Stream,  按 value 降序:\t&quot;</span> + sortedByValueReverse);<br><br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : treeMap.entrySet()) &#123;<br>            String atom = entry.getKey();<br>            <span class="hljs-keyword">int</span> num = entry.getValue();<br>            sb.append();<br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">1</span>) &#123;<br>                sb.append(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Solution solution = <span class="hljs-keyword">new</span> Solution();<br>        String str = <span class="hljs-string">&quot;K4(ON(SkdHt5O3)2)2&quot;</span>;<br>        System.out.println(solution.countOfAtoms(str));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">[&#123;K=<span class="hljs-number">4</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;O=<span class="hljs-number">1</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;N=<span class="hljs-number">1</span>, O=<span class="hljs-number">1</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;N=<span class="hljs-number">1</span>, O=<span class="hljs-number">1</span>&#125;, &#123;Skd=<span class="hljs-number">1</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;N=<span class="hljs-number">1</span>, O=<span class="hljs-number">1</span>&#125;, &#123;Ht=<span class="hljs-number">5</span>, Skd=<span class="hljs-number">1</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;N=<span class="hljs-number">1</span>, O=<span class="hljs-number">1</span>&#125;, &#123;Ht=<span class="hljs-number">5</span>, Skd=<span class="hljs-number">1</span>, O=<span class="hljs-number">3</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>&#125;, &#123;Ht=<span class="hljs-number">10</span>, Skd=<span class="hljs-number">2</span>, N=<span class="hljs-number">1</span>, O=<span class="hljs-number">7</span>&#125;]<br>[&#123;K=<span class="hljs-number">4</span>, Ht=<span class="hljs-number">20</span>, Skd=<span class="hljs-number">4</span>, N=<span class="hljs-number">2</span>, O=<span class="hljs-number">14</span>&#125;]<br><br>TreeSet, 按 key 升序:&#123;Ht=<span class="hljs-number">20</span>, K=<span class="hljs-number">4</span>, N=<span class="hljs-number">2</span>, O=<span class="hljs-number">14</span>, Skd=<span class="hljs-number">4</span>&#125;<br>TreeSet, 按 key 降序:&#123;Skd=<span class="hljs-number">4</span>, O=<span class="hljs-number">14</span>, N=<span class="hljs-number">2</span>, K=<span class="hljs-number">4</span>, Ht=<span class="hljs-number">20</span>&#125;<br><br>Stream,  按 key 升序:&#123;Ht=<span class="hljs-number">20</span>, K=<span class="hljs-number">4</span>, N=<span class="hljs-number">2</span>, O=<span class="hljs-number">14</span>, Skd=<span class="hljs-number">4</span>&#125;<br>Stream,  按 key 降序:&#123;Skd=<span class="hljs-number">4</span>, O=<span class="hljs-number">14</span>, N=<span class="hljs-number">2</span>, K=<span class="hljs-number">4</span>, Ht=<span class="hljs-number">20</span>&#125;<br>Stream,  按 value 升序:&#123;N=<span class="hljs-number">2</span>, K=<span class="hljs-number">4</span>, Skd=<span class="hljs-number">4</span>, O=<span class="hljs-number">14</span>, Ht=<span class="hljs-number">20</span>&#125;<br>Stream,  按 value 降序:&#123;Ht=<span class="hljs-number">20</span>, O=<span class="hljs-number">14</span>, K=<span class="hljs-number">4</span>, Skd=<span class="hljs-number">4</span>, N=<span class="hljs-number">2</span>&#125;<br><br>Ht20K4N2O14Skd4<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>int[]</tag>
      
      <tag>String</tag>
      
      <tag>List</tag>
      
      <tag>Map</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4 链表</title>
    <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4%20%20%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4%20%20%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-ListNode"><a href="#4-1-ListNode" class="headerlink" title="4.1 ListNode"></a>4.1 ListNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span> ListNode next;<br>    <span class="hljs-keyword">public</span> ListNode right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, ListNode next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildLinkedList</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        ListNode p = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            p.next = <span class="hljs-keyword">new</span> ListNode(num);<br>            p = p.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (ListNode p = <span class="hljs-keyword">this</span>.next; p != <span class="hljs-keyword">null</span>; p = p.next) &#123;<br>            System.out.print(p.val + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random rand = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span>[] nums = rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>).limit(<span class="hljs-number">9</span>).toArray();<br>        System.out.println(Arrays.toString(nums));<br><br>        ListNode head = <span class="hljs-keyword">new</span> ListNode();<br>        head.buildLinkedList(nums);<br>        head.reverse(<span class="hljs-number">5</span>);<br>        head.traverse();<br>        System.out.println(head.searchReciprocalKth(<span class="hljs-number">3</span>));<br>        System.out.println(head.searchMid());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-反转链表"><a href="#4-2-反转链表" class="headerlink" title="4.2 反转链表"></a>4.2 反转链表</h2><h3 id="4-2-1-反转全部元素"><a href="#4-2-1-反转全部元素" class="headerlink" title="4.2.1 反转全部元素"></a>4.2.1 反转全部元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode p = <span class="hljs-keyword">this</span>;<br>    ListNode q = p.next;<br>    p.next = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode r = q.next;<br>        q.next = p.next;<br>        p.next = q;<br>        q = r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-反转前-k-个元素"><a href="#4-2-2-反转前-k-个元素" class="headerlink" title="4.2.2 反转前 k 个元素"></a>4.2.2 反转前 k 个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode end = <span class="hljs-keyword">this</span>.next;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; end != <span class="hljs-keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;<br>        end = end.next;<br>    &#125;<br><br>    ListNode p = <span class="hljs-keyword">this</span>;<br>    ListNode q = p.next;<br>    p.next = end;<br>    <span class="hljs-keyword">while</span> (q != end) &#123;<br>        ListNode r = q.next;<br>        q.next = p.next;<br>        p.next = q;<br>        q = r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-反转-left-right-的元素"><a href="#4-2-3-反转-left-right-的元素" class="headerlink" title="4.2.3 反转 [left, right] 的元素"></a>4.2.3 反转 [left, right] 的元素</h3><p>反转 $[2, 4]$ 的元素：$[1, 2, 3, 4, 5] → [1, 4, 3, 2, 5]$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    ListNode p = <span class="hljs-keyword">this</span>;<br>    ListNode end = <span class="hljs-keyword">this</span>.next;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (end != <span class="hljs-keyword">null</span> &amp;&amp; (i &lt; left || j &lt; right)) &#123;<br>        <span class="hljs-keyword">if</span> (i++ &lt; left) &#123;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j++ &lt; right) &#123;<br>            end = end.next;<br>        &#125;<br>    &#125;<br><br>    ListNode q = p.next;<br>    p.next = end;<br>    <span class="hljs-keyword">while</span> (q != end) &#123;<br>        ListNode r = q.next;<br>        q.next = p.next;<br>        p.next = q;<br>        q = r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-删除倒数第-k-个元素"><a href="#4-3-删除倒数第-k-个元素" class="headerlink" title="4.3 删除倒数第 k 个元素"></a>4.3 删除倒数第 k 个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteReciprocalKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode p = <span class="hljs-keyword">this</span>;<br>    ListNode q = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        q = q.next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.next != <span class="hljs-keyword">null</span>) &#123;<br>        p = p.next;<br>        q = q.next;<br>    &#125;<br>    p.next = p.next.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-查找中间元素"><a href="#4-4-查找中间元素" class="headerlink" title="4.4 查找中间元素"></a>4.4 查找中间元素</h2><p>$[1, 2, 3, 4]$ 的中间元素：$2$</p><p>$[1, 2, 3, 4, 5]$ 的中间元素：$3$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchMid</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode slow = <span class="hljs-keyword">this</span>;<br>    ListNode fast = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;<br>            fast = fast.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow.val;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反转链表</tag>
      
      <tag>删除倒数第 k 个元素</tag>
      
      <tag>查找中间元素</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3 二分查找</title>
    <link href="/2021/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-查找第一个-target​-的索引"><a href="#2-1-查找第一个-target​-的索引" class="headerlink" title="2.1 查找第一个 target​ 的索引"></a>2.1 查找第一个 target​ 的索引</h2><h3 id="2-1-1-出现-right-mid-时，-mid-取下界"><a href="#2-1-1-出现-right-mid-时，-mid-取下界" class="headerlink" title="2.1.1 出现 $right = mid$ 时，$mid$ 取下界"></a>2.1.1 出现 $right = mid$ 时，$mid$ 取下界</h3><p>考虑只有两个元素时 $[left, right]$</p><ul><li><p>若取上界，即 $mid = left + (right - left + 1) / 2 = right$</p></li><li><p>当 $target ≤ nums[mid]$ 时，$right = mid$。即 $left &lt; right$ 恒成立，造成死循环</p></li></ul><p>因此，出现 $right = mid$ 时，$mid$ 取下界，即 $mid = left + (right - left) / 2$</p><h3 id="2-1-2-Code"><a href="#2-1-2-Code" class="headerlink" title="2.1.2 Code"></a>2.1.2 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * T(n) = T(n/2) + 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchFirstPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid]) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target == nums[left] ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-查找最后一个-target-的索引"><a href="#2-2-查找最后一个-target-的索引" class="headerlink" title="2.2 查找最后一个 target 的索引"></a>2.2 查找最后一个 target 的索引</h2><h3 id="2-2-1-出现-left-mid-时，-mid-取上界"><a href="#2-2-1-出现-left-mid-时，-mid-取上界" class="headerlink" title="2.2.1 出现 $left = mid$ 时，$mid$ 取上界"></a>2.2.1 出现 $left = mid$ 时，$mid$ 取上界</h3><p>考虑只有两个元素时 $[left, right]$</p><ul><li>若取下界，即 $mid = left + (right - left) / 2 = left$</li><li>当 $target ≥ nums[mid]$ 时，$left = mid$。即 $left &lt; right$ 恒成立，造成死循环</li></ul><p>因此，出现 $left = mid$ 时，$mid$ 取上界，即 $mid = left + (right - left + 1) / 2$</p><h3 id="2-2-2-Code"><a href="#2-2-2-Code" class="headerlink" title="2.2.2 Code"></a>2.2.2 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchLastPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target &gt;= nums[mid]) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target == nums[left] ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找第一个 target 的索引</tag>
      
      <tag>查找最后一个 target 的索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2 排序</title>
    <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2%20%20%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2%20%20%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="2-0-总表"><a href="#2-0-总表" class="headerlink" title="2.0 总表"></a>2.0 总表</h2><table><thead><tr><th>排序算法</th><th>时间：最好</th><th>时间：平均</th><th>时间：最坏</th><th>空间</th><th>是否稳定</th></tr></thead><tbody><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>✔</td></tr><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>✔</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td></td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td></td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td>✔</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td></td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>✔</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>✔</td></tr><tr><td>基数排序</td><td>$O(d×n)$</td><td>$O(d×n)$</td><td>$O(d×n)$</td><td>$O(n+r)$</td><td>✔</td></tr></tbody></table><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><ul><li><p>给定一个 $[0, n]$ 的数组，假设 $[0, j]$ 已经升序，且 $i = j + 1$</p></li><li><p>记录下待插入元素 $temp = nums[i]$，然后从 $j$ 开始向左遍历</p></li><li><p>向左遍历条件：$temp &lt; nums[j]$，同时 $nums[j]$ 依次右移一位，即 $nums[j + 1] = nums[j]$，$j–$；直到 $temp ≥ nums[j]$ 时退出循环，并将 $temp$ 插入 $j+1$ 处</p></li><li><p>因为存在 $j–$，所以必须增加边界条件 $j ≥ 0$，避免访问 $nums[j]$ 时发生越界</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; nums[j]) &#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j];<br>            j--;<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                swap(nums, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> minValIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[minValIndex]) &#123;<br>                minValIndex = j;<br>            &#125;<br>        &#125;<br>        swap(nums, i, minValIndex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-快速排序"><a href="#2-4-快速排序" class="headerlink" title="2.4 快速排序"></a>2.4 快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> pivot = partition(nums, left, right);<br>    quickSort(nums, left, pivot - <span class="hljs-number">1</span>);<br>    quickSort(nums, pivot + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = left; j &lt; right; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &lt; nums[right]) &#123;<br>            Swap.swap(nums, i, j);<br>            i++;<br>        &#125;<br>    &#125;<br>    Swap.swap(nums, i, right);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-1-使用快排思想在-O-n-时间内查找第-k-大的元素"><a href="#2-4-1-使用快排思想在-O-n-时间内查找第-k-大的元素" class="headerlink" title="2.4.1 使用快排思想在 O(n) 时间内查找第 k 大的元素"></a>2.4.1 使用快排思想在 O(n) 时间内查找第 k 大的元素</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的 k 个数</a></p><p>$[24, 60, 73, 36, 17]$，第 $2$ 大的元素: $60$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = left; j &lt; right; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[right]) &#123;<br>                swap(nums, i, j);<br>                i++;<br>            &#125;<br>        &#125;<br>        swap(nums, i, right);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> pivot = partition(nums, left, right);<br>        <span class="hljs-keyword">int</span> target = pivot - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt; target) &#123;<br>            kthLargest(nums, k, left, pivot - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; target) &#123;<br>            kthLargest(nums, k - target, pivot + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        kthLargest(arr, k, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.arraycopy(arr, <span class="hljs-number">0</span>, res, <span class="hljs-number">0</span>, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-荷兰国旗问题"><a href="#2-4-2-荷兰国旗问题" class="headerlink" title="2.4.2 荷兰国旗问题"></a>2.4.2 荷兰国旗问题</h3><p><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode 75. 颜色分类</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 循环不变量原理 2021.9.26</span><br><span class="hljs-comment"> * 0: [0, p0)</span><br><span class="hljs-comment"> * 1: [p0, i)</span><br><span class="hljs-comment"> * 2: (p2, n - 1]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= p2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>            swap(nums, i, p0);<br>            p0++;<br>            i++;    <span class="hljs-comment">// i == p0 时，i 和 p0 -&gt; 0; i &gt; p0 时，i -&gt; 0, p0 -&gt; 1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            swap(nums, i, p2)、;<br>            p2--;   <span class="hljs-comment">// i 不用 ++，因为不知道交换后的 i 指向多少</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-归并排序"><a href="#2-5-归并排序" class="headerlink" title="2.5 归并排序"></a>2.5 归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * T(n) = 2T(n/2) + n-1</span><br><span class="hljs-comment"> * 合并两个有序数组最坏的比较次数：n-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> reversePair = <span class="hljs-number">0</span>; <span class="hljs-comment">// 逆序对</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    mergeSort(nums, left, mid, temp);<br>    mergeSort(nums, mid + <span class="hljs-number">1</span>, right, temp);<br>    merge(nums, left, mid, right, temp);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>    <span class="hljs-comment">// mid 向下取整，可以取到 mid + 1</span><br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;<br>        temp[i] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = left;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>        <span class="hljs-keyword">if</span> (temp[i] &lt;= temp[j]) &#123;<br>            nums[k++] = temp[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[k++] = temp[j++];<br>            reversePair += mid + <span class="hljs-number">1</span> - i;    <span class="hljs-comment">// 不求逆序对，只需删除改行</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        nums[k++] = temp[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>        nums[k++] = temp[j++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-堆排序"><a href="#2-6-堆排序" class="headerlink" title="2.6 堆排序"></a>2.6 堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">HeapType</span> </span>&#123;BIG, SMALL&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] heap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapRight;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HeapType heapType;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.heap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">this</span>.heapRight = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.heapType = HeapType.SMALL;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(HeapType heapType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.heap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">this</span>.heapRight = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.heapType = heapType;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, HeapType heapType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.heap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[heap.length];<br>        System.arraycopy(heap, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.heap, <span class="hljs-number">0</span>, heap.length);<br>        <span class="hljs-keyword">this</span>.heapRight = heap.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.heapType = heapType;<br>        buildHeap();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heapRight == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (heapRight - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            downAdjust(i, heapRight);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span> &lt;= right) &amp;&amp; (heapType == HeapType.SMALL ?<br>                    heap[j + <span class="hljs-number">1</span>] &lt; heap[j] : heap[j + <span class="hljs-number">1</span>] &gt; heap[j])) &#123;<br>                j += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (heapType == HeapType.SMALL ? heap[i] &lt;= heap[j] : heap[i] &gt;= heap[j]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Swap.swap(heap, i, j);<br><br>            i = j;<br>            j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = right;<br>        <span class="hljs-keyword">int</span> j = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span> (j &gt;= left) &#123;<br>            <span class="hljs-keyword">if</span> (heapType == HeapType.SMALL ? heap[j] &lt;= heap[i] : heap[j] &gt;= heap[i]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Swap.swap(heap, i, j);<br><br>            i = j;<br>            j = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> heapRight + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.print(<span class="hljs-string">&quot;Heap is null, default top is &quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[heap.length + <span class="hljs-number">1</span>];<br><br>        System.arraycopy(heap, <span class="hljs-number">0</span>, temp, <span class="hljs-number">0</span>, heap.length);<br>        temp[++heapRight] = v;<br>        heap = temp;<br>        upAdjust(<span class="hljs-number">0</span>, heapRight);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> top;<br>        <span class="hljs-keyword">try</span> &#123;<br>            top = heap[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.print(<span class="hljs-string">&quot;Heap is null, default top is &quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[heap.length - <span class="hljs-number">1</span>];<br>        heap[<span class="hljs-number">0</span>] = heap[heapRight--];<br>        System.arraycopy(heap, <span class="hljs-number">0</span>, temp, <span class="hljs-number">0</span>, heap.length - <span class="hljs-number">1</span>);<br>        heap = temp;<br>        downAdjust(<span class="hljs-number">0</span>, heapRight);<br><br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            heap[<span class="hljs-number">0</span>] = v;<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.print(<span class="hljs-string">&quot;Heap is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        downAdjust(<span class="hljs-number">0</span>, heapRight);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 大顶堆：升序</span><br><span class="hljs-comment">     * 小顶堆：降序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = heapRight; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            Swap.swap(heap, i, <span class="hljs-number">0</span>);<br>            downAdjust(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查找数据流中前 k 大的元素</span><br><span class="hljs-comment">     * 时间：O(nlogk)</span><br><span class="hljs-comment">     * 空间：O(k)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getTopK(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span>[] topK = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, topK, <span class="hljs-number">0</span>, k);<br>        Heap h = <span class="hljs-keyword">new</span> Heap(topK, HeapType.SMALL);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; h.heap[<span class="hljs-number">0</span>]) &#123;<br>                h.replaceTop(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.heap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random rand = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span>[] nums = rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>).limit(<span class="hljs-number">7</span>).toArray();<br>        System.out.println(Arrays.toString(nums));<br><br>        Heap h = <span class="hljs-keyword">new</span> Heap(nums, HeapType.BIG);<br>        h.push(<span class="hljs-number">5</span>);<br>        System.out.println(Arrays.toString(h.heap));<br><br>        <span class="hljs-keyword">int</span> top = h.pop();<br>        System.out.println(top);<br>        System.out.println(Arrays.toString(h.heap));<br><br>        h.heapSort();<br>        System.out.println(Arrays.toString(h.heap));<br><br>        <span class="hljs-keyword">int</span>[] topNums = rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).limit(<span class="hljs-number">100</span>).toArray();<br>        System.out.println(Arrays.toString(topNums));<br>        System.out.println(<span class="hljs-string">&quot;前 k 大的元素:\t&quot;</span> + Arrays.toString(getTopK(topNums, <span class="hljs-number">10</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-7-计数排序"><a href="#2-7-计数排序" class="headerlink" title="2.7 计数排序"></a>2.7 计数排序</h2><p>应用场景：$nums$ 中的元素位于 $[0, k]$，且 $k &lt; n$。 $\frac{n}{k}$ 越大越快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] countSort(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        count[num]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        count[i] += count[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        res[--count[num]] = num;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-8-桶排序"><a href="#2-8-桶排序" class="headerlink" title="2.8 桶排序"></a>2.8 桶排序</h2><h3 id="2-8-1-数组-快排"><a href="#2-8-1-数组-快排" class="headerlink" title="2.8.1 数组 + 快排"></a>2.8.1 数组 + 快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> minVal, <span class="hljs-keyword">int</span> maxVal)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> diff = maxVal - minVal;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bucketCnt = (<span class="hljs-keyword">int</span>) (diff * <span class="hljs-number">0.1</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bucketSize = diff / bucketCnt;<br>    List&lt;List&lt;Integer&gt;&gt; bucket = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketCnt; i++) &#123;<br>        bucket.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        bucket.get(i).add(minVal);<br>        minVal += bucketSize;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketCnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; bucketCnt - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (num &gt;= bucket.get(i).get(<span class="hljs-number">0</span>) &amp;&amp; num &lt; bucket.get(i + <span class="hljs-number">1</span>).get(<span class="hljs-number">0</span>)) &#123;<br>                    bucket.get(i).add(num);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                bucket.get(i).add(num);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-2-链表"><a href="#2-8-2-链表" class="headerlink" title="2.8.2 链表"></a>2.8.2 链表</h3><p>当平均每个桶的元素个数 &lt; 数组版本的桶的元素个数时，链表版本更快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSortByListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> minVal, <span class="hljs-keyword">int</span> maxVal)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> diff = maxVal - minVal;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bucketCnt = (<span class="hljs-keyword">int</span>) (diff * <span class="hljs-number">0.3</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bucketSize = diff / bucketCnt;<br>    <span class="hljs-keyword">boolean</span> hasInsert = <span class="hljs-keyword">false</span>;<br>    ListNode head = <span class="hljs-keyword">new</span> ListNode();<br>    ListNode p = head;<br><br>    <span class="hljs-comment">// 哨兵：使用 bucket + 1 个桶，最后一个桶作为哨兵，val = Integer.MAX_VALUE，right = null</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= bucketCnt; i++) &#123;<br>        ListNode bucket = <span class="hljs-keyword">new</span> ListNode(minVal);<br>        p.next = bucket;<br>        p = bucket;<br>        minVal += bucketSize;<br>    &#125;<br>    p.val = Integer.MAX_VALUE;<br><br>    ListNode r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(num);<br><br>        <span class="hljs-keyword">for</span> (p = head.next; p.next != <span class="hljs-keyword">null</span>; p = p.next) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= p.val &amp;&amp; num &lt; p.next.val) &#123;<br>                <span class="hljs-keyword">for</span> (r = p; r.right != <span class="hljs-keyword">null</span>; r = r.right) &#123;<br>                    <span class="hljs-keyword">if</span> (num &gt;= r.val &amp;&amp; num &lt; r.right.val) &#123;<br>                        node.right = r.right;<br>                        r.right = node;<br>                        hasInsert = <span class="hljs-keyword">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (r.right == <span class="hljs-keyword">null</span>) &#123;<br>                    r.right = node;<br>                    hasInsert = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (hasInsert) &#123;<br>                hasInsert = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (p = head.next; p.next != <span class="hljs-keyword">null</span>; p = p.next) &#123;<br>        <span class="hljs-keyword">for</span> (r = p.right; r != <span class="hljs-keyword">null</span>; r = r.right) &#123;<br>            nums[k++] = r.val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-9-基数排序"><a href="#2-9-基数排序" class="headerlink" title="2.9 基数排序"></a>2.9 基数排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> maxVal)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> d = Integer.toString(maxVal).length();<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">10</span>;<br>    List&lt;List&lt;Integer&gt;&gt; radix = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) &#123;<br>        radix.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">int</span> bit = num / (<span class="hljs-keyword">int</span>) Math.pow(r, i) % <span class="hljs-number">10</span>;<br>            radix.get(bit).add(num);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : radix.get(j)) &#123;<br>                nums[k++] = val;<br>            &#125;<br>            radix.get(j).clear();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-10-Code"><a href="#2-10-Code" class="headerlink" title="2.10 Code"></a>2.10 Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> start;<br>    <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">10000</span>;<br>    Random rand = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">int</span>[] data = rand.ints(<span class="hljs-number">0</span>, maxVal + <span class="hljs-number">1</span>).limit(<span class="hljs-number">100000</span>).toArray();<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[data.length];<br>    <span class="hljs-keyword">int</span>[] cmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[data.length];<br>    System.arraycopy(data, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, data.length);<br>    System.arraycopy(data, <span class="hljs-number">0</span>, cmp, <span class="hljs-number">0</span>, data.length);<br><br>    start = System.nanoTime();<br>    Arrays.sort(cmp);<br>    System.out.println(<span class="hljs-string">&quot;Arrays.sort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms\n&quot;</span>);<br><br>    <span class="hljs-comment">// --------------------------------------- O(n^2) ---------------------------------------</span><br>    <span class="hljs-comment">// 插入排序</span><br>    start = System.nanoTime();<br>    insertSort(nums);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;insertSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;insertSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 冒泡排序</span><br>    start = System.nanoTime();<br>    bubbleSort(nums);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bubbleSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;bubbleSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 选择排序</span><br>    start = System.nanoTime();<br>    selectSort(nums);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;selectSort is error&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;selectSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms\n&quot;</span>);<br><br><br>    <span class="hljs-comment">// -------------------------------------- O(nlogn) --------------------------------------</span><br>    <span class="hljs-comment">// 快速排序</span><br>    start = System.nanoTime();<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;quickSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;quickSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 归并排序</span><br>    start = System.nanoTime();<br>    mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;mergeSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;mergeSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 堆排序</span><br>    start = System.nanoTime();<br>    nums = Heap.heapSort(nums);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;heapSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;heapSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms\n&quot;</span>);<br><br><br>    <span class="hljs-comment">// --------------------------------------- O(n) ----------------------------------------</span><br>    <span class="hljs-comment">// 计数排序</span><br>    start = System.nanoTime();<br>    nums = countSort(nums, maxVal);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;countSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;countSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 基数排序</span><br>    start = System.nanoTime();<br>    radixSort(nums, maxVal);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;radixSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;radixSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 桶排序：数组</span><br>    start = System.nanoTime();<br>    bucketSort(nums, <span class="hljs-number">0</span>, maxVal);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bucketSort is error&quot;</span>);<br>    &#125;<br>    nums = data;<br>    System.out.println(<span class="hljs-string">&quot;bucketSort\t\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>    <span class="hljs-comment">// 桶排序：链表</span><br>    start = System.nanoTime();<br>    bucketSortByListNode(nums, <span class="hljs-number">0</span>, maxVal);<br>    <span class="hljs-keyword">if</span> (!Arrays.equals(nums, cmp)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bucketSortByListNode is error&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;bucketSortByListNode\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sortuse <span class="hljs-number">16.6252</span> ms<br><br>insertSortuse <span class="hljs-number">1327.9551</span> ms<br>bubbleSortuse <span class="hljs-number">17897.3403</span> ms<br>selectSortuse <span class="hljs-number">1297.4953</span> ms<br><br>quickSortuse <span class="hljs-number">55.044</span> ms<br>mergeSortuse <span class="hljs-number">13.5013</span> ms<br>heapSortuse <span class="hljs-number">16.2483</span> ms<br><br>countSortuse <span class="hljs-number">4.3291</span> ms<br>radixSortuse <span class="hljs-number">40.2653</span> ms<br>bucketSortuse <span class="hljs-number">70.2101</span> ms<br>bucketSortByListNodeuse <span class="hljs-number">157.0709</span> ms<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章  空间亚线性算法</title>
    <link href="/2021/06/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC1%E7%AB%A0%20%20%E7%A9%BA%E9%97%B4%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2021/06/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E7%AC%AC1%E7%AB%A0%20%20%E7%A9%BA%E9%97%B4%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-蓄水池抽样算法-Reservoir-Sampling"><a href="#1-1-蓄水池抽样算法-Reservoir-Sampling" class="headerlink" title="1.1 蓄水池抽样算法 Reservoir Sampling"></a>1.1 蓄水池抽样算法 Reservoir Sampling</h2><h3 id="1-1-1-问题"><a href="#1-1-1-问题" class="headerlink" title="1.1.1 问题"></a>1.1.1 问题</h3><p>在一个包含 $n$（ $n$ 未知，且 $n &gt; k$）个元素的数据流中随机抽样 $k$ 个元素，需保证每个元素被抽样的概率均为 $\frac{k}{n}$</p><h3 id="1-1-2-算法思路"><a href="#1-1-2-算法思路" class="headerlink" title="1.1.2 算法思路"></a>1.1.2 算法思路</h3><p>使用一个大小为 $k$ 的数组 $reservoir$ 实时保存抽样的 $k$ 个元素，当遍历完一次数据流时，数组 $reservoir$ 即为最终结果</p><p>首先，将数据流的前 $k$ 个元素直接添加到 $reservoir$ 中；然后，当遍历到第 $i(i &gt; k)$ 个元素时，第 $i$ 个元素以 $\frac{k}{i}$ 的概率替换 $reservoir$ 中的某个元素。例如，第 $k + 1$ 个元素替换 $reservoir$ 中某个元素的概率为 $\frac{k}{k+1}$</p><h4 id="1-当-i-gt-k-时，第-i-个元素一直在-reservoir-中的概率是多少？"><a href="#1-当-i-gt-k-时，第-i-个元素一直在-reservoir-中的概率是多少？" class="headerlink" title="1. 当 $i&gt;k$ 时，第 $i$ 个元素一直在 $reservoir$ 中的概率是多少？"></a>1. 当 $i&gt;k$ 时，第 $i$ 个元素一直在 $reservoir$ 中的概率是多少？</h4><p>第 $i(i&gt;k)$ 个元素以 $\frac{k}{i}$ 的概率替换 $reservoir$ 中的某个元素后，还需同时保证不被第 $i+1,i+2,…,n$ 个元素替换，最终才能一直在 $reservoir$ 中，即最终被抽样得到</p><p>显然，当第 $i$ 个元素已经在 $reservoir$ 时，它被选中的概率为 $\frac{1}{k}$，而第 $i+1$ 个元素替换 $reservoir$ 中某个元素的概率为 $\frac{k}{i+1}$</p><ul><li><p>第 $i$ 个元素被第 $i+1$ 个元素替换的概率为 $\frac{1}{k}×\frac{k}{i+1}$</p></li><li><p>第 $i$ 个元素不被第 $i+1$ 个元素替换的概率为  $1-\frac{1}{k}×\frac{k}{i+1} = 1-\frac{1}{i+1}$</p></li></ul><p>因此，第 $i$ 个元素一直在 $reservoir$ 中的概率为<br>$$<br>\frac{k}{i}×(1-\frac{1}{i+1})×(1-\frac{1}{i+2})×…×(1-\frac{1}{n})= \frac{k}{i}×\frac{i}{i+1}×\frac{i+1}{i+2}×…×\frac{n-1}{n}=\frac{k}{n}<br>$$</p><h4 id="2-当-i≤k-时，第-i-个元素一直在-reservoir-中的概率是多少？"><a href="#2-当-i≤k-时，第-i-个元素一直在-reservoir-中的概率是多少？" class="headerlink" title="2. 当 $i≤k$ 时，第 $i$ 个元素一直在 $reservoir$ 中的概率是多少？"></a>2. 当 $i≤k$ 时，第 $i$ 个元素一直在 $reservoir$ 中的概率是多少？</h4><p>前面已经指出，前 $k$ 个元素被直接添加到 $reservoir$ 中，因此第 $i(i≤k)$ 个元素最开始在 $reservoir$ 中的概率为 $1$</p><p>若第 $i$ 个元素想一直在 $reservoir$ 中，则需同时保证不被第 $k+1,k+2,…,n$ 个元素替换</p><p>因此，第 $i$ 个元素一直在 $reservoir$ 中的概率为<br>$$<br>1×(1-\frac{1}{k+1})×(1-\frac{1}{k+2})×…×(1-\frac{1}{n})= 1×\frac{k}{k+1}×\frac{k+1}{k+2}×…×\frac{n-1}{n}=\frac{k}{n}<br>$$</p><h4 id="3-替换概率-frac-k-i-如何实现？替换哪个元素？"><a href="#3-替换概率-frac-k-i-如何实现？替换哪个元素？" class="headerlink" title="3. 替换概率 $\frac{k}{i}$ 如何实现？替换哪个元素？"></a>3. 替换概率 $\frac{k}{i}$ 如何实现？替换哪个元素？</h4><p>可以发现，$i&gt;k$ 时，区间长度 $[1, k]$ 与 $[1,i]$ 的比值恰为 $\frac{k}{i}$</p><p>因此，可以生成一个随机数 $r∈[1,i]$，当 $r≤k$ 时，第 $i$ 个元素以  $\frac{k}{i}$ 的概率替换 $reservoir$ 的第 $r$ 个元素</p><h4 id="4-如何验证抽样概率-frac-k-n-？"><a href="#4-如何验证抽样概率-frac-k-n-？" class="headerlink" title="4. 如何验证抽样概率 $\frac{k}{n}$？"></a>4. 如何验证抽样概率 $\frac{k}{n}$？</h4><p>一次抽样结束后，$reservoir$ 中的元素即为抽样的值。为方便验证，将 $[1,n]$ 的整数作为数据源，对其进行 $experiments$ 次抽样，用一个数组 $ inReservoirCnts$ 统计数据流中每个元素 $num$ 被抽样的次数 $inReservoirCnts[num-1]$ </p><p>当抽样次数 $experiments$ 足够大时，<br>$$<br>\frac{inReservoirCnts[num-1]}{experiments} → \frac{k}{n}<br>$$<br>对于误差分析，可以计算每个元素的相对误差 $relativeError[i]$，得到平均相对误差、最大相对误差</p><h4 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h4><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(k)$</p><h3 id="1-1-3-Code"><a href="#1-1-3-Code" class="headerlink" title="1.1.3 Code"></a>1.1.3 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReservoirSampling</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> experiments = <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">sample</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; reservoir = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Random rand = <span class="hljs-keyword">new</span> Random();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= k) &#123;<br>                reservoir.add(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> r = rand.nextInt(i) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (r &lt;= k) &#123;<br>                    reservoir.set(r - <span class="hljs-number">1</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reservoir;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">errorAnalysis</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inReservoirCnts)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> theoreticalPr = (<span class="hljs-keyword">double</span>) k / n;<br>        <span class="hljs-keyword">double</span>[] relativeError = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">double</span> realPr = (<span class="hljs-keyword">double</span>) inReservoirCnts[i] / experiments;<br>            relativeError[i] = Double.parseDouble(<br>                    String.format(<span class="hljs-string">&quot;%.4f&quot;</span>, Math.abs(realPr - theoreticalPr) / theoreticalPr));<br>        &#125;<br>        System.out.println(Arrays.toString(relativeError));<br><br>        DoubleSummaryStatistics relativeErrorStatistics = Arrays.stream(relativeError).boxed()<br>                .collect(Collectors.summarizingDouble(d -&gt; d));<br>        System.out.println(<span class="hljs-string">&quot;平均相对误差:\t&quot;</span> + relativeErrorStatistics.getAverage());<br>        System.out.println(<span class="hljs-string">&quot;最大相对误差:\t&quot;</span> + relativeErrorStatistics.getMax());<br>        System.out.println(<span class="hljs-string">&quot;最小相对误差:\t&quot;</span> + relativeErrorStatistics.getMin());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] inReservoirCnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> e = <span class="hljs-number">0</span>; e &lt; experiments; e++) &#123;<br>            List&lt;Integer&gt; reservoir = sample();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : reservoir) &#123;<br>                inReservoirCnts[num - <span class="hljs-number">1</span>]++;<br>            &#125;<br>        &#125;<br>        errorAnalysis(inReservoirCnts);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-4-Output"><a href="#1-1-4-Output" class="headerlink" title="1.1.4 Output"></a>1.1.4 Output</h3><p>$k=10,n=100,experiments=1000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">0.0702</span><br>最大相对误差:<span class="hljs-number">0.26</span><br>最小相对误差: <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>$k=10,n=100,experiments=1000000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">0.002421</span><br>最大相对误差:<span class="hljs-number">0.0071</span><br>最小相对误差:<span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>$k=50,n=100,experiments=1000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">0.027999999999999997</span><br>最大相对误差:<span class="hljs-number">0.08</span><br>最小相对误差:<span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>$k=50,n=100,experiments=1000000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">7.5E-4</span><br>最大相对误差:<span class="hljs-number">0.0029</span><br>最小相对误差:<span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>$k=50,n=1000,experiments=1000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">0.10740000000000001</span><br>最大相对误差:<span class="hljs-number">0.42</span><br>最小相对误差:<span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>$k=50,n=1000,experiments=1000000$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">平均相对误差:<span class="hljs-number">0.0034881</span><br>最大相对误差:<span class="hljs-number">0.0161</span><br>最小相对误差:<span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><h3 id="1-1-5-结论"><a href="#1-1-5-结论" class="headerlink" title="1.1.5 结论"></a>1.1.5 结论</h3><ul><li><p>$experiments$ 一定时，$\frac{k}{n}$ 越大，平均相对误差越小</p></li><li><p>$\frac{k}{n}$ 一定时，$experiments$ 越大，平均相对误差越小</p></li></ul><h2 id="1-2-数据流的中位数"><a href="#1-2-数据流的中位数" class="headerlink" title="1.2 数据流的中位数"></a>1.2 数据流的中位数</h2><h3 id="1-2-1-问题"><a href="#1-2-1-问题" class="headerlink" title="1.2.1 问题"></a>1.2.1 问题</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode | 295. 数据流的中位数</a></p><h3 id="1-2-2-算法思路"><a href="#1-2-2-算法思路" class="headerlink" title="1.2.2 算法思路"></a>1.2.2 算法思路</h3><h4 id="1-两个堆"><a href="#1-两个堆" class="headerlink" title="1. 两个堆"></a>1. 两个堆</h4><p>假设数据流大小为 $n$，对数据流进行升序排序。当 $n%2==1$ 时，中位数 = 中间元素 $mid$；当 $n%2==0$  时，中位数 = 中间两个元素 $mid1$ 和 $mid2$ 的平均值</p><p>将有序数据流均分为左半部分 $left$ 和右半部分 $right$，将 $mid$ 划分到 $left$，则 $mid$ 是 $left$ 中的最大值；同理，$mid1$ 是 $left$ 中的最大值，$mid2$ 是 $right$ 中的最小值。可以发现，无需关心 $mid$ 和 $mid1$ 左边的元素，$mid2$ 右边的元素是否有序，只要能够快速找到左半部分的最大值和右半部分的最小值，即可得到数据流的中位数</p><p>因此，可以使用一个「大顶堆」$low$ 保存数据流中较小的左半部分元素，一个「小顶堆」$high$ 保存数据流中较大的右半部分元素，同时，需保证 $low$ 的所有元素 $≤$ $high$ 的所有元素。当遍历完一遍数据流后，即可取出堆顶元素得到中位数</p><h4 id="2-负载平衡"><a href="#2-负载平衡" class="headerlink" title="2. 负载平衡"></a>2. 负载平衡</h4><p>算法的关键在于负载平衡：$low.size()$ 至多比 $high.size()$ 大 $1$，同时需保证 $low$ 的所有元素 $≤$ $high$ 的所有元素</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>$num$</td><td>待入堆元素</td></tr><tr><td>$push$</td><td>入堆：将 $nums$ 添加到堆尾，并做向上调整，时间复杂度为 $O(\log \frac{n}{2})$</td></tr><tr><td>$pop$</td><td>出堆：弹出堆顶元素，并做向下调整，时间复杂度为 $O(\log \frac{n}{2})$</td></tr><tr><td>$top$</td><td>返回堆顶元素，不弹出</td></tr><tr><td>$size$</td><td>返回堆中的元素个数</td></tr></tbody></table><p>（1）当 $low.size() == high.size()$ 时，执行 $low.push(num)$，此时 $low.size() == high.size() + 1$，可能会误认为满足算法要求，不必再进行任何操作。一种可能的情况：$num$ 入堆后，成为 $low$ 的堆顶元素，但不能保证 $num$ 比 $high$ 的堆顶元素小，因此必须执行 $high.push(low.pop())$</p><p>（2）当 $low.size() == high.size() + 1$ 时，执行 $low.push(num)$，此时 $low.size() == high.size() + 2$，应做负载平衡，即 $high.push(low.pop())$</p><p>综上所述，执行 $low.push(num)$ 后，应执行 $high.push(low.pop())$，最终 $low.size()$ 不变，$high.size() + 1$。在情况（1）中，会发生 $high.size() &gt; low.size()$，需再执行 $low.push(high.pop())$ 保持负载平衡</p><h4 id="3-中位数"><a href="#3-中位数" class="headerlink" title="3. 中位数"></a>3. 中位数</h4><p>遍历完一遍数据流，即可得到中位数：<code>low.size() == high.size() ? (low.top() + high.top()) * 0.5 : low.top()</code></p><h4 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h4><p>时间复杂度：最好情况下，入堆 $2$ 次，出堆 $1$ 次，时间复杂度为 $O(3\log \frac{n}{2})$；最坏情况下，入堆 $3$ 次，出堆 $2$ 次，时间复杂度为 $O(5\log \frac{n}{2})$。取出堆顶元素得到中位数的时间复杂度为 $O(1)$。因此，总的时间复杂度为 $O(\log n) + O(1) ≈ O(\log n)$</p><p>空间复杂度：$O(n)$</p><h3 id="1-2-3-进阶"><a href="#1-2-3-进阶" class="headerlink" title="1.2.3 进阶"></a>1.2.3 进阶</h3><h4 id="1-如果数据流中所有整数都在-0-到-100-范围内，如何优化算法？"><a href="#1-如果数据流中所有整数都在-0-到-100-范围内，如何优化算法？" class="headerlink" title="1. 如果数据流中所有整数都在 0 到 100 范围内，如何优化算法？"></a>1. 如果数据流中所有整数都在 0 到 100 范围内，如何优化算法？</h4><h5 id="（1）普通算法"><a href="#（1）普通算法" class="headerlink" title="（1）普通算法"></a>（1）普通算法</h5><p>声明一个数组 $count[0..100]$，$count[i]$ 中保存的是元素 $i$ 的个数</p><p>首先，遍历一遍数据流并填充 $count$，同时累加得到数据流的总元素个数 $cnt$，那么需要查找的 $target$ 是第 $\frac{cnt+1}{2}$ 个元素</p><p>若 $cnt$ 是奇数，则中位数是 $target$；若 $cnt$ 是偶数，则中位数是 $target$ 和 $target+1$ 的均值</p><h5 id="（2）计数排序-二分查找"><a href="#（2）计数排序-二分查找" class="headerlink" title="（2）计数排序 + 二分查找"></a>（2）计数排序 + 二分查找</h5><p>声明一个数组 $count[0..100]$，与计数排序一样，$count[i]$ 中保存的是 $≤i$ 的个数，此时 $cnt=count[100]$</p><p>显然，$count$ 中的值是非递减的，即升序，可以使用二分查找定位 $target$</p><p>具体来说，若 $target&gt;count[mid]$，则 $left=mid+1$；否则 $right=mid$。只要出现 $right=mid$，$mid$ 就应取下界，避免发生死循环</p><h4 id="2-如果数据流中-99-的整数都在-0-到-100-范围内，如何优化算法？"><a href="#2-如果数据流中-99-的整数都在-0-到-100-范围内，如何优化算法？" class="headerlink" title="2. 如果数据流中 99% 的整数都在 0 到 100 范围内，如何优化算法？"></a>2. 如果数据流中 99% 的整数都在 0 到 100 范围内，如何优化算法？</h4><p>显然，那剩余的 $1%$ 具体是什么并不重要，只需要知道它们的个数，就能定位 $target$，因为它们一定不在中位数所在的中间区间内</p><p>因此，可以将 $&gt;100$ 的元素直接放入 $count[100]$ 内，用于统计个数，同样可以得到 $cnt=count[100]$</p><p>事实上，只要保证 $target$ 不落在 $count[100$] 中，即有 $&gt;50%$ 的整数都在 $[0,100]$ 内，该优化算法都是有效的</p><h4 id="3-上述算法的空间复杂度能否达到亚线性级，即-lt-O-n-，应存储哪些数据？（B-站哈工大的大数据算法：王宏志）"><a href="#3-上述算法的空间复杂度能否达到亚线性级，即-lt-O-n-，应存储哪些数据？（B-站哈工大的大数据算法：王宏志）" class="headerlink" title="3. 上述算法的空间复杂度能否达到亚线性级，即 $&lt; O(n)$，应存储哪些数据？（B 站哈工大的大数据算法：王宏志）"></a>3. 上述算法的空间复杂度能否达到亚线性级，即 $&lt; O(n)$，应存储哪些数据？（B 站哈工大的大数据算法：王宏志）</h4><h3 id="1-2-4-Code"><a href="#1-2-4-Code" class="headerlink" title="1.2.4 Code"></a>1.2.4 Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Median</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">101</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据流的中位数 LeetCode 295</span><br><span class="hljs-comment">     * 时间：O(logn)</span><br><span class="hljs-comment">     * 空间：O(n)</span><br><span class="hljs-comment">     * [1, 2, 3] ------ 中位数：2</span><br><span class="hljs-comment">     * [1, 2, 3, 4] --- 中位数：2.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.length == <span class="hljs-number">1</span> ? nums[<span class="hljs-number">0</span>] : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        Heap low = <span class="hljs-keyword">new</span> Heap(Heap.HeapType.BIG);<span class="hljs-comment">// Heap 类在堆排序中定义</span><br>        Heap high = <span class="hljs-keyword">new</span> Heap(Heap.HeapType.SMALL);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            low.push(num);<br>            high.push(low.pop());<br>            <span class="hljs-keyword">if</span> (low.size() &lt; high.size()) &#123;<br>                low.push(high.pop());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> low.size() == high.size() ? (low.top() + high.top()) * <span class="hljs-number">0.5</span> : low.top();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据流的中位数</span><br><span class="hljs-comment">     * 优先队列 PriorityQueue</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianPriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.length == <span class="hljs-number">1</span> ? nums[<span class="hljs-number">0</span>] : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        PriorityQueue&lt;Integer&gt; low = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        PriorityQueue&lt;Integer&gt; high = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            low.add(num);<br>            high.add(low.remove());<br>            <span class="hljs-keyword">if</span> (low.size() &lt; high.size()) &#123;<br>                low.add(high.remove());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> low.size() == high.size() ? (low.element() + high.element()) * <span class="hljs-number">0.5</span> : low.element();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] count, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; count[mid]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果数据流中所有整数都在 0 到 100 范围内，如何优化算法？</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianBinarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = maxVal;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            count[num]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> target = (count[n - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> search = binarySearch(count, target, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (count[n - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> search;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> target == count[search] ? (<span class="hljs-number">0.5</span> * (<span class="hljs-number">2</span> * search + <span class="hljs-number">1</span>)) : search;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果数据流中所有整数都在 0 到 100 范围内，如何优化算法？</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianNormal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = maxVal;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            count[num]++;<br>            cnt++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> target = (cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum += count[i];<br>            <span class="hljs-keyword">if</span> (target &gt; sum - count[i] &amp;&amp; target &lt;= sum) &#123;<br>                <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> target == sum ? (<span class="hljs-number">0.5</span> * (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>)) : i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果数据流中 99% 的整数都在 0 到 100 范围内，如何优化算法？</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianBinarySearchPercent</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = maxVal;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= n) &#123;<br>                count[n - <span class="hljs-number">1</span>]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count[num]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> target = (count[n - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> search = binarySearch(count, target, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (count[n - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> search;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> target == count[search] ? (<span class="hljs-number">0.5</span> * (<span class="hljs-number">2</span> * search + <span class="hljs-number">1</span>)) : search;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成混合数据流 mixData</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n        mixData 中元素的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> percent1 mixData 中有 percent1 的元素位于 [0, maxVal-1]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> mixData</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] mixData(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">double</span> percent1) &#123;<br>        <span class="hljs-keyword">double</span> percent2 = <span class="hljs-number">1</span> - percent1;<br>        Random rand = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span>[] mix1 = rand.ints(<span class="hljs-number">0</span>, maxVal).limit((<span class="hljs-keyword">long</span>) (n * percent1)).toArray();<br>        <span class="hljs-keyword">int</span>[] mix2 = rand.ints(maxVal, <span class="hljs-number">5</span> * maxVal).limit((<span class="hljs-keyword">long</span>) (n * percent2)).toArray();<br>        <span class="hljs-keyword">int</span>[] mixData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        System.arraycopy(mix1, <span class="hljs-number">0</span>, mixData, <span class="hljs-number">0</span>, mix1.length);<br>        System.arraycopy(mix2, <span class="hljs-number">0</span>, mixData, mix1.length, mix2.length);<br>        <span class="hljs-keyword">return</span> mixData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> start;<br>        maxVal = <span class="hljs-number">101</span>;<br>        Random rand = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span>[] data = rand.ints(<span class="hljs-number">0</span>, maxVal).limit(<span class="hljs-number">100000000</span>).toArray();<br>        <span class="hljs-keyword">int</span>[] mix = mixData(<span class="hljs-number">100000</span>, <span class="hljs-number">0.99</span>);<br><br>        <span class="hljs-comment">// 混合数据流 mix</span><br>        start = System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;Find median by Heap:\t\t\t\t\t&quot;</span> + findMedianByHeap(mix));<br>        System.out.println(<span class="hljs-string">&quot;\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        start = System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;Find median by PriorityQueue:\t\t\t&quot;</span> + findMedianByPriorityQueue(mix));<br>        System.out.println(<span class="hljs-string">&quot;\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        start = System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;Find median by findMedianPercent:\t\t&quot;</span> + findMedianBinarySearchPercent(mix));<br>        System.out.println(<span class="hljs-string">&quot;\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms\n&quot;</span>);<br><br>        <span class="hljs-comment">// [0, 100] data</span><br>        start = System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;Find median by findMedianNormal:\t\t&quot;</span> + findMedianNormal(data));<br>        System.out.println(<span class="hljs-string">&quot;\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        start = System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;Find median by findMedianBinarySearch:\t&quot;</span> + findMedianBinarySearch(data));<br>        System.out.println(<span class="hljs-string">&quot;\tuse &quot;</span> + (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-5-Output"><a href="#1-2-5-Output" class="headerlink" title="1.2.5 Output"></a>1.2.5 Output</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Find median by Heap:<span class="hljs-number">51.0</span>use <span class="hljs-number">5184.6624</span> ms<br>Find median by PriorityQueue:<span class="hljs-number">51.0</span>use <span class="hljs-number">53.3883</span> ms<br>Find median by findMedianPercent:<span class="hljs-number">51.0</span>use <span class="hljs-number">2.1269</span> ms<br><br>Find median by findMedianNormal:<span class="hljs-number">50.0</span>use <span class="hljs-number">72.8294</span> ms<br>Find median by findMedianBinarySearch:<span class="hljs-number">50.0</span>use <span class="hljs-number">66.8815</span> ms<br></code></pre></td></tr></table></figure><h2 id="1-3-基数估计-Cardinality-Estimation"><a href="#1-3-基数估计-Cardinality-Estimation" class="headerlink" title="1.3 基数估计 Cardinality Estimation"></a>1.3 基数估计 Cardinality Estimation</h2><p>基数估计：估算不同元素的个数</p><h3 id="1-3-1-HyperLogLog"><a href="#1-3-1-HyperLogLog" class="headerlink" title="1.3.1 HyperLogLog"></a>1.3.1 HyperLogLog</h3><p><img src="https://e.im5i.com/2021/07/26/ok0FF.png" alt="HyperLogLog 算法描述"></p>]]></content>
    
    
    <categories>
      
      <category>大数据算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓄水池抽样算法 Reservoir Sampling</tag>
      
      <tag>数据流的中位数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第5章 Stream</title>
    <link href="/2021/06/03/Java/%E7%AC%AC5%E7%AB%A0%20%20Stream/"/>
    <url>/2021/06/03/Java/%E7%AC%AC5%E7%AB%A0%20%20Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="5-1-引入流"><a href="#5-1-引入流" class="headerlink" title="5.1 引入流"></a>5.1 引入流</h2><h3 id="5-1-1-流简介"><a href="#5-1-1-流简介" class="headerlink" title="5.1.1 流简介"></a>5.1.1 流简介</h3><p>Stream 以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。流可以看做是遍历数据集的高级迭代器，同时，流可以透明地实现并行（无需写任何多线程代码）</p><h4 id="1-流：从支持数据处理操作的数据源生成的元素序列"><a href="#1-流：从支持数据处理操作的数据源生成的元素序列" class="headerlink" title="1. 流：从支持数据处理操作的数据源生成的元素序列"></a>1. 流：从支持数据处理操作的数据源生成的元素序列</h4><ul><li>元素序列：与集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。集合是数据结构，所以它的主要目的是以特定的时间或空间复杂度存储和访问元素（如 <code>ArrayList、LinkedList</code>）。但流的目的在于表达计算，如 <code>filter、sorted、map</code> 等。<strong>集合面向数据，流面向计算</strong></li><li>数据源：流会使用一个提供数据的源，如集合、数组或 I/O 资源。 注意，由列表生成的流，其元素顺序与列表一致</li><li>数据处理操作：流的数据处理操作支持类似于数据库的操作，以及函数式编程语言中的常用操作，如 <code>filter、map、reduce、find、match、sort</code> 等。<strong>流操作可以顺序执行，也可并行执行</strong></li></ul><h4 id="2-流操作的两个重要特点"><a href="#2-流操作的两个重要特点" class="headerlink" title="2. 流操作的两个重要特点"></a>2. 流操作的两个重要特点</h4><ul><li>流水线：很多流操作本身会返回一个流，因此多个流操作可以链接起来，形成一个流水线。流水线的操作可以<br>看作对数据源进行数据库式查询</li><li>内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的</li></ul><h4 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h4><p>对数据源进行一系列流操作，返回一个结果列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dish</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span> </span>&#123;MEAT, FISH, OTHER&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> vegetarian;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Type type;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dish</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> vegetarian, <span class="hljs-keyword">int</span> calories, Type type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.vegetarian = vegetarian;<br>        <span class="hljs-keyword">this</span>.calories = calories;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vegetarian;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCalories</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> calories;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Dish&gt; menu = Arrays.asList(<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;pork&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">800</span>, Dish.Type.MEAT),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;beef&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">700</span>, Dish.Type.MEAT),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;chicken&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">400</span>, Dish.Type.MEAT),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;french fries&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">530</span>, Dish.Type.OTHER),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;rice&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">350</span>, Dish.Type.OTHER),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;season fruit&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">120</span>, Dish.Type.OTHER),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;pizza&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">550</span>, Dish.Type.OTHER),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;prawns&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">300</span>, Dish.Type.FISH),<br>                <span class="hljs-keyword">new</span> Dish(<span class="hljs-string">&quot;salmon&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">450</span>, Dish.Type.FISH));<br><br>        <span class="hljs-comment">// 只关注做什么，不关注具体实现</span><br>        List&lt;String&gt; highCaloricDish = menu.stream()<br>                .filter(d -&gt; d.getCalories() &gt; <span class="hljs-number">300</span>)<span class="hljs-comment">// 筛选</span><br>                .map(Dish::getName)<span class="hljs-comment">// 提取</span><br>                .limit(<span class="hljs-number">3</span>)<span class="hljs-comment">// 截断</span><br>                .collect(Collectors.toList());<span class="hljs-comment">// 终端操作：Stream -&gt; List</span><br><br>        System.out.println(highCaloricDish);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据源是菜单，它为流提供一个元素序列</li><li>对流进行一系列数据处理操作：<code>filter、map、limit、collect</code>。除了 <code>collect</code> 外，所有流操作都返回另一个流，因此它们可以被链接成一条流水线（查询）</li><li>最后，<code>collect</code> 执行流水线（调用 <code>collect</code> 之前，流水线中的方法调用都在排队等待），返回结果（<code>Stream</code> 转换为 <code>List</code>），并关闭流水线（流只能消费一次）</li></ul><h3 id="5-1-2-流与集合"><a href="#5-1-2-流与集合" class="headerlink" title="5.1.2 流与集合"></a>5.1.2 流与集合</h3><h4 id="1-流与集合的区别"><a href="#1-流与集合的区别" class="headerlink" title="1. 流与集合的区别"></a>1. 流与集合的区别</h4><ul><li><p>集合与流之间的一个区别就在于什么时候进行计算</p></li><li><p>集合是内存中的数据结构，它包含数据结构中目前所有的值。集合中的元素都必须先计算出来才能添加到集合中</p></li><li><p>流是在概念上固定的数据结构（不能添加或删除元素）。流中的元素是「按需计算」的，是一种「生产者-消费者」关系。从另一个角度来说，流像是一个「延迟创建」的集合，只有在消费者要求的时候才会计算值</p></li><li><p>集合（外部迭代）和流（内部迭代）的另一个关键区别在于遍历数据的方式</p></li></ul><h4 id="2-流只能遍历一次"><a href="#2-流只能遍历一次" class="headerlink" title="2. 流只能遍历一次"></a>2. 流只能遍历一次</h4><p>与迭代器类似，流只能遍历一次。流遍历完之后就被消费掉了，只能从数据源再获得一个新的流重新遍历一遍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; title = Arrays.asList(<span class="hljs-string">&quot;Java8&quot;</span>, <span class="hljs-string">&quot;In&quot;</span>, <span class="hljs-string">&quot;Action&quot;</span>);<br>Stream&lt;String&gt; s = title.stream();<br>s.forEach(System.out::println);<br>s.forEach(System.out::println);<span class="hljs-comment">// 流已被消费，不能再次操作</span><br></code></pre></td></tr></table></figure><h4 id="3-外部迭代与内部迭代"><a href="#3-外部迭代与内部迭代" class="headerlink" title="3. 外部迭代与内部迭代"></a>3. 外部迭代与内部迭代</h4><h5 id="集合：外部迭代"><a href="#集合：外部迭代" class="headerlink" title="集合：外部迭代"></a>集合：外部迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ---------- 用 for-each 循环外部迭代 ----------</span><br>List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span>(Dish d: menu) &#123;<br>    names.add(d.getName());<br>&#125;<br><br><span class="hljs-comment">// -------------- 用迭代器外部迭代 --------------</span><br>Iterator&lt;String&gt; iterator = menu.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    Dish d = iterator.next();<br>    names.add(d.getName());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="流：内部迭代"><a href="#流：内部迭代" class="headerlink" title="流：内部迭代"></a>流：内部迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = menu.stream()<br>        .map(Dish::getName)<br>        .collect(toList());    <span class="hljs-comment">// 开始执行流操作，没有迭代</span><br></code></pre></td></tr></table></figure><h3 id="5-1-3-流操作"><a href="#5-1-3-流操作" class="headerlink" title="5.1.3 流操作"></a>5.1.3 流操作</h3><h4 id="1-流的三个过程"><a href="#1-流的三个过程" class="headerlink" title="1. 流的三个过程"></a>1. 流的三个过程</h4><ul><li>一个数据源（如集合），执行一个查询</li><li>一个中间操作链，形成一条流水线</li><li>一个终端操作，执行流水线，并生成结果</li></ul><h4 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2. 中间操作"></a>2. 中间操作</h4><p>多个中间操作可以链接形成一条流水线，仅当流水线上触发一个终端操作，中间操作链才会延迟执行</p><table><thead><tr><th>中间操作</th><th>返回类型</th><th>操作参数</th><th>函数描述符</th></tr></thead><tbody><tr><td><code>filter</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>map</code></td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T, R&gt;</code></td><td><code>T -&gt; R</code></td></tr><tr><td><code>limit</code></td><td><code>Stream&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>sorted</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>(T, T) -&gt; int</code></td></tr><tr><td><code>distinct</code></td><td><code>Stream&lt;T&gt;</code></td><td></td><td></td></tr></tbody></table><p>打印流水线的中间过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = menu.stream()<br>        .filter(d -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;filtering\t&quot;</span> + d.getName());<br>            <span class="hljs-keyword">return</span> d.getCalories() &gt; <span class="hljs-number">300</span>;<br>        &#125;)<br>        .map(d -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;mapping\t&quot;</span> + d.getName());<br>            <span class="hljs-keyword">return</span> d.getName();<br>        &#125;)<br>        .limit(<span class="hljs-number">3</span>)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">filteringpork<br>mappingpork<br>filtering beef<br>mapping beef<br>filtering chicken<br>mapping chicken<br></code></pre></td></tr></table></figure><ul><li>这体现了流的延迟特性</li><li>尽管很多菜的热量都 &gt; 300 卡路里，但只选出了前 3 个</li><li>尽管 <code>filter</code> 和 <code>map</code> 是两个独立的操作，但它们合并到同一次遍历中，我们把这种技术称为「循环合并」</li></ul><h4 id="3-终端操作"><a href="#3-终端操作" class="headerlink" title="3. 终端操作"></a>3. 终端操作</h4><p>终端操作执行流水线的中间操作，并生成结果。其结果是任何不是流的值，如 <code>List、Integer、void</code></p><table><thead><tr><th>终端操作</th><th>返回类型</th><th>目的</th></tr></thead><tbody><tr><td><code>forEach</code></td><td><code>void</code></td><td>消费流中的每个元素并对其应用 Lambda 表达式</td></tr><tr><td><code>count</code></td><td><code>long</code></td><td>返回流中元素的个数</td></tr><tr><td><code>collect</code></td><td>集合</td><td>把流归约成一个集合</td></tr></tbody></table><h4 id="4-流操作总表"><a href="#4-流操作总表" class="headerlink" title="4. 流操作总表"></a>4. 流操作总表</h4><p><img src="https://s.im5i.com/2021/06/09/fdM8Y.png" alt="流操作总表"></p><h3 id="5-1-5-小结"><a href="#5-1-5-小结" class="headerlink" title="5.1.5 小结"></a>5.1.5 小结</h3><ul><li>流是 「从支持数据处理操作的源生成的一系列元素」</li><li>流利用内部迭代：迭代通过 <code>filter、map、sorted</code> 等操作被抽象掉</li><li>流操作有两类：中间操作、终端操作</li><li><code>filter、map</code> 等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果</li><li><code>forEach、count、collect</code> 等终端操作会返回一个非流的值，并处理流水线以返回结果</li><li>流中的元素是按需计算的</li></ul><h2 id="5-2-使用流"><a href="#5-2-使用流" class="headerlink" title="5.2 使用流"></a>5.2 使用流</h2><h3 id="5-2-1-筛选和切片"><a href="#5-2-1-筛选和切片" class="headerlink" title="5.2.1 筛选和切片"></a>5.2.1 筛选和切片</h3><h4 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; vegetarianMenu = menu.stream()<br>        .filter(Dish::isVegetarian)<br>        .collect(toList());<br></code></pre></td></tr></table></figure><h4 id="2-distinct"><a href="#2-distinct" class="headerlink" title="2. distinct"></a>2. distinct</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>numbers.stream()<br>       .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>       .distinct()<span class="hljs-comment">// 输出：2 4</span><br>       .forEach(System.out::println);<br></code></pre></td></tr></table></figure><h4 id="3-limit"><a href="#3-limit" class="headerlink" title="3. limit"></a>3. limit</h4><p><code>limit(n)</code> ：返回一个 ≤ n 个元素的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; dishes = menu.stream()<br>        .filter(d -&gt; d.getCalories() &gt; <span class="hljs-number">300</span>)<br>        .limit(<span class="hljs-number">3</span>)<span class="hljs-comment">// 如果是有序流，则最多返回前 n 个元素</span><br>        .collect(toList());<br></code></pre></td></tr></table></figure><ul><li>limit 方法也可以用在无序流上，例如源是一个 Set。此时，limit 的结果不会以任何顺序排列</li></ul><h4 id="4-skip"><a href="#4-skip" class="headerlink" title="4. skip"></a>4. skip</h4><p><code>skip(n)</code>：返回一个扔掉了前 n 个元素的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; dishes = menu.stream()<br>        .filter(d -&gt; d.getCalories() &gt; <span class="hljs-number">300</span>)<br>        .skip(<span class="hljs-number">2</span>)<br>        .collect(toList());<br></code></pre></td></tr></table></figure><h3 id="5-2-2-映射"><a href="#5-2-2-映射" class="headerlink" title="5.2.2 映射"></a>5.2.2 映射</h3><h4 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h4><p>返回每道菜名的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; dishNameLengths = menu.stream()<br>        .map(Dish::getName)<br>        .map(String::length)<br>        .collect(toList());<br>System.out.println(dishNameLengths);<span class="hljs-comment">// 输出：[4, 4, 7, 12, 4, 12, 5, 6, 6]</span><br></code></pre></td></tr></table></figure><p>返回一个单词列表中每个单词的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;Java 8&quot;</span>, <span class="hljs-string">&quot;Lambdas&quot;</span>, <span class="hljs-string">&quot;In&quot;</span>, <span class="hljs-string">&quot;Action&quot;</span>);<br>List&lt;Integer&gt; wordLengths = words.stream()<br>        .map(String::length)<br>        .collect(toList());<br>System.out.println(wordLengths);<span class="hljs-comment">// 输出：[6, 7, 2, 6]</span><br></code></pre></td></tr></table></figure><h4 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2. flatMap"></a>2. flatMap</h4><p>给定一个单词表，如何返回一个由单词表中各异的字符组成的列表？ 例如，给定 <code>[&quot;Hello&quot;, &quot;World&quot;]</code>，应返回 <code>[&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;, &quot;W&quot;, &quot;r&quot;, &quot;d&quot;]</code></p><h5 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);<br>List&lt;String&gt; distinctChar = words.stream()<br>        .map(w -&gt; w.split(<span class="hljs-string">&quot;&quot;</span>))<br>        .distinct()<br>        .collect(toList());<br></code></pre></td></tr></table></figure><ul><li>这个方法的问题在于：传递给 <code>map</code> 的 Lambda 表达式为每个单词返回了一个 <code>String[]</code>。因此， <code>map</code> 返回的流实际上是 <code>Stream&lt;String[]&gt;</code></li><li>而我们想要得到一个字符串流 <code>Stream&lt;String&gt;</code></li></ul><h5 id="使用-flatMap"><a href="#使用-flatMap" class="headerlink" title="使用 flatMap"></a>使用 flatMap</h5><p>使用 <code>flatMap(Arrays::stream)</code> 将 <code>Stream&lt;String[]&gt;</code> 中的每个字符流合并起来，扁平化为一个字符串流 <code>Stream&lt;String&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; uniqueCharacters = words.stream()<br>        .flatMap(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)))<span class="hljs-comment">// Stream&lt;String[]&gt; -&gt; Stream&lt;String&gt;</span><br>        .distinct()<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; uniqueCharacters = words.stream()<br>        .map(w -&gt; w.split(<span class="hljs-string">&quot;&quot;</span>))<span class="hljs-comment">// Stream&lt;String[]&gt;</span><br>        .flatMap(Arrays::stream)<span class="hljs-comment">// Stream&lt;String[]&gt; -&gt; Stream&lt;String&gt; --- flatMap(s -&gt; Arrays.tream(s))</span><br>        .distinct()<br>        .collect(Collectors.toList());<span class="hljs-comment">// Stream&lt;String&gt; -&gt; List&lt;String&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><p>（1）给定一个数字列表，如何返回一个由每个数的平方组成的列表？例如，给定 <code>[1, 2, 3, 4, 5]</code>，应返回 <code>[1, 4, 9, 16, 25]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>List&lt;Integer&gt; suqares = nums.stream()<br>        .map(n -&gt; n * n)<br>        .collect(Collectors.toList());<br>System.out.println(suqares);<span class="hljs-comment">// 输出：[1, 4, 9, 16, 25]</span><br></code></pre></td></tr></table></figure><p>（2）给定两个数字列表，如何返回所有的数对？例如，给定 <code>[1, 2, 3]</code>和 <code>[3, 4]</code>，应返回 <code>[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]</code>。为简单起见，可以用有两个元素的数组来代表数对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>List&lt;Integer&gt; nums2 = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>List&lt;<span class="hljs-keyword">int</span>[]&gt; pairs = nums1.stream()<br>        .flatMap(i -&gt; nums2.stream().map(j -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;))<br>        .collect(Collectors.toList());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : pairs) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : p) &#123;<br>        System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果使用两个 <code>map</code> 来迭代这两个列表，则会返回一个 <code>Stream&lt;Stream&lt;Integer[]&gt;&gt;</code></li><li>可以使用 <code>flatMap</code> 将 <code>Stream&lt;Stream&lt;Integer[]&gt;&gt;</code> 扁平化为 <code>Stream&lt;Integer[]&gt;</code></li></ul><p>（3）如何扩展前一个例子，只返回总和能被 3 整除的数对？例如 <code>[(2, 4), (3, 3)]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>List&lt;Integer&gt; nums2 = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>List&lt;<span class="hljs-keyword">int</span>[]&gt; pairs = nums1.stream()<br>        .flatMap(i -&gt; nums2.stream()<br>                 .filter(j -&gt; (i + j) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>                 .map(j -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="5-2-3-匹配和查找"><a href="#5-2-3-匹配和查找" class="headerlink" title="5.2.3 匹配和查找"></a>5.2.3 匹配和查找</h3><h4 id="1-匹配"><a href="#1-匹配" class="headerlink" title="1. 匹配"></a>1. 匹配</h4><h5 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(menu.stream()<br>        .anyMatch(d -&gt; d.getCalories() &lt; <span class="hljs-number">200</span>));<span class="hljs-comment">// 只要有一个 &lt; 200，就返回 true</span><br></code></pre></td></tr></table></figure><h5 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(menu.stream()<br>        .allMatch(d -&gt; d.getCalories() &lt; <span class="hljs-number">1000</span>));<span class="hljs-comment">// 所有都 &lt; 1000，才返回 true</span><br></code></pre></td></tr></table></figure><h5 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(menu.stream()<br>        .noneMatch(d -&gt; d.getCalories() &gt;= <span class="hljs-number">1000</span>));<span class="hljs-comment">// 所有都不 ≥ 1000（&lt; 1000），才返回 true</span><br></code></pre></td></tr></table></figure><h5 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h5><p>假设对一个用 <code>and</code> 连起来的布尔表达式求值，不管表达式多长，只要找到一个表达式为 <code>false</code>，那么整个表达式就为 <code>false</code></p><p>对于流而言，某些操作（如 <code>allMatch、anyMatch、noneMatch、findFirst、findAny</code>）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。</p><p>同样，<code>limit</code> 也是一个短路操作：只需创建一个给定大小的流，而不用处理流中所有的元素。limit 也可以将无限流变成有限流</p><h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h4><h5 id="Optional-lt-T-gt-容器类"><a href="#Optional-lt-T-gt-容器类" class="headerlink" title="Optional&lt;T&gt; 容器类"></a>Optional&lt;T&gt; 容器类</h5><p><code>Optional&lt;T&gt;</code> 容器类表示一个值 value 存在与否</p><table><thead><tr><th>方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>isPresent()</code></td><td><code>boolean</code></td><td>value 存在时返回 <code>true</code>，否则返回 <code>false</code></td></tr><tr><td><code>ifPresent(Consumer&lt;T&gt; block)</code></td><td><code>void</code></td><td>value 存在的时候执行给定的代码块。<code>Consumer&lt;T&gt;</code> 函数式接口接收一个 T 类型参数，返回 <code>void</code> 的 Lambda 表达式</td></tr><tr><td><code>get()</code></td><td><code>T</code></td><td>value 存在时返回 value，否则抛出一个 <code>NoSuchElement</code> 异常</td></tr><tr><td><code>T orElse(T other)</code></td><td><code>T</code></td><td>value 存在时返回 other，否则返回一个默认值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">menu.stream()<br>    .filter(Dish::isVegetarian)<br>    .findAny()<br>    .ifPresent(d -&gt; System.out.println(d.getName());<span class="hljs-comment">// value 存在时返回菜名</span><br></code></pre></td></tr></table></figure><h5 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Dish&gt; dish = menu.stream()<br>    .filter(Dish::isVegetarian)<br>    .findAny();<span class="hljs-comment">// 返回当前流中的任意元素</span><br></code></pre></td></tr></table></figure><ul><li><code>findAny</code> 可能什么元素都没找到。Java 8 引入了 <code>Optional&lt;T&gt;</code> 容器类，这样就不用返回众所周知容易出问题的 <code>null</code> 了</li></ul><h5 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br>Optional&lt;Integer&gt; firstSquareDivisibleByThree = nums.stream()<br>        .map(x -&gt; x * x)<br>        .filter(x -&gt; x % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>        .findFirst(); <span class="hljs-comment">// 输出：9</span><br></code></pre></td></tr></table></figure><ul><li>找到第一个元素在并行上限制更多。如果不关心返回的元素是哪个，请使用 <code>findAny</code>，因为它在使用并行流时限制较少</li></ul><h3 id="5-2-4-归约"><a href="#5-2-4-归约" class="headerlink" title="5.2.4 归约"></a>5.2.4 归约</h3><p><code>reduce</code>：将流<strong>「归约」</strong>成一个值</p><h4 id="1-sum"><a href="#1-sum" class="headerlink" title="1. sum"></a>1. sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Stream.iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>)<br>        .limit(<span class="hljs-number">10</span>)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = nums.stream().reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b);<span class="hljs-comment">// 从初始值 0 开始累加 nums 中的值</span><br><span class="hljs-keyword">int</span> sum = nums.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<span class="hljs-comment">// 方法引用</span><br></code></pre></td></tr></table></figure><p><code>reduce</code> 还有一个不接受初始值的重载，但是返回一个 <code>Optional</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; a + b));<br></code></pre></td></tr></table></figure><ul><li>为什么返回一个 <code>Optional&lt;Integer&gt;</code> ?</li><li>考虑流中没有任何元素时，因为没有初始值，所以 <code>reduce</code> 无法返回。有元素时，默认初始值为 0</li></ul><h4 id="2-max"><a href="#2-max" class="headerlink" title="2. max"></a>2. max</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; maxVal = numbers.stream().reduce((x, y) -&gt; (x &gt; y) ? x : y);<br>Optional&lt;Integer&gt; maxVal = numbers.stream().reduce(Integer::max);<br></code></pre></td></tr></table></figure><h4 id="3-count"><a href="#3-count" class="headerlink" title="3. count"></a>3. count</h4><p>使用 <code>map</code> 和 <code>reduce</code> 统计元素个数，与 MapReduce 中的 word counting 一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = menu.stream()<br>    .map(i -&gt; <span class="hljs-number">1</span>)<br>    .reduce(<span class="hljs-number">0</span>, Integer::sum);<br><br><span class="hljs-keyword">long</span> count2 = menu.stream().count();<br></code></pre></td></tr></table></figure><h3 id="5-2-5-Demo"><a href="#5-2-5-Demo" class="headerlink" title="5.2.5 Demo"></a>5.2.5 Demo</h3><h4 id="1-Need"><a href="#1-Need" class="headerlink" title="1. Need"></a>1. Need</h4><p>假如你是一个交易员，你需要得到以下八个查询结果</p><ol><li>找出 <u>2011 年</u>发生的<u>所有交易</u>，并按<u>交易额</u>排序（从高到低）</li><li>交易员都在哪些不同的<u>城市</u>工作过？</li><li>找出所有来自于剑桥的交易员，并按姓名字母顺序排序</li><li>找出所有来自<u>剑桥</u>的交易员，并按<u>姓名字母顺序</u>排序（只排序）</li><li>打印<u>所有交易员的姓名</u>，并按<u>姓名字母顺序</u>排序</li><li>有没有工作在<u>米兰</u>的交易员？</li><li>打印工作在<u>剑桥</u>的交易员的<u>所有交易额</u></li><li>所有交易中，<u>最高的交易额</u>是多少？</li><li>找到<u>交易额最小的交易</u></li></ol><h4 id="2-交易员：Trader"><a href="#2-交易员：Trader" class="headerlink" title="2. 交易员：Trader"></a>2. 交易员：Trader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trader</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String city;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trader</span><span class="hljs-params">(String name, String city)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.city = city;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n\t\tTrader &#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name = &#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, city = &#x27;&quot;</span> + city + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-交易：Transaction"><a href="#3-交易：Transaction" class="headerlink" title="3. 交易：Transaction"></a>3. 交易：Transaction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transaction</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Trader trader;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer year;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(Trader trader, Integer year, Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.trader = trader;<br>        <span class="hljs-keyword">this</span>.year = year;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Trader <span class="hljs-title">getTrader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> trader;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getYear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> year;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\nTransaction &#123;&quot;</span> +<br>                <span class="hljs-string">&quot;\n\ttrader = &quot;</span> + trader +<br>                <span class="hljs-string">&quot;,\n\tyear = &quot;</span> + year +<br>                <span class="hljs-string">&quot;,\n\tvalue = &quot;</span> + value +<br>                <span class="hljs-string">&quot;\n&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Trader raoul = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">&quot;Raoul&quot;</span>, <span class="hljs-string">&quot;Cambridge&quot;</span>);<br>        Trader mario = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">&quot;Mario&quot;</span>, <span class="hljs-string">&quot;Milan&quot;</span>);<br>        Trader alan = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">&quot;Alan&quot;</span>, <span class="hljs-string">&quot;Cambridge&quot;</span>);<br>        Trader brian = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">&quot;Brian&quot;</span>, <span class="hljs-string">&quot;Cambridge&quot;</span>);<br><br>        List&lt;Transaction&gt; trans = Arrays.asList(<br>                <span class="hljs-keyword">new</span> Transaction(brian, <span class="hljs-number">2011</span>, <span class="hljs-number">300</span>),<br>                <span class="hljs-keyword">new</span> Transaction(raoul, <span class="hljs-number">2012</span>, <span class="hljs-number">1000</span>),<br>                <span class="hljs-keyword">new</span> Transaction(raoul, <span class="hljs-number">2011</span>, <span class="hljs-number">400</span>),<br>                <span class="hljs-keyword">new</span> Transaction(mario, <span class="hljs-number">2012</span>, <span class="hljs-number">710</span>),<br>                <span class="hljs-keyword">new</span> Transaction(mario, <span class="hljs-number">2012</span>, <span class="hljs-number">700</span>),<br>                <span class="hljs-keyword">new</span> Transaction(alan, <span class="hljs-number">2012</span>, <span class="hljs-number">950</span>)<br>        );<br><br>        <span class="hljs-comment">// 找出 2011 年发生的所有交易，并按交易额排序（从高到低）</span><br>        List&lt;Transaction&gt; trans2011 = trans.stream()<br>                .filter(s -&gt; s.getYear() == <span class="hljs-number">2011</span>)<br>                .sorted(Comparator.comparing(Transaction::getValue).reversed())<br>                .collect(Collectors.toList());<br><br>        System.out.println(<span class="hljs-string">&quot;\n【1】 找出 2011 年发生的所有交易，并按交易额排序（从高到低）\n&quot;</span> + trans2011);<br><br>        <span class="hljs-comment">// 交易员都在哪些不同的城市工作过？</span><br>        List&lt;String&gt; city = trans.stream()<br>                .map(s -&gt; s.getTrader().getCity())<br>                .distinct()<br>                .collect(Collectors.toList());<br><br>        Set&lt;String&gt; city2 = trans.stream()<br>                .map(s -&gt; s.getTrader().getCity())<br>                .collect(Collectors.toSet());<br><br>        System.out.println(<span class="hljs-string">&quot;\n【2】 交易员都在哪些不同的城市工作过？\n&quot;</span> + city);<br><br>        <span class="hljs-comment">// 找出所有来自于剑桥的交易员，并按姓名字母顺序排序</span><br>        List&lt;Trader&gt; traderCambridge = trans.stream()<br>                .map(Transaction::getTrader)<br>                .filter(r -&gt; <span class="hljs-string">&quot;Cambridge&quot;</span>.equals(r.getCity()))<br>                .sorted(Comparator.comparing(Trader::getName))<br>                .collect(Collectors.toList());<br><br>        System.out.println(<span class="hljs-string">&quot;\n【3】 找出所有来自于剑桥的交易员，并按姓名字母顺序排序\n&quot;</span> + traderCambridge);<br><br>        <span class="hljs-comment">// 打印所有交易员的姓名，并按姓名字母顺序排序</span><br>        String nameTrader = trans.stream()<br>                .map(s -&gt; s.getTrader().getCity())<br>                .distinct()<br>                .sorted(Comparator.reverseOrder())<br>                .reduce(<span class="hljs-string">&quot;&quot;</span>, (n1, n2) -&gt; n1 + n2 + <span class="hljs-string">&quot;, &quot;</span>);<br><br>        String nameTrader2 = trans.stream()<br>                .map(s -&gt; s.getTrader().getCity())<br>                .distinct()<br>                .sorted(Comparator.reverseOrder())<br>                .collect(Collectors.joining(<span class="hljs-string">&quot;, &quot;</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;\n【4】 打印所有交易员的姓名，并按字母顺序排序\n&quot;</span> + nameTrader);<br><br>        <span class="hljs-comment">// 有没有工作在米兰的交易员?</span><br>        <span class="hljs-keyword">boolean</span> hasMilanTrader = trans.stream()<br>                .anyMatch(s -&gt; <span class="hljs-string">&quot;Milan&quot;</span>.equals(s.getTrader().getCity()));<br><br>        System.out.println(<span class="hljs-string">&quot;\n【5】 有没有工作在米兰的交易员?\n&quot;</span> + hasMilanTrader);<br><br>        <span class="hljs-comment">// 打印工作在剑桥的交易员的所有交易额</span><br>        System.out.println(<span class="hljs-string">&quot;\n【6】 打印工作在剑桥的交易员的所有交易额&quot;</span>);<br>        <br>        trans.stream()<br>                .filter(s -&gt; <span class="hljs-string">&quot;Cambridge&quot;</span>.equals(s.getTrader().getCity()))<br>                .map(Transaction::getValue)<br>                .forEach(System.out::println);<br>        <br>        <span class="hljs-comment">// 所有交易中，最高的交易额是多少？</span><br>        Optional&lt;Integer&gt; maxVal = trans.stream()<br>                .map(Transaction::getValue)<br>                .reduce(Integer::max);<br><br>        System.out.println(<span class="hljs-string">&quot;\n【7】 所有交易中，最高的交易额是多少？\n&quot;</span> + maxVal.get());<br><br>        <span class="hljs-comment">// 找出交易额最小的交易</span><br>        Optional&lt;Transaction&gt; minValTrans = trans.stream()<br>                .filter(s -&gt; s.getValue().equals(trans.stream()<br>                        .map(Transaction::getValue)<br>                        .reduce(Integer::min)<br>                        .get()<br>                ))<br>                .findAny();<br><br>        Optional&lt;Transaction&gt; minValTrans2 = trans.stream()<br>                .reduce((t1, t2) -&gt; t1.getValue() &lt; t2.getValue() ? t1 : t2);<br><br>        Optional&lt;Transaction&gt; minValTrans3 = trans.stream()<br>                .min(Comparator.comparing(Transaction::getValue));<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n【8】 找出交易额最小的交易&quot;</span> + minValTrans3.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Output"><a href="#4-Output" class="headerlink" title="4. Output"></a>4. Output</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">【<span class="hljs-number">1</span>】 找出 <span class="hljs-number">2011</span> 年发生的所有交易，并按交易额排序（从高到低）<br>[<br>Transaction &#123;<br>trader = <br>Trader &#123;name = <span class="hljs-string">&#x27;Raoul&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;,<br>year = <span class="hljs-number">2011</span>,<br>value = <span class="hljs-number">400</span><br>&#125;, <br>Transaction &#123;<br>trader = <br>Trader &#123;name = <span class="hljs-string">&#x27;Brian&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;,<br>year = <span class="hljs-number">2011</span>,<br>value = <span class="hljs-number">300</span><br>&#125;]<br><br>【<span class="hljs-number">2</span>】 交易员都在哪些不同的城市工作过？<br>[Cambridge, Milan]<br><br>【<span class="hljs-number">3</span>】 找出所有来自于剑桥的交易员，并按姓名字母顺序排序<br>[<br>Trader &#123;name = <span class="hljs-string">&#x27;Alan&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;, <br>Trader &#123;name = <span class="hljs-string">&#x27;Brian&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;, <br>Trader &#123;name = <span class="hljs-string">&#x27;Raoul&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;, <br>Trader &#123;name = <span class="hljs-string">&#x27;Raoul&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;]<br><br>【<span class="hljs-number">4</span>】 打印所有交易员的姓名，并按字母顺序排序<br>Milan, Cambridge<br><br>【<span class="hljs-number">5</span>】 有没有工作在米兰的交易员?<br><span class="hljs-keyword">true</span><br><br>【<span class="hljs-number">6</span>】 打印工作在剑桥的交易员的所有交易额<br><span class="hljs-number">300</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">400</span><br><span class="hljs-number">950</span><br><br>【<span class="hljs-number">7</span>】 所有交易中，最高的交易额是多少？<br><span class="hljs-number">1000</span><br><br>【<span class="hljs-number">8</span>】 找出交易额最小的交易<br>Transaction &#123;<br>trader = <br>Trader &#123;name = <span class="hljs-string">&#x27;Brian&#x27;</span>, city = <span class="hljs-string">&#x27;Cambridge&#x27;</span>&#125;,<br>year = <span class="hljs-number">2011</span>,<br>value = <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-6-数值流"><a href="#5-2-6-数值流" class="headerlink" title="5.2.6 数值流"></a>5.2.6 数值流</h3><p><code>map</code> + <code>reduce</code>：返回总热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> calories = menu.stream()<br>        .map(Dish::getCalories)<br>        .reduce(<span class="hljs-number">0</span>, Integer::sum);<span class="hljs-comment">// Stream&lt;T&gt; 没有定义 sum 方法</span><br></code></pre></td></tr></table></figure><ul><li>这段代码的问题在于，它有一个暗含的装箱成本。每个 <code>Integer</code>都必须拆箱成一个原始类型，再进行求和</li><li><code>map</code> 生成一个 <code>Stream&lt;T&gt;</code>，能不能直接调用 <code>sum</code> 方法求和？显然不能，因为类型参数 <code>T</code> 不一定是支持 <code>sum</code> 方法的数值类型，因此 <code>Stream&lt;T&gt;</code> 没有定义 <code>sum</code> 方法</li></ul><h4 id="1-原始类型数值流"><a href="#1-原始类型数值流" class="headerlink" title="1. 原始类型数值流"></a>1. 原始类型数值流</h4><p>Java 8 引入了三个<strong>「原始类型数值流（特化流）」</strong>避免了「暗含的装箱成本」：<code>IntStream、DoubleStream、LongStream</code>，分别将流中的元素特化为 <code>int、long、double</code></p><p>特化的原因不在于流的复杂性，而是装箱造成的复杂性</p><h5 id="mapToInt"><a href="#mapToInt" class="headerlink" title="mapToInt"></a>mapToInt</h5><p><code>mapToInt</code>：对象流 -&gt; 数值流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> calories = menu.stream()<br>        .mapToInt(Dish::getCalories)<br>        .sum();<span class="hljs-comment">// 如果数值流 IntStream 是空的，sum 默认返回 0。数值流还有其他方法：max、min、average</span><br></code></pre></td></tr></table></figure><h5 id="boxed"><a href="#boxed" class="headerlink" title="boxed"></a>boxed</h5><p><code>boxed</code>：数值流 -&gt; 对象流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);<br>Stream&lt;Integer&gt; stream = intStream.boxed();<br></code></pre></td></tr></table></figure><h5 id="OptionalInt"><a href="#OptionalInt" class="headerlink" title="OptionalInt"></a>OptionalInt</h5><p><code>OptionalInt</code>：如果数值流中没有最大值，显示定义一个默认最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">OptionalInt maxCalories = menu.stream()<br>        .mapToInt(Dish::getCalories)<br>        .max();<br><br><span class="hljs-keyword">int</span> maxVal = maxCalories.orElse(<span class="hljs-number">1</span>);<span class="hljs-comment">// 如果没有最大值，默认最大值为 1</span><br></code></pre></td></tr></table></figure><h4 id="2-数值范围"><a href="#2-数值范围" class="headerlink" title="2. 数值范围"></a>2. 数值范围</h4><h5 id="IntStream-range"><a href="#IntStream-range" class="headerlink" title="IntStream.range"></a>IntStream.range</h5><p><code>IntStream.range(1, n)</code>：生成 一个<code>[1, n)</code> 的数值流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream evenNumbers = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>.filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<span class="hljs-comment">// [1, 100) 的偶数数值流</span><br><br><span class="hljs-keyword">int</span> evenCnt = evenNumbers.count();<span class="hljs-comment">// 49 个</span><br></code></pre></td></tr></table></figure><h5 id="IntStream-rangeClosed"><a href="#IntStream-rangeClosed" class="headerlink" title="IntStream.rangeClosed"></a>IntStream.rangeClosed</h5><p><code>IntStream.rangeClosed(1, n)</code>：生成一个 <code>[1, n]</code> 的数值流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream evenNumbers = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>.filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<span class="hljs-comment">// [1, 100] 的偶数数值流</span><br><br><span class="hljs-keyword">int</span> evenCnt = evenNumbers.count();<span class="hljs-comment">// 50 个</span><br></code></pre></td></tr></table></figure><h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><p>生成一个 <code>[0, 100)</code> 的随机整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Random rand = <span class="hljs-keyword">new</span> Random();<span class="hljs-comment">// 也可以指定 seed，如 new Random(10)</span><br><span class="hljs-keyword">int</span> r = rand.nextInt(<span class="hljs-number">100</span>);<span class="hljs-comment">// [0, 100) 的随机数，不能指定 left</span><br></code></pre></td></tr></table></figure><p>生成一个包含 10 个 <code>[0, 100)</code> 的随机整数的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] numsInt = rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>        .limit(<span class="hljs-number">10</span>)<br>        .toArrays();<span class="hljs-comment">// ints 方法返回一个 IntStream</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; listInt = rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>    .limit(<span class="hljs-number">10</span>)<br>    .boxed()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="3-数值流应用：勾股"><a href="#3-数值流应用：勾股" class="headerlink" title="3. 数值流应用：勾股"></a>3. 数值流应用：勾股</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;<span class="hljs-keyword">int</span>[]&gt; triples = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<span class="hljs-comment">// IntStream</span><br>        .boxed()<span class="hljs-comment">// IntStream -&gt; Stream&lt;Integer&gt;</span><br>        .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="hljs-number">100</span>)<span class="hljs-comment">// Stream&lt;Stream&lt;int[]&gt;&gt; -&gt; Stream&lt;int[]&gt;</span><br>.filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 判断 a * a + b * b 是否为整数</span><br>.mapToObj(b -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a, b, (<span class="hljs-keyword">int</span>) Math.sqrt(a * a + b * b)&#125;));<span class="hljs-comment">// IntStream -&gt; Stream&lt;int[]&gt;</span><br><br>triples.limit(<span class="hljs-number">5</span>).forEach(t -&gt; System.out.println(t[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;, &quot;</span> + t[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;, &quot;</span> + t[<span class="hljs-number">2</span>]));<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span><br><span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span><br><span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span><br><span class="hljs-number">7</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span><br><span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="5-2-7-生成流"><a href="#5-2-7-生成流" class="headerlink" title="5.2.7 生成流"></a>5.2.7 生成流</h3><h4 id="1-Stream-of"><a href="#1-Stream-of" class="headerlink" title="1. Stream.of"></a>1. Stream.of</h4><p><code>Stream.of</code>：由值生成流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;Java 8 &quot;</span>, <span class="hljs-string">&quot;Lambdas &quot;</span>, <span class="hljs-string">&quot;In &quot;</span>, <span class="hljs-string">&quot;Action&quot;</span>);<br>stream.map(String::toUpperCase).forEach(System.out::println);<br><br>Stream&lt;String&gt; emptyStream = Stream.empty();<span class="hljs-comment">// 使用 empty 得到一个空流</span><br></code></pre></td></tr></table></figure><h4 id="2-Arrays-stream"><a href="#2-Arrays-stream" class="headerlink" title="2. Arrays.stream"></a>2. Arrays.stream</h4><p><code>Arrays.stream</code>：由数组生成流</p><h5 id="int-gt-IntStream"><a href="#int-gt-IntStream" class="headerlink" title="int[] -&gt; IntStream"></a>int[] -&gt; IntStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;;<br><br><span class="hljs-comment">// Arrays.stream 有返回数值流 IntStream 的重载方法，可以直接调用 sum 方法</span><br><span class="hljs-keyword">int</span> sum = Arrays.stream(numbers).sum();<br></code></pre></td></tr></table></figure><h5 id="T-gt-Stream-lt-T-gt"><a href="#T-gt-Stream-lt-T-gt" class="headerlink" title="T[] -&gt; Stream&lt;T&gt;"></a>T[] -&gt; Stream&lt;T&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Stream&lt;Stream&lt;String&gt;&gt; -&gt; Stream&lt;String&gt;</span><br>List&lt;String&gt; str = Stream.of(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<span class="hljs-comment">// Stream&lt;String&gt;</span><br>        .flatMap(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)))<span class="hljs-comment">// String -&gt; String[] -&gt; Stream&lt;String&gt;</span><br>        .distinct()<br>        .collect(Collectors.toList());<br><br>System.out.println(str);<span class="hljs-comment">// 输出：[H, e, l, o, W, r, d]</span><br></code></pre></td></tr></table></figure><h4 id="3-Files-lines"><a href="#3-Files-lines" class="headerlink" title="3. Files.lines"></a>3. Files.lines</h4><p><code>Files.lines</code>：由文件生成流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="hljs-string">&quot;Data.txt&quot;</span>), Charset.defaultCharset())) &#123;<br>    List&lt;String&gt; flatMapLine = lines.flatMap(l -&gt; Arrays.stream(l.split(<span class="hljs-string">&quot; &quot;</span>)))<br>        .collect(Collectors.toList());<br>    System.out.println(flatMapLine);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Caught IOException&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Data.txt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello World<br>Hadoop MapReduce<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Hello, World, Hadoop, MapReduce]<br></code></pre></td></tr></table></figure><h4 id="4-无限流"><a href="#4-无限流" class="headerlink" title="4. 无限流"></a>4. 无限流</h4><h5 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h5><p>从 0 开始，生成 10 个偶数流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">2</span>)<br>    .limit(<span class="hljs-number">10</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>斐波纳契元组序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;<span class="hljs-keyword">int</span>[]&gt; fib = Stream.iterate(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;t[<span class="hljs-number">1</span>], t[<span class="hljs-number">0</span>] + t[<span class="hljs-number">1</span>]&#125;);<br><br>fib.limit(<span class="hljs-number">5</span>).forEach(t -&gt; System.out.println(t[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;, &quot;</span> + t[<span class="hljs-number">1</span>]));<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-number">3</span>, <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h5 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h5><p>与 <code>iterate</code> 方法类似，<code>generate</code> 方法也可以按需生成一个无限流。但 <code>generate</code> 不是依次对每个新生成的值应用函数的。如下方的例子：生成 5 个 <code>[0, 1]</code> 的随机 <code>double</code> 值</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Stream</span><span class="hljs-selector-class">.generate</span>(<span class="hljs-attribute">Math</span>::random)<span class="hljs-selector-class">.limit</span>(<span class="hljs-number">5</span>)<span class="hljs-selector-class">.forEach</span>(System.<span class="hljs-attribute">out</span>::println);<br></code></pre></td></tr></table></figure><ul><li>这里的供应源（指向 <code>Math.random</code> 的方法引用）是无状态的：它不会在任何地方记录任何值，以备以后计算使用</li><li>但供应源不一定是无状态的。可以创建存储状态的供应源，它可以修改状态，并在为流生成下一个值时使用</li><li>使用 <code>iterate</code> 的方法则是纯粹不变的：它没有修改现有状态，但在每次迭代时会创建新的元组。应始终采用「不变」的方法</li></ul><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0.0682192789949102</span><br><span class="hljs-number">0.5240741555145046</span><br><span class="hljs-number">0.532085234961741</span><br><span class="hljs-number">0.49163117456949623</span><br><span class="hljs-number">0.8569667696843923</span><br></code></pre></td></tr></table></figure><h2 id="5-3-收集器-Collectors"><a href="#5-3-收集器-Collectors" class="headerlink" title="5.3 收集器 Collectors"></a>5.3 收集器 Collectors</h2><h3 id="5-3-1-归约"><a href="#5-3-1-归约" class="headerlink" title="5.3.1 归约"></a>5.3.1 归约</h3><p><code>Collectors.counting</code>：统计菜的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> dishCnt = menu.stream().collect(Collectors.counting());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> dishCnt2 = menu.stream().mapToInt(d -&gt; <span class="hljs-number">1</span>).count();<br><span class="hljs-keyword">long</span> dishCnt3 = menu.stream().count();<br><span class="hljs-keyword">long</span> dishCnt4 = menu.size();<br></code></pre></td></tr></table></figure><h4 id="1-maxBy"><a href="#1-maxBy" class="headerlink" title="1. maxBy"></a>1. maxBy</h4><p><code>Collectors.maxBy</code>：返回最高热量的 <code>Optional&lt;Dish&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Dish&gt; calCmp = Comparator.comparingInt(Dish::getCalories);<br>Optional&lt;Dish&gt; maxCalDish = menu.stream().collect(Collectors.maxBy(calCmp));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Dish&gt; maxCalDish2 = menu.stream().max(CaloriesCmp);<br>Optional&lt;Dish&gt; maxCalDish3 = menu.stream().<br>    reduce((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2);<br></code></pre></td></tr></table></figure><h4 id="2-summingInt"><a href="#2-summingInt" class="headerlink" title="2. summingInt"></a>2. summingInt</h4><p><code>Collectors.summingInt</code>：返回总热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> totalCal = menu.stream()<br>.collect(Collectors.summingInt(Dish::getCalories));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> totalCal2 = menu.stream().mapToInt(Dish::getCalories).sum();<br><span class="hljs-keyword">int</span> totalCal3 = menu.stream()<br>.map(Dish::getCalories)<br>.reduce(Integer::sum)<br>.orElse(<span class="hljs-number">100</span>);<span class="hljs-comment">// 若为空流，返回 100</span><br>OptionalInt totalCal4 = menu.stream()<br>        .mapToInt(Dish::getCalories)<br>        .reduce(Integer::sum);<br></code></pre></td></tr></table></figure><h4 id="3-averageingInt"><a href="#3-averageingInt" class="headerlink" title="3. averageingInt"></a>3. averageingInt</h4><p><code>Collectors.averageingInt</code>：返回平均热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> avgCal = menu.stream()<br>    .collect(Collectors.averageingInt(Dish::getCalories));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> avgCal2 = (<span class="hljs-keyword">double</span>) totalCal / dishCnt;<br></code></pre></td></tr></table></figure><h4 id="4-summarizingInt"><a href="#4-summarizingInt" class="headerlink" title="4. summarizingInt"></a>4. summarizingInt</h4><p><code>Collectors.summarizingInt</code> ：返回统计量 <code>IntSummaryStatistics</code>，通过 <code>getter</code> 方法获得统计值：<code>count、sum、average、max、min</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">IntSummaryStatistics menuStatistics = menu.stream()<br>   .collect(Collectors.summarizingInt(Dish::getCalories));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(menuStatistics.getCount());<br>System.out.println(menuStatistics.getSum());<br>System.out.println(menuStatistics.getAverage());<br>System.out.println(menuStatistics.getMax());<br>System.out.println(menuStatistics.getMin());<br></code></pre></td></tr></table></figure><h4 id="5-joining"><a href="#5-joining" class="headerlink" title="5. joining"></a>5. joining</h4><p><code>Collectors.joining</code>：连接所有菜名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining(<span class="hljs-string">&quot;, &quot;</span>));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; menuNull = Arrays.asList();<span class="hljs-comment">// 空流</span><br><br><span class="hljs-comment">// 空流:【不能使用 get】</span><br>String shortMenu2 = menuNull.stream().map(Dish::getName)<br>.collect(Collectors.reducing((s1, s2) -&gt; s1 + <span class="hljs-string">&quot;, &quot;</span> + s2)).get();<br><br><span class="hljs-comment">// 空流: 返回 null</span><br>String shortMenu2 = menuNull.stream().map(Dish::getName)<br>.collect(Collectors.reducing((s1, s2) -&gt; s1 + <span class="hljs-string">&quot;, &quot;</span> + s2)).orElse(<span class="hljs-string">&quot;null&quot;</span>);<br><br><span class="hljs-comment">// 空流: 返回作为累加器初值的 &quot;null&quot;</span><br>String shortMenu3 = menuNull.stream()<br>.collect(Collectors.reducing(<span class="hljs-string">&quot;null&quot;</span>, Dish::getName, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot;, &quot;</span> + s2));<br></code></pre></td></tr></table></figure><h4 id="6-reducing"><a href="#6-reducing" class="headerlink" title="6. reducing"></a>6. reducing</h4><p> <code>Collectors.reducing</code>：返回总热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> totalCal = menu.stream()<br>    .collect(Collectors.reducing(<span class="hljs-number">0</span>, Dish::getCalories, Integer::sum));<span class="hljs-comment">// 若为空流，返回 0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若为空流，都返回 0</span><br><span class="hljs-keyword">int</span> totalCal2 = menu.stream().mapToInt(Dish::getCalories).sum();<br><span class="hljs-keyword">int</span> totalCal3 = menu.stream().map(Dish::getCalories).reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p> <code>Collectors.reducing</code>：返回最高热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> maxCal = menu.stream()<br>    .collect(Collectors.reducing(<span class="hljs-number">100</span>, Dish::getCalories, Integer::max));<span class="hljs-comment">// 若为空流，返回 100</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> maxCal2 = menu.stream().map(Dish::getCalories).reduce(<span class="hljs-number">100</span>, Integer::max);<span class="hljs-comment">// 若为空流，返回 100</span><br></code></pre></td></tr></table></figure><h3 id="5-3-2-分组"><a href="#5-3-2-分组" class="headerlink" title="5.3.2 分组"></a>5.3.2 分组</h3><h4 id="1-groupingBy"><a href="#1-groupingBy" class="headerlink" title="1. groupingBy"></a>1. groupingBy</h4><h5 id="Map-lt-Type-List-lt-Dish-gt-gt"><a href="#Map-lt-Type-List-lt-Dish-gt-gt" class="headerlink" title="Map&lt;Type, List&lt;Dish&gt;&gt;"></a>Map&lt;Type, List&lt;Dish&gt;&gt;</h5><p><code>Collectors.groupingBy</code>：按 <code>Type </code> 分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span> </span>&#123;MEAT, FISH, OTHER&#125;<br><br>Map&lt;Type, List&lt;Dish&gt;&gt; typeMap = menu.stream()<br>    .collect(Collectors.groupingBy(Dish::getType));<br></code></pre></td></tr></table></figure><ul><li><code>f</code> 是分类函数，单参数 <code>groupingBy(f)</code>，实际上是 <code>groupingBy(f, toList())</code> 的简便写法</li></ul><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=[french fries, rice, season fruit, pizza],<br> FISH=[prawns, salmon],<br> MEAT=[pork, beef, chicken]&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Level-List-lt-Dish-gt-gt"><a href="#Map-lt-Level-List-lt-Dish-gt-gt" class="headerlink" title="Map&lt;Level, List&lt;Dish&gt;&gt;"></a>Map&lt;Level, List&lt;Dish&gt;&gt;</h5><p><code>Collectors.groupingBy</code>：按 <code>Level</code> 分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Level, List&lt;Dish&gt;&gt; levelMap = menu.stream().collect(<br>    Collectors.groupingBy(<br>        d -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">400</span>) &#123;<br>                <span class="hljs-keyword">return</span> Level.DIET;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">700</span>) &#123;<br>                <span class="hljs-keyword">return</span> Level.NORMAL;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> Level.FAT;<br>            &#125;<br>        &#125;<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;FAT=[pork],<br> DIET=[chicken, rice, season fruit, prawns],<br> NORMAL=[beef, french fries, pizza, salmon]&#125;<br></code></pre></td></tr></table></figure><h4 id="2-多级分组"><a href="#2-多级分组" class="headerlink" title="2. 多级分组"></a>2. 多级分组</h4><h5 id="Map-lt-Type-Map-lt-Level-List-lt-Dish-gt-gt-gt"><a href="#Map-lt-Type-Map-lt-Level-List-lt-Dish-gt-gt-gt" class="headerlink" title="Map&lt;Type, Map&lt;Level, List&lt;Dish&gt;&gt;&gt;"></a>Map&lt;Type, Map&lt;Level, List&lt;Dish&gt;&gt;&gt;</h5><p>先按 <code>Type</code> 分组，再按 <code>Level</code> 分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Map&lt;Level, List&lt;Dish&gt;&gt;&gt; typeLevelMap = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.groupingBy(<br>            d -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">400</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.DIET;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">700</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.NORMAL;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Level.FAT;<br>                &#125;<br>            &#125;<br>        )<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=&#123;DIET=[rice, season fruit], NORMAL=[french fries, pizza]&#125;,<br> FISH=&#123;DIET=[prawns], NORMAL=[salmon]&#125;,<br> MEAT=&#123;FAT=[pork], DIET=[chicken], NORMAL=[beef]&#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Type-Long-gt"><a href="#Map-lt-Type-Long-gt" class="headerlink" title="Map&lt;Type, Long&gt;"></a>Map&lt;Type, Long&gt;</h5><p>先按 <code>Type</code> 分组，再统计每种 <code>Type</code> 中菜的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Long&gt; typeCnt = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.counting()<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=<span class="hljs-number">4</span>, FISH=<span class="hljs-number">2</span>, MEAT=<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Type-Optional-lt-Dish-gt-gt"><a href="#Map-lt-Type-Optional-lt-Dish-gt-gt" class="headerlink" title="Map&lt;Type, Optional&lt;Dish&gt;&gt;"></a>Map&lt;Type, Optional&lt;Dish&gt;&gt;</h5><p>先按 <code>Type</code> 分组，再返回每种 <code>Type</code> 中热量最高的 <code>Optional&lt;Dish&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Optional&lt;Dish&gt;&gt; maxDishByType = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.maxBy(Comparator.comparingInt(Dish::getCalories))<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=Optional[pizza], FISH=Optional[salmon], MEAT=Optional[pork]&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Type-Dish-gt"><a href="#Map-lt-Type-Dish-gt" class="headerlink" title="Map&lt;Type, Dish&gt;"></a>Map&lt;Type, Dish&gt;</h5><p>先按 <code>Type</code> 分组，再返回每种 <code>Type</code> 中热量最高的 <code>Dish</code></p><p><code>collectingAndThen</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Dish&gt; maxDishByType2 = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.collectingAndThen(<br>            Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)),<br>            Optional::get<br>        )<br>    )<br>);<br></code></pre></td></tr></table></figure><p><code>Collectors.toMap</code></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-keyword">Type</span>, Dish&gt; maxDishByType3 = menu.stream().collect(<br>    Collectors.toMap(<br>        Dish<span class="hljs-type">::getType</span>,<br>        Function.identity(),<br>        BinaryOperator.maxBy(Comparator.comparingInt(Dish<span class="hljs-type">::getCalories</span>))<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=pizza, FISH=salmon, MEAT=pork&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Type-Integer-gt"><a href="#Map-lt-Type-Integer-gt" class="headerlink" title="Map&lt;Type, Integer&gt;"></a>Map&lt;Type, Integer&gt;</h5><p>先按 <code>Type</code> 分组，再返回每种 <code>Type</code> 中的总热量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Integer&gt; totalCalByType = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.summingInt(Dish::getCalories)<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;OTHER=<span class="hljs-number">1550</span>, FISH=<span class="hljs-number">750</span>, MEAT=<span class="hljs-number">1900</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Type-Set-lt-Level-gt-gt"><a href="#Map-lt-Type-Set-lt-Level-gt-gt" class="headerlink" title="Map&lt;Type, Set&lt;Level&gt;&gt;"></a>Map&lt;Type, Set&lt;Level&gt;&gt;</h5><p><code>Collectors.mapping</code>：先按 <code>Type</code> 分组，再统计每种 <code>Type</code> 中有哪些 <code>Level</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Set&lt;Level&gt;&gt; levelByType = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.mapping(<br>            d -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">400</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.DIET;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">700</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.NORMAL;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Level.FAT;<br>                &#125;<br>            &#125;,<br>            Collectors.toSet()<br>        )<br>    )<br>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Type, Set&lt;Level&gt;&gt; levelByType2 = menu.stream().collect(<br>    Collectors.groupingBy(<br>        Dish::getType,<br>        Collectors.mapping(<br>            d -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">400</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.DIET;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.getCalories() &lt;= <span class="hljs-number">700</span>) &#123;<br>                    <span class="hljs-keyword">return</span> Level.NORMAL;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Level.FAT;<br>                &#125;<br>            &#125;,<br>            Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>)<br>        )<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;FISH=[NORMAL, DIET], MEAT=[NORMAL, FAT, DIET], OTHER=[NORMAL, DIET]&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-分区"><a href="#5-3-3-分区" class="headerlink" title="5.3.3 分区"></a>5.3.3 分区</h3><p>分区是分组的特殊情况：分区函数是一个谓词（返回一个布尔值的函数）</p><h4 id="1-partitioningBy"><a href="#1-partitioningBy" class="headerlink" title="1. partitioningBy"></a>1. partitioningBy</h4><h5 id="Map-lt-Boolean-List-lt-Dish-gt-gt"><a href="#Map-lt-Boolean-List-lt-Dish-gt-gt" class="headerlink" title="Map&lt;Boolean, List&lt;Dish&gt;&gt;"></a>Map&lt;Boolean, List&lt;Dish&gt;&gt;</h5><p>按 <code>isVegetarian</code> 分区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Dish&gt;&gt; isVegPartition = menu.stream()<br>    .collect(Collectors.partitioningBy(Dish::isVegetarian));<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-keyword">false</span>=[pork, beef, chicken, prawns, salmon],<br> <span class="hljs-keyword">true</span>=[french fries, rice, season fruit, pizza]&#125;<br></code></pre></td></tr></table></figure><h4 id="2-多级分区"><a href="#2-多级分区" class="headerlink" title="2. 多级分区"></a>2. 多级分区</h4><h5 id="Map-lt-Boolean-Map-lt-Type-List-lt-Dish-gt-gt-gt"><a href="#Map-lt-Boolean-Map-lt-Type-List-lt-Dish-gt-gt-gt" class="headerlink" title="Map&lt;Boolean, Map&lt;Type, List&lt;Dish&gt;&gt;&gt;"></a>Map&lt;Boolean, Map&lt;Type, List&lt;Dish&gt;&gt;&gt;</h5><p>先按 <code>isVegetarian</code> 分区，再按 <code>Type</code> 分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, Map&lt;Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = menu.stream().collect(<br>    Collectors.partitioningBy(<br>        Dish::isVegetarian,<br>        Collectors.groupingBy(Dish::getType)<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-keyword">false</span>=&#123;FISH=[prawns, salmon], MEAT=[pork, beef, chicken]&#125;, <br> <span class="hljs-keyword">true</span>=&#123;OTHER=[french fries, rice, season fruit, pizza]&#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Boolean-Dish-gt"><a href="#Map-lt-Boolean-Dish-gt" class="headerlink" title="Map&lt;Boolean, Dish&gt;"></a>Map&lt;Boolean, Dish&gt;</h5><p>先按 <code>isVegetarian</code> 分区，再返回每种 <code>isVegetarian</code> 中热量最高的 <code>Dish</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, Dish&gt; maxCalPartitionByVeg = menu.stream().collect(<br>    Collectors.partitioningBy(<br>        Dish::isVegetarian,<br>        Collectors.collectingAndThen(<br>            Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)),<br>            Optional::get<br>        )<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-keyword">false</span>=pork, <span class="hljs-keyword">true</span>=pizza&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Boolean-Long-gt"><a href="#Map-lt-Boolean-Long-gt" class="headerlink" title="Map&lt;Boolean, Long&gt;"></a>Map&lt;Boolean, Long&gt;</h5><p>先按 <code>isVegetarian</code> 分区，再统计每种 <code>isVegetarian</code> 中菜的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, Long&gt; countByVeg = menu.stream().collect(<br>    Collectors.partitioningBy(<br>        Dish::isVegetarian,<br>        Collectors.counting()<br>    )<br>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-keyword">false</span>=<span class="hljs-number">5</span>, <span class="hljs-keyword">true</span>=<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-按质数和非质数分区"><a href="#3-按质数和非质数分区" class="headerlink" title="3. 按质数和非质数分区"></a>3. 按质数和非质数分区</h4><h5 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = (<span class="hljs-keyword">int</span>) Math.sqrt(n);<br>    <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">2</span>, m).noneMatch(i -&gt; n % i == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map-lt-Boolean-List-lt-Integer-gt-gt"><a href="#Map-lt-Boolean-List-lt-Integer-gt-gt" class="headerlink" title="Map&lt;Boolean, List&lt;Integer&gt;&gt;"></a>Map&lt;Boolean, List&lt;Integer&gt;&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes = IntStream.rangeClosed(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>)<br>    .boxed()<br>    .collect(Collectors.partitioningBy(Dish::isPrime));<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-keyword">false</span>=[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>], <span class="hljs-keyword">true</span>=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]&#125;<br></code></pre></td></tr></table></figure><h2 id="5-4-收集器接口-Collector"><a href="#5-4-收集器接口-Collector" class="headerlink" title="5.4 收集器接口 Collector"></a>5.4 收集器接口 Collector</h2><p><code>Collector</code> 接口包含了一系列方法，为实现具体的归约操作（即收集器）提供了范本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br>    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code>：流中待收集元素的类型</li><li><code>A</code>：累加器的类型。累加器用于在收集过程中累积中间结果</li><li><code>R</code>：最终归约操作得到的结果容器的类型。最终结果不一定是容器，这里用结果容器代指最终结果</li></ul><h3 id="5-4-1-Collector-的接口方法"><a href="#5-4-1-Collector-的接口方法" class="headerlink" title="5.4.1 Collector 的接口方法"></a>5.4.1 Collector 的接口方法</h3><h4 id="1-supplier：建立新的累加器"><a href="#1-supplier：建立新的累加器" class="headerlink" title="1. supplier：建立新的累加器"></a>1. supplier：建立新的累加器</h4><p><code> Supplier&lt;A&gt;</code>：创建一个空的累加器实例 <code>A</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;<br>    <span class="hljs-keyword">return</span> ArrayList::<span class="hljs-keyword">new</span>;<span class="hljs-comment">// return () -&gt; new ArraysList&lt;T&gt;();</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-accumulator：将元素添加到累加器"><a href="#2-accumulator：将元素添加到累加器" class="headerlink" title="2. accumulator：将元素添加到累加器"></a>2. accumulator：将元素添加到累加器</h4><p><code>BiConsumer&lt;A, T&gt;</code>：将元素 <code>T</code> 添加到累加器 <code>A</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;<br>    <span class="hljs-keyword">return</span> List::add;<span class="hljs-comment">// return (list, item) -&gt; list.add(item)</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-combiner：合并两个累加器"><a href="#3-combiner：合并两个累加器" class="headerlink" title="3. combiner：合并两个累加器"></a>3. combiner：合并两个累加器</h4><p><code>BinaryOperator&lt;A&gt;</code>：合并两个累加器。<code>combiner</code> 方法仅用于并行规约</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;<br>    <span class="hljs-keyword">return</span> (list1, list2) -&gt; &#123;<br>        list1.addAll(list2);<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-finisher：将累加器转换为结果容器"><a href="#4-finisher：将累加器转换为结果容器" class="headerlink" title="4. finisher：将累加器转换为结果容器"></a>4. finisher：将累加器转换为结果容器</h4><p><code>Function&lt;A, R&gt;</code>：将累加器<code>A</code> 转换为结果容器 <code>R</code>。若无需转换，可以使用恒等函数 <code>Function.identity</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;<br><span class="hljs-keyword">return</span> Function.identity();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-characteristics：收集器是否可以并行归约"><a href="#5-characteristics：收集器是否可以并行归约" class="headerlink" title="5. characteristics：收集器是否可以并行归约"></a>5. characteristics：收集器是否可以并行归约</h4><p><code>Set&lt;Characteristics&gt;</code>：<code>Characteristics</code> 是一个包含三个标志的枚举，这三个标志定义了收集器的部分行为</p><ul><li><code>UNORDERED</code>：表明归约结果不受流中元素的遍历和累积顺序的影响。如果收集器没有标为 <code>UNORDERED</code>，那它仅在用于无序数据源时才可以并行归约</li><li><code>CONCURRENT</code>：表明 <code>accumulator</code> 方法可以从多个线程同时调用，且该收集器可以并行归约流</li><li><code>IDENTITY_FINISH</code>：表明 <code>finisher</code> 方法返回的是一个恒等函数 <code>Function.identity</code> ，可以跳过。此时，将累加器 <code>A</code> 不加检查地转换为结果容器 <code>R</code> 是安全的</li></ul><h3 id="5-4-2-自定义收集器-ToListCollector"><a href="#5-4-2-自定义收集器-ToListCollector" class="headerlink" title="5.4.2 自定义收集器 ToListCollector"></a>5.4.2 自定义收集器 ToListCollector</h3><p>用自定义收集器 <code>ToListCollector</code> 代替收集器方法 <code>Collectors.toList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToListCollector</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;<br>        <span class="hljs-comment">// 创建集合操作的起始点</span><br>        <span class="hljs-keyword">return</span> ArrayList::<span class="hljs-keyword">new</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;<br>        <span class="hljs-comment">// 累积遍历过的项目，原位修改累加器</span><br>        <span class="hljs-keyword">return</span> List::add;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;<br>        <span class="hljs-comment">// 恒等函数</span><br>        <span class="hljs-keyword">return</span> Function.identity();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;<br>        <span class="hljs-comment">// 将第二个累加器的内容追加到第一个累加器后面</span><br>        <span class="hljs-keyword">return</span> (list1, list2) -&gt; &#123;<br>            list1.addAll(list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 是 IDENTITY_FINISH：因为用来累积流中元素的 List 已经是最终结果，无需进转换</span><br><span class="hljs-comment">         * 不是 UNORDERED ：因为用在有序流上的时候，我们希望顺序保存在结果 List 中</span><br><span class="hljs-comment">         * 是 CONCURRENT 的：因为不是 UNORDERED，所以仅当数据源无序时才会并行归约</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> Collections.unmodifiableSet(<br>                EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.CONCURRENT)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ToListCollector</code> 和 <code>Collectors.toList</code> 的区别： <code>Collectors.toList</code> 是一个工厂方法，而 <code>ToListCollector</code> 必须 <code>new</code> 出实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; dishes = menuStream.collect(<span class="hljs-keyword">new</span> ToListCollector&lt;Dish&gt;());<br>List&lt;Dish&gt; dishes = menuStream.collect(toList());<br></code></pre></td></tr></table></figure><h3 id="5-4-3-无需实现-Collector"><a href="#5-4-3-无需实现-Collector" class="headerlink" title="5.4.3 无需实现 Collector"></a>5.4.3 无需实现 Collector</h3><p>一个重载的 <code>collect</code> 方法包含三个参数：<code>supplier、accumulator、combiner</code>，可以得到相同的结果而无需实现 <code>Collector</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Dish&gt; dishes = menuStream.collect(<br>    ArrayList::<span class="hljs-keyword">new</span>,<span class="hljs-comment">// 供应源</span><br>    List::add,<span class="hljs-comment">// 累加器</span><br>    List::addAll<span class="hljs-comment">// 组合器</span><br>);<br></code></pre></td></tr></table></figure><ul><li>该方法针对的是一个 <code>IDENTITY_FINISH、CONCURRENT</code> 但并非 <code>UNORDERED</code> 的收集器</li></ul><h3 id="5-4-4-自定义收集器-PrimeCollector"><a href="#5-4-4-自定义收集器-PrimeCollector" class="headerlink" title="5.4.4 自定义收集器 PrimeCollector"></a>5.4.4 自定义收集器 PrimeCollector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeCollector</span> <span class="hljs-keyword">implements</span></span><br><span class="hljs-class">    <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Map</span>&lt;<span class="hljs-title">Boolean</span>, <span class="hljs-title">List</span>&lt;<span class="hljs-title">Integer</span>&gt;&gt;, <span class="hljs-title">Map</span>&lt;<span class="hljs-title">Boolean</span>, <span class="hljs-title">List</span>&lt;<span class="hljs-title">Integer</span>&gt;&gt;&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier() &#123;<br>        <span class="hljs-keyword">return</span> () -&gt; <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>) &#123;&#123;<br>            put(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>            put(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        &#125;&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BiConsumer&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Integer&gt; accumulator() &#123;<br>        <span class="hljs-keyword">return</span> (acc, n) -&gt; acc.get(isPrime(acc.get(<span class="hljs-keyword">true</span>), n)).add(n);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner() &#123;<br>        <span class="hljs-comment">// 实际上这个收集器不能并行使用，因为该算法本身是顺序的，因此永远不会调用 combiner 方法</span><br>        <span class="hljs-keyword">return</span> (map1, map2) -&gt; &#123;<br>            map1.get(<span class="hljs-keyword">true</span>).addAll(map2.get(<span class="hljs-keyword">true</span>));<br>            map1.get(<span class="hljs-keyword">false</span>).addAll(map2.get(<span class="hljs-keyword">false</span>));<br>            <span class="hljs-keyword">return</span> map1;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() &#123;<br>        <span class="hljs-keyword">return</span> Function.identity();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;A&gt; <span class="hljs-function">List&lt;A&gt; <span class="hljs-title">takeWhile</span><span class="hljs-params">(List&lt;A&gt; primeList, Predicate&lt;A&gt; p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (A prime : primeList) &#123;<br>            <span class="hljs-keyword">if</span> (!p.test(prime)) &#123;<br>                <span class="hljs-keyword">return</span> primeList.subList(<span class="hljs-number">0</span>, i);<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primeList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> nRoot = (<span class="hljs-keyword">int</span>) Math.sqrt(n);<br>        <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">2</span>, nRoot).noneMatch(p -&gt; n % p == <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(List&lt;Integer&gt; primeList, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 优化：若 n 不能被 ≤ nRoot 的所有质数整除，则为质数</span><br>        <span class="hljs-keyword">int</span> nRoot = (<span class="hljs-keyword">int</span>) Math.sqrt(n);<br>        <span class="hljs-keyword">return</span> takeWhile(primeList, i -&gt; i &lt;= nRoot).stream().noneMatch(p -&gt; n % p == <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">2</span>, n)<br>                .boxed()<br>                .collect(Collectors.partitioningBy(p -&gt; isPrime(p)));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithPrimeCollector(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">2</span>, n)<br>                .boxed()<br>                .collect(<span class="hljs-keyword">new</span> PrimeCollector());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector2(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> IntStream.rangeClosed(<span class="hljs-number">2</span>, n).boxed()<br>                .collect(<br>                        () -&gt; <span class="hljs-keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;(<span class="hljs-number">2</span>) &#123;&#123;<br>                            put(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>                            put(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>                        &#125;&#125;,<br>                        (acc, i) -&gt; &#123;<br>                            acc.get(isPrime(acc.get(<span class="hljs-keyword">true</span>), i)).add(i);<br>                        &#125;,<br>                        (map1, map2) -&gt; &#123;<br>                            map1.get(<span class="hljs-keyword">true</span>).addAll(map2.get(<span class="hljs-keyword">true</span>));<br>                            map1.get(<span class="hljs-keyword">false</span>).addAll(map2.get(<span class="hljs-keyword">false</span>));<br>                        &#125;<br>                );<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-comment">// 单位：ns</span><br>        Map&lt;Boolean, List&lt;Integer&gt;&gt; primeList = partitionPrimesWithPrimeCollector(<span class="hljs-number">1_000_000</span>);<br>        <span class="hljs-keyword">long</span> duration = (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span>;<br>        System.out.println(<span class="hljs-string">&quot;partitionPrimesWithPrimeCollector:\t&quot;</span> + duration + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        <span class="hljs-keyword">long</span> start2 = System.nanoTime();<br>        Map&lt;Boolean, List&lt;Integer&gt;&gt; primeList2 = partitionPrimes(<span class="hljs-number">1_000_000</span>);<br>        <span class="hljs-keyword">long</span> duration2 = (System.nanoTime() - start2) / <span class="hljs-number">1_000_000</span>;<br>        System.out.println(<span class="hljs-string">&quot;partitionPrimes:\t&quot;</span> + duration2 + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Output">partitionPrimesWithPrimeCollector:455 ms(优化后更快是因为 isPrime 的优化，而非使用了 PrimeCollector)<br>partitionPrimes:719 ms<br></code></pre></td></tr></table></figure><h2 id="5-5-并行数据处理与性能"><a href="#5-5-并行数据处理与性能" class="headerlink" title="5.5 并行数据处理与性能"></a>5.5 并行数据处理与性能</h2><h3 id="5-5-1-并行流"><a href="#5-5-1-并行流" class="headerlink" title="5.5.1 并行流"></a>5.5.1 并行流</h3><p>并行流：一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</p><p>并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价可能很大，因此，需保证在内核中并行执行的时间比在内核之间传输数据的时间长</p><h4 id="1-将顺序流转换为并行流"><a href="#1-将顺序流转换为并行流" class="headerlink" title="1. 将顺序流转换为并行流"></a>1. 将顺序流转换为并行流</h4><p><code>paralle</code>：将顺序流转换为并行流；<code>sequential</code>：将并行流转换为顺序流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">parallelSum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Stream.iterate(<span class="hljs-number">1L</span>, i -&gt; i + <span class="hljs-number">1</span>)<br>        .limit(n)<br>        .parallel()<br>        .reduce(<span class="hljs-number">0L</span>, Long::sum);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>iterate</code> 很难分割成能够独立执行的小块，因为每次应用这个函数都要依赖前一次应用的结果</li><li><code>iterate</code> 生成的是装箱的对象，必须拆箱成数字才能求和</li><li>因此，使用 <code>iterate</code> 处理并行流使性能变得很差</li></ul><h4 id="2-LongStream-rangeClosed"><a href="#2-LongStream-rangeClosed" class="headerlink" title="2. LongStream.rangeClosed"></a>2. LongStream.rangeClosed</h4><p><code>LongStream.rangeClosed</code> 方法与 <code>iterate</code> 相比有两个优点</p><ul><li><code>LongStream.rangeClosed</code> 直接产生原始类型 <code>long </code>，没有装箱拆箱的开销</li><li><code>LongStream.rangeClosed</code> 指定数字范围，很容易拆分为独立的小块</li></ul><h4 id="3-避免共享可变状态"><a href="#3-避免共享可变状态" class="headerlink" title="3. 避免共享可变状态"></a>3. 避免共享可变状态</h4><p>错用并行流而产生错误的首要原因，就是使用的算法改变了某些共享状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Accumulator</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;<br><br>    Accumulator() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span> </span>&#123;<br>        total += value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>        Accumulator.total = <span class="hljs-number">0</span>;<br>        LongStream.rangeClosed(<span class="hljs-number">1</span>, n).parallel().forEach(Accumulator::add);<br>        <span class="hljs-keyword">return</span> Accumulator.total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(sum(<span class="hljs-number">10_000_000L</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13822622038838</span><br><span class="hljs-number">8021521601507</span><br><span class="hljs-number">8276687061799</span><br><span class="hljs-number">8532980499941</span><br><span class="hljs-number">8063439043898</span><br></code></pre></td></tr></table></figure><ul><li>正确答案：50000005000000。显然，每次计算的结果不仅不同，而且都是错误的</li><li>原因在于，多个线程可以同时执行 <code>total += value</code>，而这条语句并不是原子操作。因此，共享可变状态影响了并行计算</li></ul><h4 id="4-使用并行流的建议"><a href="#4-使用并行流的建议" class="headerlink" title="4. 使用并行流的建议"></a>4. 使用并行流的建议</h4><ul><li>测量。把顺序流转成并行流轻而易举，但却不一定是好事。并行流并不总是比顺序流快。此外，并行流有时候会和你的直觉不一致，所以在考虑选择顺序流还是并行流时，第一个也是最重要的建议就是用适当的基准来测量其性能</li><li>留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8 中有数值流（<code>IntStream、LongStream、DoubleStream</code>）来避免这种操作，但凡有可能都应该用这些流</li><li>有些操作本身在并行流上的性能就比顺序流差。特别是 <code>limit、findFirst</code> 等依赖元素顺序的操作，它们在并行流上执行的代价非常大。例如，<code>findAny</code> 比 <code>findFirst</code> 性能好，因为它不一定要按顺序来执行。可以使用 <code>unordered</code> 方法来把有序流变成无序流。例如，如果你需要流中的 <code>n</code> 个元素而不是前 <code>n</code> 个的话，对无序并行流调用 <code>limit</code> 可能会比单个有序流（比如数据源是一个List）更高效</li><li>考虑流的操作流水线的总计算成本。设 $N$ 是要处理的元素总数，$Q$ 是一个元素通过流水线的大致处理成本，则 $N*Q$ 就是这个对成本的一个粗略的定性估计。$Q$ 较高就意味着使用并行流时性能好的可能性比较大</li><li>对于少量数据，并行流不是一个好的选择。并行处理少量数据的好处抵不上并行化造成的额外开销</li><li>考虑流背后的数据结构是否易于分解。例如，<code>ArrayList</code> 的拆分效率比 <code>LinkedList</code>高得多，因为前者用不着遍历就可以平均拆分，而后者必须遍历。另外，用 <code>range</code> 方法创建的原始类型流也可以快速分解。最后，可以实现 <code>Spliterator</code> 来掌控分解过程</li><li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个 <code>SIZED</code> 流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。</li><li>考虑终端操作中合并操作的代价。例如，<code>Collector</code> 中的 <code>combiner</code> 方法。如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价可能会超出通过并行流得到的性能提升</li></ul><h4 id="5-流的数据源和可分解性"><a href="#5-流的数据源和可分解性" class="headerlink" title="5. 流的数据源和可分解性"></a>5. 流的数据源和可分解性</h4><table><thead><tr><th>源</th><th>可分解性</th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>极佳</td></tr><tr><td><code>LinkedList</code></td><td>差</td></tr><tr><td><code>IntStream.range</code></td><td>极佳</td></tr><tr><td><code>Stream.iterate</code></td><td>差</td></tr><tr><td><code>HashSet</code></td><td>好</td></tr><tr><td><code>TreeSet</code></td><td>好</td></tr></tbody></table><h3 id="5-5-2-分支-合并框架"><a href="#5-5-2-分支-合并框架" class="headerlink" title="5.5.2 分支/合并框架"></a>5.5.2 分支/合并框架</h3><p>分支/合并框架：以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果</p><p>它是 <code>ExecutorService</code> 接口的一个实现，它把子任务分配给线程池 <code>ForkJoinPool</code> 中的工作线程</p><h4 id="1-RecursiveTask"><a href="#1-RecursiveTask" class="headerlink" title="1. RecursiveTask"></a>1. RecursiveTask</h4><p><code>RecursiveTask&lt;R&gt;</code> 的唯一抽象方法 <code>compute</code>：将任务拆分成子任务，以及无法再拆分或不方便再拆分时，生成单个子任务结果。这个方法的实现类似于下面的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (任务足够小或不可分) &#123;<br>    顺序计算该任务;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    将任务分成两个子任务;<br>    递归调用本方法，拆分每个子任务，等待所有子任务完成;<br>    合并每个子任务的结果;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinSumCalculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] nums;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> THRESHOLD = <span class="hljs-number">10_000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinSumCalculator</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.nums = nums;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinSumCalculator</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(nums, <span class="hljs-number">0</span>, nums.length);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = end - start;<br>        <span class="hljs-keyword">if</span> (len &lt;= THRESHOLD) &#123;<br>            <span class="hljs-keyword">return</span> computeSequentially();<br>        &#125;<br><br>        ForkJoinSumCalculator leftTask = <span class="hljs-keyword">new</span> ForkJoinSumCalculator(nums, start, start + len / <span class="hljs-number">2</span>);<br>        leftTask.fork();<span class="hljs-comment">// 利用另一个 ForkJoinPool 线程异步执行新创建的子任务</span><br>        ForkJoinSumCalculator rightTask = <span class="hljs-keyword">new</span> ForkJoinSumCalculator(nums, start + len / <span class="hljs-number">2</span>, end);<br>        Long rightRes = rightTask.compute();<span class="hljs-comment">// 同步执行第二个子任务，有可能允许进一步递归划分</span><br>        Long leftRes = leftTask.join();<span class="hljs-comment">// 读取第一个子任务的结果，如果尚未完成就等待</span><br><br>        <span class="hljs-keyword">return</span> leftRes + rightRes;<br>    &#125;<br><br>    <span class="hljs-comment">// 在子任务不再可分时计算结果的简单算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">computeSequentially</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; end; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">forkJoinSum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span>[] nums = LongStream.rangeClosed(<span class="hljs-number">1</span>, n).toArray();<br>        ForkJoinTask&lt;Long&gt; task = <span class="hljs-keyword">new</span> ForkJoinSumCalculator(nums);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForkJoinPool().invoke(task);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(forkJoinSum(<span class="hljs-number">10_000_000</span>));<span class="hljs-comment">// 输出：17091674486562432</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用分支-合并框架的建议"><a href="#2-使用分支-合并框架的建议" class="headerlink" title="2. 使用分支/合并框架的建议"></a>2. 使用分支/合并框架的建议</h4><ul><li>对一个任务调用 <code>join</code> 方法会阻塞调用方，直到该任务结束。因此，有必要在两个子任务的计算都开始之后再调用它。否则，会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动</li><li>不应在 <code>RecursiveTask</code> 内部使用 <code>ForkJoinPool</code> 的 <code>invoke</code> 方法。相反，你应该始终直接调用 <code>compute、fork</code> 方法，只有顺序代码才应该用 <code>invoke</code>来启动并行计算</li><li>对子任务调用 <code>fork</code> 方法可以把它排进 <code>ForkJoinPool</code>。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用 <code>compute</code> 低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销</li><li>与并行流一样，你不应认为在多核处理器上使用分支/合并框架就比顺序计算快</li></ul><h4 id="3-工作窃取"><a href="#3-工作窃取" class="headerlink" title="3. 工作窃取"></a>3. 工作窃取</h4><p>理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的 CPU 内核都同样繁忙。实际中，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是因为磁盘访问慢，或是需要和外部服务协调执行</p><p>分支/合并框架使用<strong>「工作窃取」</strong>算法来解决这个问题，工作窃取算法用于在池中的工作线程之间重新分配和平衡任务</p><ul><li><p>在实际应用中，任务平均分配到 <code>ForkJoinPool</code> 中的所有线程上</p></li><li><p>每个线程都维护一个双向队列保存分配给它的任务，每完成一个任务，就会从队头上取出下一个任务开始执行</p></li><li><p>当某个线程完成了分配给它的所有任务时，即它的队列已经空了，而其他的线程还很忙。此时，这个线程随机挑选了一个其他线程，从它的队尾上「偷走」一个任务。这个过程一直继续下去，直到所有任务都执行完毕，即所有队列都清空</p></li><li><p>这就是为什么要划成许多小任务而不是少数几个大任务，这有助于更好地在工作线程之间平衡负载</p></li></ul><h3 id="5-5-3-可分迭代器-Spliterator"><a href="#5-5-3-可分迭代器-Spliterator" class="headerlink" title="5.5.3 可分迭代器 Spliterator"></a>5.5.3 可分迭代器 Spliterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br>    <span class="hljs-function">Spliterator&lt;T&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">estimateSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>tryAdvance</code> ：类似于普通的 <code>Iterator</code>，按顺序访问 <code>Spliterator</code> 中的元素，若还有其他元素要遍历，则返回 <code>true</code></li><li><code>trySpli</code>：专为 <code>Spliterator</code> 而接口设计，把一些元素划分给第二个 <code>Spliterator</code>（由该方法返回），以实现并行处理</li><li><code>estimateSize</code> ：估计待遍历的元素个数，即使不那么准确，也能快速估算出一个值，有助于均匀拆分</li><li><code>characteristics</code>：返回 <code>Spliterator</code> 特性集的编码</li></ul><h4 id="1-拆分过程"><a href="#1-拆分过程" class="headerlink" title="1. 拆分过程"></a>1. 拆分过程</h4><p>将 Stream 拆分成多个部分的算法是一个递归过程。第一步：对第一个 <code>Spliterator</code> 调用 <code>trySplit</code>，生成第二个 <code>Spliterator</code>。第二步：对这两个 <code>Spliterator</code> 调用 <code>trysplit</code>，总共有四个 <code>Spliterator</code>。不断对 <code>Spliterator</code> 调用 <code>trySplit</code> 直到返回 <code>null</code>，表明不能再分割。</p><p>这个拆分过程也受 <code>Spliterator</code> 本身的特性影响，而特性是通过 <code>characteristics</code> 方法声明的</p><h4 id="2-Spliterator-特性集"><a href="#2-Spliterator-特性集" class="headerlink" title="2. Spliterator 特性集"></a>2. Spliterator 特性集</h4><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td><code>ORDERED</code></td><td>元素有既定的顺序（如 <code>List</code>），因此 <code>Spliterator</code> 在遍历和划分时也会遵循这一顺序</td></tr><tr><td><code>ORDERED</code></td><td>对于任意一对遍历过的元素 <code>x、y</code>，<code>x.equals(y)</code> 返回 <code>false</code></td></tr><tr><td><code>SORTED</code></td><td>遍历的元素按照一个预定义的顺序排序</td></tr><tr><td><code>SIZED</code></td><td><code>Spliterator</code> 由一个已知大小的源建立（如 <code>Set</code>），因此 <code>estimatedSize</code> 返回的是准确值</td></tr><tr><td><code>NONNULL</code></td><td>保证遍历的元素不会为 <code>null</code></td></tr><tr><td><code>IMMUTABLE</code></td><td><code>Spliterator</code> 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</td></tr><tr><td><code>CONCURRENT</code></td><td><code>Spliterator</code> 的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td><code>SUBSIZED</code></td><td><code>Spliterator</code> 和所有从它拆分出来的 <code>Spliterator</code> 都是 <code>SIZED</code></td></tr></tbody></table><h4 id="3-实现-Spliterator"><a href="#3-实现-Spliterator" class="headerlink" title="3. 实现 Spliterator"></a>3. 实现 Spliterator</h4><h5 id="（1）字数统计：迭代"><a href="#（1）字数统计：迭代" class="headerlink" title="（1）字数统计：迭代"></a>（1）字数统计：迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countWordsIteratively</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> lastSpace = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (Character.isWhitespace(c)) &#123;<br>            lastSpace = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastSpace) &#123;<br>            cnt++;<br>            lastSpace = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）字数统计：流"><a href="#（2）字数统计：流" class="headerlink" title="（2）字数统计：流"></a>（2）字数统计：流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> counter;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> lastSpace;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordCounter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> counter, <span class="hljs-keyword">boolean</span> lastSpace)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.counter = counter;<br>        <span class="hljs-keyword">this</span>.lastSpace = lastSpace;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WordCounter <span class="hljs-title">accumulator</span><span class="hljs-params">(Character c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Character.isWhitespace(c)) &#123;<br>            <span class="hljs-keyword">return</span> !lastSpace ? <span class="hljs-keyword">new</span> WordCounter(counter, <span class="hljs-keyword">true</span>) : <span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> lastSpace ? <span class="hljs-keyword">new</span> WordCounter(counter + <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>) : <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WordCounter <span class="hljs-title">combiner</span><span class="hljs-params">(WordCounter wordCounter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCounter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countWords</span><span class="hljs-params">(Stream&lt;Character&gt; stream)</span> </span>&#123;<br>        WordCounter wordCounter = stream.reduce(<br>            <span class="hljs-keyword">new</span> WordCounter(<span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>),<br>            WordCounter::accumulator,<br>            WordCounter::combiner);<br>        <span class="hljs-keyword">return</span> wordCounter.getCounter();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String str =<br>            <span class="hljs-string">&quot; Nel mezzo  del cammin di nostra vita &quot;</span> +<br>            <span class="hljs-string">&quot;mi ritrovai in una selva oscura&quot;</span> +<br>            <span class="hljs-string">&quot; ché la dritta via era smarrita &quot;</span>;<br>        <span class="hljs-comment">// 迭代</span><br>        System.out.println(countWordsIteratively(str));<span class="hljs-comment">// 输出：19</span><br><br>        <span class="hljs-comment">// 流</span><br>        Stream&lt;Character&gt; stream = IntStream.range(<span class="hljs-number">0</span>, str.length()).mapToObj(str::charAt);<br>        System.out.println(countWords(stream));<br><br>        <span class="hljs-comment">// 并行流</span><br>        Spliterator&lt;Character&gt; spliterator = <span class="hljs-keyword">new</span> WordCounterSpliterator(str);<br>        Stream&lt;Character&gt; streamParallel = StreamSupport.stream(spliterator, <span class="hljs-keyword">true</span>);<br>        System.out.println(countWords(streamParallel));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>accumulate</code>：定义了如何更改 <code>WordCounter</code> 的状态，更确切地说，是用哪个状态来建立新的 <code>WordCounter</code>，因为这个类是不可变的。每次遍历到 Stream 中的一个新的 <code>Character</code> 时，都会调用 <code>accumulate</code> 方法</li><li><code>combine</code> ：对作用于 <code>Character</code> 流的两个不同子部分的两个 <code>WordCounter</code> 的部分结果进行汇总，即把两个 <code>WordCounter</code> 内部的计数器加起来</li></ul><h5 id="（3）字数统计：并行流"><a href="#（3）字数统计：并行流" class="headerlink" title="（3）字数统计：并行流"></a>（3）字数统计：并行流</h5><p>尝试使用并行流来加快字数统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Found &quot;</span> + countWords(stream.parallel()) + <span class="hljs-string">&quot; words&quot;</span>);<br></code></pre></td></tr></table></figure><p>不幸的是，这次的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">25<br></code></pre></td></tr></table></figure><ul><li>这显然是错误的。因为原始的 <code>String</code> 在任意位置拆分，所以有时一个词会被分为两个词，然后数了两次</li><li>这说明，拆分流会影响结果，而把顺序流换成并行流就可能使结果出错</li></ul><p>解决方案就是要确保 String 不是在随机位置拆开的，而只能在词尾拆开。可以为 <code>Character</code> 实现一个 <code>Spliterator</code>，它只能在两个词之间拆开 <code>String</code>，然后由此创建并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCounterSpliterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">Character</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String str;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentChar = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MINSIZE = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordCounterSpliterator</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.str = str;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> Character&gt; action)</span> </span>&#123;<br>        action.accept(str.charAt(currentChar++));<br>        <span class="hljs-keyword">return</span> currentChar &lt; str.length();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;Character&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> currentSize = str.length() - currentChar;<br>        <span class="hljs-keyword">if</span> (currentSize &lt; MINSIZE) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> splitPos = currentSize / <span class="hljs-number">2</span> + currentChar; splitPos &lt; str.length(); splitPos++) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isWhitespace(str.charAt(splitPos))) &#123;<br>                Spliterator&lt;Character&gt; spliterator =<br>                        <span class="hljs-keyword">new</span> WordCounterSpliterator(str.substring(currentChar, splitPos));<br>                currentChar = splitPos;<br>                <span class="hljs-keyword">return</span> spliterator;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">estimateSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str.length() - currentChar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章 Lambda 表达式</title>
    <link href="/2021/05/23/Java/%E7%AC%AC4%E7%AB%A0%20%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/05/23/Java/%E7%AC%AC4%E7%AB%A0%20%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-函数式接口"><a href="#4-1-函数式接口" class="headerlink" title="4.1 函数式接口"></a>4.1 函数式接口</h2><p>Lambda 表达式以「匿名方法」的形式实现「函数式接口」中的一个强制方法。函数式接口的强制方法的签名称为<strong>「函数描述符」</strong></p><p>函数式接口是只有一个强制方法的接口。不包括默认方法、静态方法、继承的方法（继承的方法可以不重写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 默认方法不是强制方法</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;   <span class="hljs-comment">// 静态方法不是强制方法</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;       <span class="hljs-comment">// toString() 方法从根类 Object 类中继承，可以不重写</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> vodi <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不是函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test6</span> </span>&#123;<br>                            <span class="hljs-comment">// 空接口没有一个强制方法</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 默认方法不是强制方法</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test8</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 可重写，可不重写，不是强制方法</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Tese8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span></span>;<span class="hljs-comment">// 定义了两个强制方法，其中一个从超类 Test1 中继承</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-1-FunctionalInterface"><a href="#4-1-1-FunctionalInterface" class="headerlink" title="4.1.1 @FunctionalInterface"></a>4.1.1 @FunctionalInterface</h3><p>注解 @FunctionalInterface 可以检查接口是否是一个函数式接口。如果不是，则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-2-内置的函数式接口"><a href="#4-1-2-内置的函数式接口" class="headerlink" title="4.1.2 内置的函数式接口"></a>4.1.2 内置的函数式接口</h3><h4 id="1-Predicate"><a href="#1-Predicate" class="headerlink" title="1. Predicate"></a>1. Predicate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<span class="hljs-comment">// 谓词：返回 boolean 的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2. Consumer"></a>2. Consumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Function"><a href="#3-Function" class="headerlink" title="3. Function"></a>3. Function</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br><span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;<br>        List&lt;T&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(T s: list)&#123;<br>            <span class="hljs-keyword">if</span>(p.test(s))&#123;<br>                res.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (T i : list) &#123;<br>            c.accept(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R&gt; <span class="hljs-function">List&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span> </span>&#123;<br>        List&lt;R&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(T s: list)&#123;<br>            res.add(f.apply(s));<br>        &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; nonEmpty = filter(Arrays.asList(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lambda&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>), s -&gt; !s.isEmpty());<br>        System.out.println(nonEmpty);<span class="hljs-comment">// 输出：[lambda, in, action]</span><br><br>        forEach(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), x -&gt; System.out.println(x));<br>        forEach(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), System.out.println);<br><br>        List&lt;Integer&gt; list = map(Arrays.asList(<span class="hljs-string">&quot;lambda&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>), x -&gt; x.length());<br>        List&lt;Integer&gt; list = map(Arrays.asList(<span class="hljs-string">&quot;lambda&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>), String::length);<br>        System.out.println(list);<span class="hljs-comment">// 输出：[6, 2, 6]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-Lambda-表达式"><a href="#4-2-Lambda-表达式" class="headerlink" title="4.2 Lambda 表达式"></a>4.2 Lambda 表达式</h2><h3 id="4-2-1-三大组成部分"><a href="#4-2-1-三大组成部分" class="headerlink" title="4.2.1 三大组成部分"></a>4.2.1 三大组成部分</h3><ul><li>参数列表：参数列表必须与函数式接口中要实现的强制方法匹配，可以不用指定参数类型</li><li>箭头：**-&gt;** 把参数列表与 Lambda 主体分隔开</li><li>Lambda 主体：实现的强制方法中的方法主体，可以为一条或多条语句。lambda 主体中隐含 <code>return</code> 语句</li></ul><p>有效的 lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123;&#125;                    <span class="hljs-comment">// 无参数，无返回值。两者都不能省</span><br>() -&gt; <span class="hljs-string">&quot;hello&quot;</span>               <span class="hljs-comment">// 无参数，返回 String</span><br>() -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;     <span class="hljs-comment">// 显式使用 return，注意 return ; &#123;&#125; 要么同时出现，要么都不出现</span><br></code></pre></td></tr></table></figure><p>无效的 lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(String s) -&gt; <span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// 必须使用花括号 &#123;&#125;</span><br>(String s) -&gt; &#123;<span class="hljs-string">&quot;hello&quot;</span>;&#125;            <span class="hljs-comment">// 必须使用 return</span><br></code></pre></td></tr></table></figure><p>修改后的 lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">s -&gt; &#123;<span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot;hello&quot;</span>;&#125;<br>s -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-可行性建议"><a href="#4-2-2-可行性建议" class="headerlink" title="4.2.2 可行性建议"></a>4.2.2 可行性建议</h3><ul><li>参数列表的类型可省。因为参数列表必须与函数描述符保持一致，可自动进行类型推导</li><li>只有一个参数时，<code>()</code> 可省</li><li>无参数时，<code>()</code> 不能省</li><li>无 lambda 主体时，<code>&#123;&#125;</code> 不能省</li><li>不推荐使用 <code>return</code> 语句，直接写出需返回的表达式更加简洁</li></ul><h3 id="4-2-3-使用-Lambda-表达式"><a href="#4-2-3-使用-Lambda-表达式" class="headerlink" title="4.2.3 使用 Lambda 表达式"></a>4.2.3 使用 Lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span> </span>&#123;<br>    <span class="hljs-comment">// 函数式接口 --- 静态成员接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test1</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test2</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test3</span> </span>&#123;<br>        <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">(String s)</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test4</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test1 t1 = () -&gt; System.out.println(<span class="hljs-string">&quot;Test1&quot;</span>);<span class="hljs-comment">// 输出一条语句，返回空</span><br>        t1.test();<br><br>        Test1 s1 = () -&gt; &#123;&#125;;<span class="hljs-comment">// 输出空，返回空</span><br>        s1.test();<br><br>        Test2 t2 = x -&gt; System.out.println(x + <span class="hljs-string">&quot; Test2&quot;</span>);<br>        t2.test(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>        Test3 t3 = s -&gt; s + <span class="hljs-string">&quot; Test3&quot;</span>;<br>        System.out.println(t3.test(<span class="hljs-string">&quot;hello&quot;</span>));<br><br>        Test4 t4 = (a, b) -&gt; a + b;<br>        System.out.println(t4.test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// lambda 表达式可以替换为方法引用</span><br>       Test4 s4 = Integer::sum;<br>        System.out.println(s4.test(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>));<br><br>        <span class="hljs-comment">// lambda 主体中可以包含多条语句</span><br>        Test4 p4 = (a, b) -&gt; &#123;<br>            System.out.println(a + b);<br>            System.out.println(a - b);<br>            System.out.println(a * b);<br>            System.out.println(a / b);<br>            <span class="hljs-keyword">return</span> a * <span class="hljs-number">100</span> + b * <span class="hljs-number">100</span>;<span class="hljs-comment">// 有 &#123;&#125; 时，return 不能省</span><br>        &#125;;<br>        System.out.println(p4.test(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Test1<br><br>hello Test2<br>hello Test3<br><span class="hljs-number">3</span><br><span class="hljs-number">300</span><br><span class="hljs-number">6</span><br><span class="hljs-number">2</span><br><span class="hljs-number">8</span><br><span class="hljs-number">2</span><br><span class="hljs-number">600</span><br></code></pre></td></tr></table></figure><h5 id="Apple-类"><a href="#Apple-类" class="headerlink" title="Apple 类"></a>Apple 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer weight;<br><br>    Apple(String color, Integer weight) &#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> weight;<br>    &#125;<br><br>    <span class="hljs-comment">// 用作方法引用，且必须声明为 static。方法签名必须与函数式接口中的强制方法的签名相同</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isGreen</span><span class="hljs-params">(Apple apple)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Green&quot;</span>.equals(apple.getColor());<br>    &#125;<br><br>    <span class="hljs-meta">@FunctionalInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">P</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(P p)</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Apple&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;Apple&gt; appleList, Predicate&lt;Apple&gt; p)</span> </span>&#123;<br>        List&lt;Aplle&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Apple apple : appleList) &#123;<br>            <span class="hljs-comment">// 过滤器模式</span><br>            <span class="hljs-keyword">if</span> (p.test(apple)) &#123;<br>                res.add(apple);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>));<br>        list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">200</span>));<br>        list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">180</span>));<br>        list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">200</span>));<br><br>        <span class="hljs-comment">// 推荐这样初始化 list</span><br>        List&lt;Apple&gt; aList = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>),<br>                <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">200</span>),<br>                <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">120</span>),<br>                <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">150</span>));<br><br>        List&lt;Apple&gt; greenApples = Apple.filter(list, a -&gt; <span class="hljs-string">&quot;Green&quot;</span>.equals(a.getColor()));<br>        List&lt;Apple&gt; heavyApples = Apple.filter(list, a -&gt; a.getWight() &gt; <span class="hljs-number">150</span>);<br>        List&lt;Apple&gt; ghApples = Apple.filter(list, a -&gt; <span class="hljs-string">&quot;Green&quot;</span>.equals(a.getColor() &amp;&amp; a.getWight() &gt; <span class="hljs-number">150</span>);<br><br>        <span class="hljs-comment">// lambda 表达式可以换成方法引用</span><br>        List&lt;Apple&gt; greenApples = Apple.filter&lt;list, a -&gt; isGreen(a));<br>        List&lt;Apple&gt; greenApples = Apple.filter&lt;list, Apple::isGreen);<span class="hljs-comment">// 不用传入参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-闭包"><a href="#4-2-4-闭包" class="headerlink" title="4.2.4 闭包"></a>4.2.4 闭包</h3><p>闭包就是一个函数的实例，它可以作为参数传递给方法，且可以访问其作用域之外的变量。Java 8 的 Lambda 和匿名类就类似于闭包</p><p><strong>局部变量的限制</strong></p><p>与局部类一样，lambda 表达式中访问的局部变量（实际上访问的是局部变量的副本）隐式声明为 <code>final</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;<br>Test1 t1 = () -&gt; System.out.println(x);<br>x = <span class="hljs-number">100</span>;<span class="hljs-comment">// lambda 表达式已使用局部变量 x（被隐式声明为 final），不能再被修改</span><br></code></pre></td></tr></table></figure><h2 id="4-3-方法引用"><a href="#4-3-方法引用" class="headerlink" title="4.3 方法引用"></a>4.3 方法引用</h2><p>方法引用允许将 Lambda 表达式换成已有的方法，且无需指定方法参数</p><p><strong>基本思想</strong>：如果一个 Lambda 表达式描述的只是「直接调用某个方法」，那么应直接使用函数名来调用它，而不是描述如何调用它</p><table><thead><tr><th align="left">Lambda 表达式</th><th>方法引用</th></tr></thead><tbody><tr><td align="left"><code>(Apple a) -&gt; a.getWeight()</code></td><td><code>Apple::getWeight</code></td></tr><tr><td align="left"><code>() -&gt; Thread.currentThread().dumpStack()</code></td><td><code>Thread.currentThread()::dumpStack</code></td></tr><tr><td align="left"><code>(String s, int i) -&gt; s.substring(i)</code></td><td><code>String::substring</code></td></tr><tr><td align="left"><code>(String s) -&gt; System.out.println(s)</code></td><td><code>System.out::println</code></td></tr></tbody></table><h3 id="4-3-1-分类"><a href="#4-3-1-分类" class="headerlink" title="4.3.1 分类"></a>4.3.1 分类</h3><h4 id="1-指向静态方法的方法引用"><a href="#1-指向静态方法的方法引用" class="headerlink" title="1. 指向静态方法的方法引用"></a>1. 指向静态方法的方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">args -&gt; ClassName.staticMethod(args)<br>ClassName::staticMethod<br></code></pre></td></tr></table></figure><h4 id="2-指向参数对象的实例方法的方法引用"><a href="#2-指向参数对象的实例方法的方法引用" class="headerlink" title="2. 指向参数对象的实例方法的方法引用"></a>2. 指向参数对象的实例方法的方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">obj -&gt; obj.instanceMethod()<br>ClassName::instanceMethod<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(obj, res) -&gt; obj.instanceMethod(res)<br>ClassName::instanceMethod<br></code></pre></td></tr></table></figure><h4 id="3-指向外部对象的实例方法的方法引用"><a href="#3-指向外部对象的实例方法的方法引用" class="headerlink" title="3. 指向外部对象的实例方法的方法引用"></a>3. 指向外部对象的实例方法的方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassName obj = <span class="hljs-keyword">new</span> ClassName();<br>args -&gt; obj.instanceMethod(args);<br>obj::instanceMethod<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>String&lt;Charater&gt; stream = Instream.range(<span class="hljs-number">0</span>, str.length())<br>    .mapToObj(str::charAt);<span class="hljs-comment">// i -&gt; str.charAt(i)</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-构造函数引用"><a href="#4-3-2-构造函数引用" class="headerlink" title="4.3.2 构造函数引用"></a>4.3.2 构造函数引用</h3><p>可以使用构造函数的名称和关键字 <code>new</code> 来创建一个构造方法引用：<code>ClassName::new</code></p><p>没有参数的构造函数 <code>Apple()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="hljs-keyword">new</span> Apple();<br>Supplier&lt;Apple&gt; c1 = Apple::<span class="hljs-keyword">new</span>;<br><span class="hljs-comment">// 初始化对象</span><br>Apple a1 = c1.get();<br></code></pre></td></tr></table></figure><p>一个参数的构造函数 <code>Apple(Integer weight)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Apple&gt; c2 = w -&gt; <span class="hljs-keyword">new</span> Apple(w);<br>Function&lt;Integer, Apple&gt; c2 = Apple::<span class="hljs-keyword">new</span>;<br><span class="hljs-comment">// 初始化对象（给定 Apple 的重量）</span><br>Apple a2 = c2.apply(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>两个参数的构造函数 <code>Apple(String color, Integer weight)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BiFunction&lt;String, Integer, Apple&gt; c3 = Apple::<span class="hljs-keyword">new</span>;<br><span class="hljs-comment">// 初始化对象（给定 Apple 的颜色和重量）</span><br>Apple a3 = c3.apply(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>初始化一系列对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; weights = Arrays.asList(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br>List&lt;Apple&gt; apples = map(weights, Apple::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R&gt; <span class="hljs-function">List&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span> </span>&#123;<br>    List&lt;R&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(T s: list)&#123;<br>        res.add(f.apply(s));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>Map</code> 将构造函数映射到字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Map&lt;String, Function&lt;Integer, Fruit&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">// 静态初始化程序</span><br><span class="hljs-keyword">static</span> &#123;<br>    map.put(<span class="hljs-string">&quot;apple&quot;</span>, Apple::<span class="hljs-keyword">new</span>);<br>    map.put(<span class="hljs-string">&quot;orange&quot;</span>, Orange::<span class="hljs-keyword">new</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回重量为 weight 的水果 fruit</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title">giveFruit</span><span class="hljs-params">(String fruit, Integer weight)</span></span>&#123;<br><span class="hljs-keyword">return</span> map.get(fruit.toLowerCase()).apply(weight);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-复合-Lambda-表达式"><a href="#4-4-复合-Lambda-表达式" class="headerlink" title="4.4 复合 Lambda 表达式"></a>4.4 复合 Lambda 表达式</h2><h3 id="4-4-1-排序"><a href="#4-4-1-排序" class="headerlink" title="4.4.1 排序"></a>4.4.1 排序</h3><h4 id="1-int-、Integer-、String"><a href="#1-int-、Integer-、String" class="headerlink" title="1. int[]、Integer[]、String[]"></a>1. int[]、Integer[]、String[]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] nums = <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-comment">// 在堆中</span><br>Integer[] nums = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-comment">// 在栈中</span><br><br>Arrays.sort(nums);<span class="hljs-comment">// 升序</span><br>Arrays.sort(nums, Comparator.reverseOrder());<span class="hljs-comment">// 降序</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Comparator.reverseOrder() 实际上调用 Collection.reverseOrder()</span><br><span class="hljs-comment"> * 但 Collection.reverseOrder() 返回类型为 Comparator&lt;T&gt;</span><br><span class="hljs-comment"> * 而 Arrays.sort 的第二个入参也为 Comparator&lt;T&gt;</span><br><span class="hljs-comment"> * 可见，Comparator&lt;T&gt; 是统一的对外接口</span><br><span class="hljs-comment"> */</span><br>Arrays.sort(nums, Comparator.naturalOrder());<span class="hljs-comment">// 升序</span><br>Arrays.sort(nums, Collection.naturalOrder());<span class="hljs-comment">// 升序</span><br>Arrays.sort(nums, Collection.reverseOrder());<span class="hljs-comment">// 降序</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><br>Arrays.sort(nums);<span class="hljs-comment">// 只能升序，降序必须将 int[] 声明为包装类数组 Integer[]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] str = <span class="hljs-keyword">new</span> &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bcd&quot;</span>&#125;;<br>String[] str = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bcd&quot;</span>&#125;;<br><br>Arrays.sort(str);<span class="hljs-comment">// 升序</span><br>Arrays.sort(str, Comparator.reverseOrder());<span class="hljs-comment">// 降序</span><br></code></pre></td></tr></table></figure><h4 id="2-List-lt-Integer-gt-、List-lt-String-gt"><a href="#2-List-lt-Integer-gt-、List-lt-String-gt" class="headerlink" title="2. List&lt;Integer&gt;、List&lt;String&gt;"></a>2. List&lt;Integer&gt;、List&lt;String&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<br>list.sort(Comparator.naturalOrder());<span class="hljs-comment">// 升序</span><br>list.sort(Comparator.reverseOrder());<span class="hljs-comment">// 降序</span><br><br>List&lt;String&gt; slist = Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>slist.sort(Comparator.naturalOrder());<span class="hljs-comment">// 升序</span><br>slist.sort(Comparator.reverseOrder())<span class="hljs-comment">// 降序</span><br></code></pre></td></tr></table></figure><h4 id="3-List-lt-Apple-gt"><a href="#3-List-lt-Apple-gt" class="headerlink" title="3. List&lt;Apple&gt;"></a>3. List&lt;Apple&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; alist = Arrays.asList(<br>        <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>),<br>        <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">200</span>),<br>        <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">100</span>),<br>        <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">150</span>));<br><br>Function&lt;Apple, Integer&gt; f = a -&gt; a.getWeight();<br><br>Comparator&lt;Apple&gt; c = Comparator.comparing(f);<br>Comparator&lt;Apple&gt; c = Comparator.comparing(a -&gt; a.getWeight());<br>Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);<br>Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());<br><br>alist.sort(c);<span class="hljs-comment">// 升序</span><br>alist.sort(c.reversed());<span class="hljs-comment">// 降序</span><br><br><span class="hljs-comment">// 注意：没有 Comparator.naturalOrder(c)、Comparator.reverseOrder(c)</span><br>alist.sort(Collections.naturalOrder(c));<br>alist.sort(Collections.reverseOrder(c));<span class="hljs-comment">// c.reversed() 实际上调用 Collections.reverseOrder(c)</span><br><br><span class="hljs-comment">// 推荐</span><br>alist.sort(Comparator.comparing(Apple::getWeight));<br>alist.sort(Comparator.comparing(Apple::getWeight).reversed());<br></code></pre></td></tr></table></figure><h4 id="4-List-lt-int-gt"><a href="#4-List-lt-int-gt" class="headerlink" title="4. List&lt;int[]&gt;"></a>4. List&lt;int[]&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先按下标 0 升序；若相等，再按下标 1 升序</span><br>list.sort((a1, a2) -&gt; (a1[<span class="hljs-number">0</span>] == a2[<span class="hljs-number">0</span>]) ? (a1[<span class="hljs-number">1</span>] - a2[<span class="hljs-number">1</span>]) : (a1[<span class="hljs-number">0</span>] - a2[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><h3 id="4-4-2-比较器链"><a href="#4-4-2-比较器链" class="headerlink" title="4.4.2 比较器链"></a>4.4.2 比较器链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(List&lt;Apple&gt; list, BiConsumer&lt;String, Integer&gt; bc)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Apple a : list) &#123;<br>            bc.accept(a.getColor(), a.getWeight());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparator&lt;Apple&gt; <span class="hljs-title">myComparing</span><span class="hljs-params">(Function&lt;Apple, Integer&gt; f1, Function&lt;Apple, String&gt; f2)</span> </span>&#123;<br>        <span class="hljs-comment">// 三种写法</span><br>        <span class="hljs-keyword">return</span> (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> res = f1.apply(o1).compareTo(f1.apply(o2));<br>            <span class="hljs-keyword">return</span> res != <span class="hljs-number">0</span> ? res : f2.apply(o1).compareTo(f2.apply(o2));<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (f1.apply(o1).equals(f1.apply(o2))) &#123;<br>                <span class="hljs-keyword">return</span> f2.apply(o1).compareTo(f2.apply(o2));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> f1.apply(o1).compareTo(f1.apply(o2));<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> Comparator.comparingInt(f1::apply).thenComparing(f2::apply);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Apple&gt; alist = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">160</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">200</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">150</span>));<br><br>        <span class="hljs-comment">// 按重量进行升序排序</span><br>        alist.sort(Comparator&gt;comparing(Apple::getWeight));<br>        forEach(list, (c, w) -&gt; System.out.println(c + <span class="hljs-string">&quot;\t&quot;</span> + w));<br>        System.out.println();<br><br>        <span class="hljs-comment">// 先按重量进行升序排序；当重量相同时，再按颜色进行升序排序</span><br>        alist.sort(Comparator.comparing(Apple::getWeight).thenComparing(Apple::getCountry));<br>        forEach(list, (c, w) -&gt; System.out.println(c + <span class="hljs-string">&quot;\t&quot;</span> + w));<br><br>        <span class="hljs-comment">// 使用自己定义的比较器链</span><br>        alist.sort(myComparing(Apple::getWeight, Apple::getColor));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Red <span class="hljs-number">100</span><br>Green <span class="hljs-number">100</span><br>Blue <span class="hljs-number">100</span><br>Blue <span class="hljs-number">150</span><br>Red <span class="hljs-number">160</span><br>Green <span class="hljs-number">200</span><br><br>Blue <span class="hljs-number">100</span><br>Green<span class="hljs-number">100</span><br>Red <span class="hljs-number">100</span><br>Blue <span class="hljs-number">150</span><br>Red <span class="hljs-number">160</span><br>Green <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="4-4-3-复合谓词"><a href="#4-4-3-复合谓词" class="headerlink" title="4.4.3 复合谓词"></a>4.4.3 复合谓词</h3><p>谓词接口 <code>Predicate&lt;T&gt;</code> 包括三个方法：<code>and、or、negate</code>，分别对应「与、或、非」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Apple&gt; alist = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">160</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">200</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">100</span>),<br>            <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">150</span>));<br><br>        Predicate&lt;Apple&gt; redApple = a -&gt; <span class="hljs-string">&quot;Red&quot;</span>.equals(a.getColor());<br><br>        <span class="hljs-comment">// 不是红苹果 --- negate</span><br>        alist&lt;Apple&gt; nonRedApple = filter(alist, redApple.negate());<br>        alist&lt;Apple&gt; nonRedApple = filter(alist, a -&gt; !(<span class="hljs-string">&quot;Red&quot;</span>.equals(a.getColor())));<br><br>        <span class="hljs-comment">// 比较重的红苹果 --- and</span><br>        alist&lt;Apple&gt; redHeavyApple = filter(alist, redApple.and(a -&gt; a.getWeight() &gt; <span class="hljs-number">150</span>));<br>        alist&lt;Apple&gt; redHeavyApple = filter(alist, a -&gt; <span class="hljs-string">&quot;Red&quot;</span>.equals(a.getColor()) &amp;&amp; a.getWeight() &gt; <span class="hljs-number">150</span>);<br><br>        <span class="hljs-comment">// 要么是重的红苹果，要么是绿苹果 --- and.or</span><br>        alist&lt;Apple&gt; redHeavyOrGreenApple = filter(alist, redApple.and(a -&gt; a.getWeight() &gt; <span class="hljs-number">150</span>)<br>                                                  .or(a -&gt; <span class="hljs-string">&quot;Green&quot;</span>.equals(a.getColor())));<br>        alist&lt;Apple&gt; redHeavyOrGreenApple = filter(alist, a -&gt; ((<span class="hljs-string">&quot;Red&quot;</span>.equals(a.getColor())<br>                                                                &amp;&amp; a.getWeight() &gt; <span class="hljs-number">150</span>))<br>                                                       || <span class="hljs-string">&quot;Green&quot;</span>.equals(a.getColor()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-4-复合-Lambda-表达式"><a href="#4-4-4-复合-Lambda-表达式" class="headerlink" title="4.4.4 复合 Lambda 表达式"></a>4.4.4 复合 Lambda 表达式</h3><p>使用接口 <code>Function&lt;T, R&gt;</code> 的 <code>andThen、compose</code> 方法复合 Lambda 表达式</p><h4 id="1-andThen-——-g-f-x"><a href="#1-andThen-——-g-f-x" class="headerlink" title="1. andThen —— g(f(x))"></a>1. andThen —— g(f(x))</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="hljs-number">1</span>;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="hljs-number">2</span>;<br>Function&lt;Integer, Integer&gt; h = f.andThen(g);<span class="hljs-comment">// g(f(x))</span><br><span class="hljs-keyword">int</span> result = h.apply(<span class="hljs-number">1</span>);<span class="hljs-comment">// 输出：(x + 1) * 2 = 4</span><br></code></pre></td></tr></table></figure><h4 id="2-compose-——-f-g-x"><a href="#2-compose-——-f-g-x" class="headerlink" title="2. compose —— f(g(x))"></a>2. compose —— f(g(x))</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="hljs-number">1</span>;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="hljs-number">2</span>;<br>Function&lt;Integer, Integer&gt; h = f.compose(g);<span class="hljs-comment">// f(g(x))</span><br><span class="hljs-keyword">int</span> result = h.apply(<span class="hljs-number">1</span>);<span class="hljs-comment">// 输出：(x * 2) + 1 = 3</span><br></code></pre></td></tr></table></figure><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><ul><li>Lambda 表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表- </li><li>函数式接口就是仅仅声明了一个抽象方法的接口</li><li>Lambda 表达式让你可以简洁地传递代码，只有在接受函数式接口的地方才可以使用 Lambda 表达式</li><li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例</li><li>Java 8 自带一些常用的函数式接口，放在 java.util.function 包里，包括 Predicate&lt;T&gt;、Function&lt;T, R&gt;、Supplier&lt;T&gt;、Consumer&lt;T&gt; 和 BinaryOperator&lt;T&gt;</li><li>为了避免装箱操作，对 Predicate&lt;T&gt; 和 Function&lt;T, R&gt; 等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction</li><li>环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理）可以配合 Lambda 表达式提高灵活性和可重用性</li><li>Lambda 表达式所需要代表的类型称为目标类型</li><li>方法引用让你重复使用现有的方法实现并直接传递它们</li><li>Comparator、Predicate 和 Function 等函数式接口都有几个可以用来结合 Lambda 表达式的默认方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda 表达式</tag>
      
      <tag>函数式接口</tag>
      
      <tag>方法引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第3章 正则表达式</title>
    <link href="/2021/05/19/Java/%E7%AC%AC3%E7%AB%A0%20%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/05/19/Java/%E7%AC%AC3%E7%AB%A0%20%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-字符匹配符"><a href="#3-1-字符匹配符" class="headerlink" title="3.1 字符匹配符"></a>3.1 字符匹配符</h2><table><thead><tr><th>符号</th><th>说明</th><th>示例</th><th>说明</th><th>匹配结果</th></tr></thead><tbody><tr><td><code>[]</code></td><td>匹配 <code>[]</code> 中的任意一个</td><td><code>[abc]</code></td><td><code>a、b、c</code> 中的任意一个字符</td><td><code>a</code></td></tr><tr><td><code>[^]</code></td><td>匹配除 <code>[]</code> 中的任意一个</td><td><code>[^abc]</code></td><td>除 <code>a、b、c</code> 外的任意一个字符</td><td><code>d</code></td></tr><tr><td><code>-</code></td><td>连字符</td><td><code>a-z</code></td><td>任意一个小写字母</td><td><code>g</code></td></tr><tr><td><code>.</code></td><td>除 <code>\n</code> 外的任意字符</td><td><code>a..b</code></td><td><code>a</code> 开头，<code>b</code> 结尾，中间包含 2 个任意字符</td><td><code>a12b</code>、<code>a#?b</code></td></tr><tr><td><code>\\d</code></td><td>一个数字，等价于 <code>[0-9]</code></td><td><code>\\d&#123;3&#125;(\\d)?</code></td><td>包含 3 或 4 个数字，<code>?</code> 表示可能有或没有第 4 个数字</td><td><code>123</code>、<code>5678</code></td></tr><tr><td><code>\\D</code></td><td>一个非数字，等价于 <code>[^0-9]</code></td><td><code>\\D(\\d)*</code></td><td>以一个非数字开头，后接任意个数字</td><td><code>a123</code>、<code>A</code></td></tr><tr><td><code>\\w</code></td><td>一个数字、字母、下划线，等价于 <code>[0-9a-zA-Z_]</code></td><td><code>\\d&#123;3&#125;\\w&#123;4&#125;</code></td><td>以 3 个数字开头的长度为 7 的数字字母</td><td><code>123_4b5</code>、<code>789bd1e</code></td></tr><tr><td><code>\\W</code></td><td>一个非数字、字母、下划线，等价于 <code>[^0-9a-zA-Z]</code></td><td><code>\\W+\\d&#123;2&#125;</code></td><td>以至少一个非数字字母开头，2 个数字结尾</td><td><code>#-12</code>、<code>@%&amp;45</code>、不能是 `#-1223</td></tr><tr><td><code>\\s</code></td><td>一个空白字符（空格、制表符、换行符）</td><td><code>\\s+</code></td><td>包含至少一个空白字符</td><td></td></tr><tr><td><code>\\S</code></td><td>一个非空白字符</td><td><code>\\S+</code></td><td>包含至少一个非空白字符</td><td><code>123abc</code></td></tr></tbody></table><h2 id="3-2-选择匹配符"><a href="#3-2-选择匹配符" class="headerlink" title="3.2 选择匹配符"></a>3.2 选择匹配符</h2><table><thead><tr><th>符号</th><th>说明</th><th>示例</th><th>说明</th><th>匹配结果</th></tr></thead><tbody><tr><td>`</td><td>`</td><td>`</td><td>` 左边或右边</td><td>`ab</td></tr></tbody></table><h2 id="3-3-限定符"><a href="#3-3-限定符" class="headerlink" title="3.3 限定符"></a>3.3 限定符</h2><table><thead><tr><th>符号</th><th>说明</th><th>示例</th><th>说明</th><th>匹配结果</th></tr></thead><tbody><tr><td><code>*</code></td><td>左边的字符重复 ≥ 0 次</td><td><code>(abc)*</code></td><td>包含任意个 <code>abc</code></td><td><code>abc</code>、<code>abcabc</code></td></tr><tr><td><code>+</code></td><td>左边的字符重复 ≥ 1 次</td><td><code>m+(abc)*</code></td><td>以至少 1 个 m 开头，后接任意个 <code>abc</code></td><td><code>m</code>、<code>mabc</code>、<code>mmabc</code></td></tr><tr><td><code>?</code></td><td>左边的字符重复 0 或 1 次</td><td><code>m+abc?</code></td><td>以至多 1 个 m 开头，后接 <code>ab</code> 或 <code>abc</code></td><td><code>mab</code>、<code>mabc</code>、<code>mmabc</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>字符数 = n</td><td><code>[abcd]&#123;3&#125;</code></td><td>由 <code>abcd</code> 中任意字母组成的字符数 = 3</td><td><code>abc</code>、<code>dbc</code>、<code>adc</code></td></tr><tr><td><code>&#123;n,&#125;</code></td><td>字符数 ≥ n</td><td><code>[abcd]&#123;3,&#125;</code></td><td>由 <code>abcd</code> 中任意字母组成的字符数 ≥ 3</td><td><code>aab</code>、<code>aadcbcc</code></td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>字符数 ∈<code>[n, m]</code></td><td><code>[abcd]&#123;3,5&#125;</code></td><td>由 <code>abcd</code> 中任意字母组成的字符数 ∈ <code>[3, 5]</code></td><td><code>abd</code>、<code>daca</code>、<code>ccabd</code></td></tr></tbody></table><h2 id="3-4-定位符"><a href="#3-4-定位符" class="headerlink" title="3.4 定位符"></a>3.4 定位符</h2><table><thead><tr><th>符号</th><th>说明</th><th>示例</th><th>说明</th><th>匹配结果</th></tr></thead><tbody><tr><td><code>^</code></td><td>指定起始字符</td><td><code>^[0-9]+[a-z]*</code></td><td>以至少 1 个数字开头，后接任意个小写字母</td><td><code>12</code>、<code>6a</code>、不能是 <code>a123</code></td></tr><tr><td><code>$</code></td><td>指定结束字符</td><td><code>^[0-9][a-z]+$</code></td><td>以 1 个数字开头，至少 1 个小写字母结尾</td><td><code>1ab</code>、不能是 <code>1#ab</code></td></tr><tr><td><code>\\b</code></td><td>匹配目标字符串的边界</td><td><code>abc\\b</code></td><td><code>abc</code> 后面是空格、制表符、换行符等边界</td><td><code>1abc 232abc\n56 </code>、<code>2abc</code></td></tr><tr><td><code>\\B</code></td><td>匹配目标字符串的非边界</td><td><code>abc\\B</code></td><td><code>abc</code> 后面不是空格、制表符、换行符等边界</td><td><code>abc123 abc9</code>、<code>1abc3</code></td></tr></tbody></table><h2 id="3-5-分组"><a href="#3-5-分组" class="headerlink" title="3.5 分组"></a>3.5 分组</h2><h3 id="3-5-1-捕获分组"><a href="#3-5-1-捕获分组" class="headerlink" title="3.5.1 捕获分组"></a>3.5.1 捕获分组</h3><h4 id="1-非命名捕获：-pattern"><a href="#1-非命名捕获：-pattern" class="headerlink" title="1. 非命名捕获： (pattern)"></a>1. 非命名捕获： (pattern)</h4><p><code>(\\d\\d)(\\d\\d)</code></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">将 <span class="hljs-number">1234</span> 分为两组：<span class="hljs-number">12</span> 和 <span class="hljs-number">34</span>。通过 matcher.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>) 捕获 <span class="hljs-number">12</span>，matcher.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>) 捕获 <span class="hljs-number">34</span>，matcher.<span class="hljs-keyword">group</span>(<span class="hljs-number">0</span>) 捕获 <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h4 id="2-命名捕获：-lt-name-gt-pattern"><a href="#2-命名捕获：-lt-name-gt-pattern" class="headerlink" title="2. 命名捕获： (?&lt;name&gt;pattern)"></a>2. 命名捕获： (?&lt;name&gt;pattern)</h4><p><code>(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)</code></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">通过 matcher.<span class="hljs-keyword">group</span>(<span class="hljs-string">&quot;g1&quot;</span>) 捕获 <span class="hljs-number">12</span>，matcher.<span class="hljs-keyword">group</span>(<span class="hljs-string">&quot;g2&quot;</span>) 捕获 <span class="hljs-number">34</span>，matcher.<span class="hljs-keyword">group</span>(<span class="hljs-number">0</span>) 捕获 <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="3-5-2-非捕获分组"><a href="#3-5-2-非捕获分组" class="headerlink" title="3.5.2 非捕获分组"></a>3.5.2 非捕获分组</h3><p>只匹配不捕获：不能通过 <code>matcher.group</code> 进行捕获分组</p><h4 id="1-pattern"><a href="#1-pattern" class="headerlink" title="1. (?:pattern)"></a>1. (?:pattern)</h4><p><code>conti(?:nue|ous)</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">匹配 <span class="hljs-keyword">continue</span>、contious，比 <span class="hljs-string">&quot;continue|contious&quot;</span> 更简洁<br></code></pre></td></tr></table></figure><h4 id="2-pattern"><a href="#2-pattern" class="headerlink" title="2.  (?=pattern)"></a>2.  (?=pattern)</h4><p><code>continue(?=1|2)</code></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">匹配 <span class="hljs-keyword">continue</span><span class="hljs-number">1</span>、<span class="hljs-keyword">continue</span><span class="hljs-number">2</span> 中的 <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p><code>continue(?=[^12])</code></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">匹配不是 <span class="hljs-keyword">continue</span><span class="hljs-number">1</span>、<span class="hljs-keyword">continue</span><span class="hljs-number">2</span> 中的 <span class="hljs-keyword">continue</span>，<span class="hljs-number">1</span>|<span class="hljs-number">2</span> 等价于 [<span class="hljs-number">12</span>]。也可以是 <span class="hljs-keyword">continue</span>(?!<span class="hljs-number">1</span>|<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="3-pattern"><a href="#3-pattern" class="headerlink" title="3.  (?!pattern)"></a>3.  (?!pattern)</h4><p><code>continue(?!12|NP)</code></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">匹配不是 <span class="hljs-keyword">continue</span><span class="hljs-number">12</span>、continueNP 中的 <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><h2 id="3-6-Code"><a href="#3-6-Code" class="headerlink" title="3.6 Code"></a>3.6 Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegExp</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// ----------------------------------- 元字符 ---------------------------------------</span><br>        <span class="hljs-comment">// 字符匹配符</span><br>        String regStr = <span class="hljs-string">&quot;\\d&#123;4&#125;&quot;</span>;           <span class="hljs-comment">// 4 个数字</span><br>        String regStr2 = <span class="hljs-string">&quot;[abc]&quot;</span>;           <span class="hljs-comment">// abc 中的任意一个字符</span><br>        String regStr3 = <span class="hljs-string">&quot;\\d&#123;3&#125;(\\d)?&quot;</span>;    <span class="hljs-comment">// 包含 3 或 4 个数字，`?` 表示可能有或没有第 4 个数字</span><br>        String regStr4 = <span class="hljs-string">&quot;\\D(\\d)*&quot;</span>;       <span class="hljs-comment">// 以一个非数字开头，后接任意个数字</span><br>        String regStr5 = <span class="hljs-string">&quot;\\d&#123;3&#125;\\W&#123;4&#125;&quot;</span>;    <span class="hljs-comment">// 以 3 个数字开头的长度为 7 的数字字母下划线</span><br>        String regStr6 = <span class="hljs-string">&quot;\\W+\\d&#123;2&#125;&quot;</span>;      <span class="hljs-comment">// 以至少一个非数字字母开头，2 个数字结尾</span><br>        String regStr7 = <span class="hljs-string">&quot;.&quot;</span>;               <span class="hljs-comment">// \n 外的任意一个字符</span><br>        String regStr8 = <span class="hljs-string">&quot;\\.&quot;</span>;             <span class="hljs-comment">// . 本身</span><br>        String regStr9 = <span class="hljs-string">&quot;\\s+&quot;</span>;            <span class="hljs-comment">// 包含至少一个空白字符（空格、制表符、换行符）</span><br>        String regStr10 = <span class="hljs-string">&quot;\\S+&quot;</span>;           <span class="hljs-comment">// 包含至少一个非空白字符</span><br><br>        String alpha = <span class="hljs-string">&quot;abc&quot;</span>;               <span class="hljs-comment">// 区分大小写</span><br>        String alpha2 = <span class="hljs-string">&quot;(?i)abc&quot;</span>;          <span class="hljs-comment">// 不区分大小写</span><br>        String alpha3 = <span class="hljs-string">&quot;a(?i)bc&quot;</span>;          <span class="hljs-comment">// bc 不区分大小写</span><br>        String alpha4 = <span class="hljs-string">&quot;a((?i)b)c&quot;</span>;        <span class="hljs-comment">// b 不区分大小写</span><br>        String alpha5 = <span class="hljs-string">&quot;[abc]&quot;</span>;            <span class="hljs-comment">// abc 中的任意一个</span><br><br>        <span class="hljs-comment">// 选择匹配符</span><br>        String select = <span class="hljs-string">&quot;ab|cd&quot;</span>;            <span class="hljs-comment">// 匹配 ab 或 cd</span><br><br>        <span class="hljs-comment">// 限定符</span><br>        String qualifier = <span class="hljs-string">&quot;m+(abc)*&quot;</span>;      <span class="hljs-comment">// 以至少 1 个 m 开头，后接任意个 abc</span><br>        String qualifier2 = <span class="hljs-string">&quot;m+abc?&quot;</span>;       <span class="hljs-comment">// 以至少 1 个 m 开头，后接 ab 或 abc</span><br>        String qualifier3 = <span class="hljs-string">&quot;[abcd]&#123;3&#125;&quot;</span>;    <span class="hljs-comment">// 由 abcd 中任意字母组成的字符数 = 3</span><br>        String qualifier4 = <span class="hljs-string">&quot;[abcd]&#123;3,&#125;&quot;</span>;   <span class="hljs-comment">// 由 abcd 中任意字母组成的字符数 ≥ 3</span><br>        String qualifier5 = <span class="hljs-string">&quot;[abcd]&#123;3,5&#125;&quot;</span>;  <span class="hljs-comment">// 由 abcd 中任意字母组成的字符数 ∈ [3, 5]</span><br><br>        <span class="hljs-comment">// 定位符</span><br>        String locator = <span class="hljs-string">&quot;^[0-9]+[a-z]*&quot;</span>;   <span class="hljs-comment">// 以至少 1 个数组开头，后接任意个小写字母</span><br>        String locator2 = <span class="hljs-string">&quot;^[0-9][a-z]+$&quot;</span>;  <span class="hljs-comment">// 以至少 1 个数字开头，至少 1 个小写字母结尾，【中间不能有其他字符】</span><br>        String locator3 = <span class="hljs-string">&quot;abc\\b&quot;</span>;         <span class="hljs-comment">// abc 后面是空格、制表符、换行符等边界</span><br>        String locator4 = <span class="hljs-string">&quot;abc\\B&quot;</span>;         <span class="hljs-comment">// abc 后面不是空格、制表符、换行符等边界</span><br><br>        <span class="hljs-comment">// 捕获分组</span><br>        String group = <span class="hljs-string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;             <span class="hljs-comment">// 非命名捕获，通过 group(1)、group(2) 捕获第 1、2 个分组</span><br>        String group2 = <span class="hljs-string">&quot;(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)&quot;</span>;  <span class="hljs-comment">// 命名捕获，通过 matcher.group(&quot;g1&quot;) 捕获第 1 个分组</span><br><br>        <span class="hljs-comment">// 非捕获分组 --- 不能通过 matcher.group(1) 进行捕获分组</span><br>        String group3 = <span class="hljs-string">&quot;conti(?:nue|ous)&quot;</span>;     <span class="hljs-comment">// 匹配 continue、contious，比 &quot;continue|contious&quot; 更简洁</span><br>        String group4 = <span class="hljs-string">&quot;continue(?=1|2)&quot;</span>;      <span class="hljs-comment">// 匹配 continue1、continue2 中的 continue</span><br>        String group5 = <span class="hljs-string">&quot;continue(?=[^12])&quot;</span>;    <span class="hljs-comment">// 匹配不是 continue1、continue2 中的 continue</span><br>        String group6 = <span class="hljs-string">&quot;continue(?!12|NP)&quot;</span>;    <span class="hljs-comment">// 匹配不是 continue12、continueNP 中的 continue</span><br><br>        <span class="hljs-comment">// 贪心、非贪心匹配</span><br>        String greedy = <span class="hljs-string">&quot;\\d+&quot;</span>;       <span class="hljs-comment">// 贪心匹配，在 1111aa中，匹配所有 1</span><br>        String nonGreedy = <span class="hljs-string">&quot;\\d+?&quot;</span>;   <span class="hljs-comment">// 非贪心匹配，在 1111aa 中，仅匹配一个 1</span><br><br>        String str = <span class="hljs-string">&quot;11aaaa&quot;</span>;<br><span class="hljs-comment">//        Pattern pattern = Pattern.compile(alpha4, Pattern.CASE_INSENSITIVE);   // 不区分大小写</span><br>        Pattern pattern = Pattern.compile(nonGreedy);<br>        Matcher matcher = pattern.matcher(str);<br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Finded:\t&quot;</span> + matcher.group(<span class="hljs-number">0</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7-实例"><a href="#3-7-实例" class="headerlink" title="3.7 实例"></a>3.7 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegExpPractice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;a9--&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 汉字</span><br><span class="hljs-comment">         * Need: 以至少一个汉字开头、结尾。即必须全是汉字</span><br><span class="hljs-comment">         * eg:   你好</span><br><span class="hljs-comment">         */</span><br>        String regExp = <span class="hljs-string">&quot;^[\u0391-\uffe5]+$&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 邮编</span><br><span class="hljs-comment">         * Need: 以 1-9 开头的 6 位数</span><br><span class="hljs-comment">         * eg:   123666</span><br><span class="hljs-comment">         */</span><br>        String regExp2 = <span class="hljs-string">&quot;^[1-9]\\d&#123;5&#125;$&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * QQ</span><br><span class="hljs-comment">         * Need: 以 1-9 开头的 5-10 位数</span><br><span class="hljs-comment">         * eg:   12345, 666666</span><br><span class="hljs-comment">         */</span><br>        String regExp3 = <span class="hljs-string">&quot;^[1-9]\\d&#123;4,9&#125;$&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 手机号</span><br><span class="hljs-comment">         * Need: 以 13, 14, 15, 18 开头的 11 位数</span><br><span class="hljs-comment">         * eg:   13566668888</span><br><span class="hljs-comment">         */</span><br>        String regExp4 = <span class="hljs-string">&quot;^1[2348]\\d&#123;9&#125;$&quot;</span>;     <span class="hljs-comment">// 如果是以 123 或 148 开头，应写成 ^1(23|48)\d&#123;9&#125;$</span><br><br>        String url = <span class="hljs-string">&quot;https://www.bilibili.com/video/BV1Eq4y1E79W?p=17&amp;spm_id_from=pageDriver&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * URL</span><br><span class="hljs-comment">         * https:// -------- ((http|https)://)?    有些 URL 没有 https:// 或 http://，因此后面是 ?</span><br><span class="hljs-comment">         * www.bilibili. --- ([\w-]+\.)+           URL 可能是 www.bi-lib-ili.com，因此需要连字符 -</span><br><span class="hljs-comment">         * com ------------- [\w-]+</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * (/[\\w-?=&amp;/%.]*)?</span><br><span class="hljs-comment">         *      1. [\\w-?=&amp;/%.] 中的字符可以有任意个，因此后面是 *</span><br><span class="hljs-comment">         *      2. / 和后面的字符可能有可能没有，因此后面是 ?。eg: https://www.bilibili.com</span><br><span class="hljs-comment">         *      3. 注意：[?.] 内的字符不需要转义，都表示 ?. 本身，因此 [.] 等价于 \\.</span><br><span class="hljs-comment">         */</span><br>        String regExp5 = <span class="hljs-string">&quot;^((http|https)://)?([\\w-]+\\.)+[\\w-]+(/[\\w-?=#&amp;/%.]*)?$&quot;</span>;<br><br>        Pattern pattern = Pattern.compile(regExp5);<br>        Matcher matcher = pattern.matcher(url);<br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Satisfied&quot;</span>);<br>            System.out.println(matcher.group(<span class="hljs-number">0</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Not Satisfied&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>元字符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相关配置</title>
    <link href="/2021/05/19/MySQL/%E7%AC%AC1%E7%AB%A0%20%20%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/05/19/MySQL/%E7%AC%AC1%E7%AB%A0%20%20%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-启动-MySQL-服务"><a href="#1-1-启动-MySQL-服务" class="headerlink" title="1.1 启动 MySQL 服务"></a>1.1 启动 MySQL 服务</h2><h3 id="1-1-1-Linux"><a href="#1-1-1-Linux" class="headerlink" title="1.1.1 Linux"></a>1.1.1 Linux</h3><h4 id="1-使用-service"><a href="#1-使用-service" class="headerlink" title="1. 使用 service"></a>1. 使用 service</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">service mysqld status    -- 查看状态<br>service mysqld start     -- 启动<br>service mysqld stop      -- 停止<br>service mysqld restart   -- 重启<br></code></pre></td></tr></table></figure><h4 id="2-使用-systemctl"><a href="#2-使用-systemctl" class="headerlink" title="2. 使用 systemctl"></a>2. 使用 systemctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">systemctl status mysql.service   -- 查看状态<br>systemctl start mysql.service    -- 启动<br>systemctl stop mysql.service     -- 停止<br>systemctl restart mysql.service  -- 重启<br></code></pre></td></tr></table></figure><h3 id="1-1-2-Win"><a href="#1-1-2-Win" class="headerlink" title="1.1.2 Win"></a>1.1.2 Win</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">net start mysql -- 启动<br>net stop mysql  -- 停止<br></code></pre></td></tr></table></figure><h2 id="1-2-连接-MySQL"><a href="#1-2-连接-MySQL" class="headerlink" title="1.2 连接 MySQL"></a>1.2 连接 MySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -uroot -p-- 回车后输入密码<br>mysql -uroot -p密码     -- 直接在 -p 后面输密码，注意 -p 后不能有空格<br>exit;-- 退出连接<br></code></pre></td></tr></table></figure><h2 id="1-3-修改用户密码"><a href="#1-3-修改用户密码" class="headerlink" title="1.3 修改用户密码"></a>1.3 修改用户密码</h2><p>连接 MySQL 后，在 <code>mysql&gt;</code> 后输入下方的命令，修改密码为一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set authentication_string&#x3D;password(&#39; &#39;) where user&#x3D;&#39;root&#39; and host&#x3D;&#39;localhost&#39;;<br>flush privileges;-- 刷新权限，可不要<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 类型系统</title>
    <link href="/2021/05/17/Java/%E7%AC%AC2%E7%AB%A0%20%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/05/17/Java/%E7%AC%AC2%E7%AB%A0%20%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-五种引用类型"><a href="#2-1-五种引用类型" class="headerlink" title="2.1 五种引用类型"></a>2.1 五种引用类型</h2><p>五种引用类型：数组、类、接口、枚举、注解</p><h3 id="2-1-1-引用类型和基本类型"><a href="#2-1-1-引用类型和基本类型" class="headerlink" title="2.1.1 引用类型和基本类型"></a>2.1.1 引用类型和基本类型</h3><ul><li>八种基本类型由 Java 语言定义，程序员不能定义新基本类型。引用类型由用户定义，因此有无限多个</li><li>基本类型表示单个值。引用类型是聚合类型，可以保存零个或多个基本值或对象。假设 Point 类存储两个 double 类型的值，char[] 和 Point[] 数组类型是聚合类型，因为它们保存一些 char 类型的基本值和 Point 对象</li><li><strong>「基本类型使用深复制」</strong>。把基本值赋给变量或传入方法时，会重新申请一块内存，在哪申请内存取决于变量类型。具体而言，局部变量在栈中，全局变量和静态变量都在全局（静态）存储区</li><li><strong>「引用类型使用浅复制」</strong>。把对象赋给变量或传入方法时，不会重新申请一块内存，而是把这个内存的引用存储在变量中或传入方法。即只有一个对象的副本，但是这个对象的引用有两个副本<h3 id="2-1-2-数组的深复制"><a href="#2-1-2-数组的深复制" class="headerlink" title="2.1.2 数组的深复制"></a>2.1.2 数组的深复制</h3></li></ul><p>数组可以通过 <code>clone</code> 或 <code>System.arraycopy</code> 方法实现深复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明数组的两种方法</span><br><span class="hljs-keyword">int</span>[] srcNums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>&#125;;<br><span class="hljs-keyword">int</span>[] srcNums = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>&#125;;<br><br><span class="hljs-comment">// 浅复制</span><br><span class="hljs-keyword">int</span>[] dstNums = srcNums;<br>dstNums[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;   <span class="hljs-comment">// srcNums[0] = 100</span><br><br><span class="hljs-comment">// 深复制</span><br><span class="hljs-keyword">int</span>[] dstNums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[srcNums.length];<br>System.arraycopy(srcNums, <span class="hljs-number">0</span>, dstNums, <span class="hljs-number">0</span>, srcNums.length);<br>dstNums[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;   <span class="hljs-comment">// srcNums[0] = 2</span><br><br><span class="hljs-keyword">int</span>[] dstNums = srcNums.clone();<br>dstNums[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;   <span class="hljs-comment">// srcNums[0] = 2</span><br></code></pre></td></tr></table></figure><h2 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h2><h3 id="2-2-1-定义接口"><a href="#2-2-1-定义接口" class="headerlink" title="2.2.1 定义接口"></a>2.2.1 定义接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若不声明为 public，则不能在包外访问该接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Centered</span> </span>&#123;<br>    <span class="hljs-comment">// 解耦的所有成员都隐式声明为 public</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCenter</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getCenterX</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getCenterY</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-接口的特性"><a href="#1-接口的特性" class="headerlink" title="1. 接口的特性"></a>1. 接口的特性</h4><ul><li><p>接口中的所有「强制方法」（实现该接口的类必须实现的方法）都隐式声明为 <code>abstract</code> ，不能有方法主体，并使用分号</p></li><li><p>接口（包括注解）的所有成员都隐式声明为 <code>public</code>（若需要在包外访问该接口，则接口应声明为 <code>public</code>）。如果在接口中使用 <code>protected</code> 或 <code>private</code> 定义方法，会导致编译错误</p></li><li><p>接口中可以包含嵌套类型。嵌套类型隐式使用 <code>public</code> 和 <code>static</code> 声明</p></li><li><p>从 Java 8 开始，接口中可以定义静态方法和默认方法（声明为 <code>default</code> 的方法）</p></li></ul><h4 id="2-接口的限制"><a href="#2-接口的限制" class="headerlink" title="2. 接口的限制"></a>2. 接口的限制</h4><ul><li>接口不能定义任何实例字段，因为实例字段是实现细节。在接口中只能定义同时使用 <code>static</code> 和 <code>final</code> 声明的常量</li><li>接口不能实例化，因此不定义构造方法</li></ul><h3 id="2-2-2-扩展接口"><a href="#2-2-2-扩展接口" class="headerlink" title="2.2.2 扩展接口"></a>2.2.2 扩展接口</h3><p><strong>接口使用关键字 <code>extends</code> 扩展接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Positionable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Centered</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUpperRightCorner</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getUpperRightX</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getUpperRightY</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Transformable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scalable</span>, <span class="hljs-title">Translatable</span>, <span class="hljs-title">Rotatable</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SuperShape</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Positionable</span>, <span class="hljs-title">Transformable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>扩展多个接口的接口，会继承每个父接口中的所有方法和常量，且可以定义属于自己的方法和常量</li><li>实现这个接口的类必须实现这个接口直接定义的抽象方法，以及从所有父接口中继承的全部抽象方法</li></ul><h3 id="2-2-3-实现接口"><a href="#2-2-3-实现接口" class="headerlink" title="2.2.3 实现接口"></a>2.2.3 实现接口</h3><p><strong>类使用关键字 <code>extends</code> 扩展超类，使用关键字 <code>implements</code> 实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CenteredRectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Centered</span> </span>&#123;<br>    <span class="hljs-comment">// 新增的实例字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> cx, cy;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CenteredRectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> cx, <span class="hljs-keyword">double</span> cy, <span class="hljs-keyword">double</span> w, <span class="hljs-keyword">double</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, h);<br>        <span class="hljs-keyword">this</span>.cx = cx;<br>        <span class="hljs-keyword">this</span>.cy = cy;<br>    &#125;<br><br>    <span class="hljs-comment">// 继承了 Rectangle 类中的所有方法</span><br>    <span class="hljs-comment">// 但要实现 Centered 接口中的所有强制方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCenter</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        cx = x;<br>        cy = y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCenterX</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cx;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCenterY</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果实现接口的类没有实现接口中的所有抽象方法，那么这个类从接口中继承未实现的抽象方法，且必须声明为 <code>abstract</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CenteredRectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Centered</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> cx, cy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CenteredRectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> cx, <span class="hljs-keyword">double</span> cy, <span class="hljs-keyword">double</span> w, <span class="hljs-keyword">double</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, h);<br>        <span class="hljs-keyword">this</span>.cx = cx;<br>        <span class="hljs-keyword">this</span>.cy = cy;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有实现 Centered 接口中的 setCenter 方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCenterX</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cx;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCenterY</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cy;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一个接口，多种实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">CenteredRectangle rect = <span class="hljs-keyword">new</span> CenteredRectangle(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br>CenteredRectangle squ = <span class="hljs-keyword">new</span> CenteredSquare(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br><br><span class="hljs-keyword">if</span> (rect <span class="hljs-keyword">instanceof</span> Centered) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Instance rect belongs to Interface Centered&quot;</span>)<br>&#125;<br><br>Centered cen = rect;            <span class="hljs-comment">// 放大转换</span><br><span class="hljs-keyword">double</span> rx = cen.getCenterX();   <span class="hljs-comment">// 调用 CenteredRectangle 类实现的接口方法</span><br><br>cen = suq;<br>duoble sx = cen.getCenterX();   <span class="hljs-comment">// 调用 CenteredSquare 类实现的接口方法</span><br><br><span class="hljs-comment">// 推荐写法</span><br>Centered cen = <span class="hljs-keyword">new</span> CenteredRectangle(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><ul><li>如果一个类实现了一个接口，那么这个类的实例可以赋值给这个接口的变量 <strong>（不能称为实例，因为接口不能实例化）</strong></li><li>不同类可以实现同一个接口的接口方法，将不同的类实例赋值给同一个接口变量，即可通过一个接口变量调用不同类实现的接口方法</li></ul><h3 id="2-2-4-实现多个接口"><a href="#2-2-4-实现多个接口" class="headerlink" title="2.2.4 实现多个接口"></a>2.2.4 实现多个接口</h3><p>一个类实现多个接口表明这个类要实现所有接口中的全部抽象方法，否则必须声明为 <code>abstract</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperDuperSquare</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Centered</span>, <span class="hljs-title">UpperRightCornered</span>, <span class="hljs-title">Scalable</span> </span>&#123;<br>    <span class="hljs-comment">// 实现所有接口中的全部抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-5-默认方法"><a href="#2-2-5-默认方法" class="headerlink" title="2.2.5 默认方法"></a>2.2.5 默认方法</h3><p>Java 8 出现后，接口中可以实现可选的默认方法</p><p>目的是在接口中添加新方法时，不会出现实现该接口的类中没有实现添加的新方法而导师编译错误，从而更好地实现向后兼容</p><p><strong>默认方法的特性</strong></p><ul><li>实现接口的类可以（但不是必须）实现默认方法</li><li>如果实现接口的类实现了默认方法，那么将调用这个类中实现的方法（覆盖接口中的默认方法）</li><li>如果找不到其他实现，那么将调用接口的默认方法</li></ul><h3 id="2-2-6-标记接口"><a href="#2-2-6-标记接口" class="headerlink" title="2.2.6 标记接口"></a>2.2.6 标记接口</h3><p><strong>标记接口是定义为全空的接口</strong></p><ul><li>标记接口提供了额外的信息。类实现这种接口时只需在 implements 子句中列出这个接口，而不用实现任何方法</li><li><code>java.io.Serializable</code> 接口就是标记接口。实现 <code>Serializable</code> 接口的类告诉 <code>ObjectOutputStream</code> 类，这个类的实例可以安全地序列化</li><li><code>java.util.RandomAccess</code> 接口也是标记接口。<code>java.util.List</code> 接口实现了这个接口，表明 <code>java.util.List</code> 接口支持随机访问。例如，<code>ArrayList</code> 类实现了 <code>RandomAccess</code> 接口，而 <code>LinkedList</code> 类没实现</li></ul><h2 id="2-3-泛型"><a href="#2-3-泛型" class="headerlink" title="2.3 泛型"></a>2.3 泛型</h2><h3 id="2-3-1-初识泛型"><a href="#2-3-1-初识泛型" class="headerlink" title="2.3.1 初识泛型"></a>2.3.1 初识泛型</h3><p>容器类型一般叫作 <strong>「泛型」</strong>，容器中保存的 <strong>「负载类型」</strong> 在尖括号 <strong>&lt;&gt;</strong> 中指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">box</span><span class="hljs-params">(T t)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">unbox</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>容器中实际保存的是负载类型（引用类型）的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;CenteredCircle&gt; shapes = <span class="hljs-keyword">new</span> ArrayList&lt;CenteredCircle&gt;();<br>shapes.add(<span class="hljs-keyword">new</span> CenteredCircle(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>));<br><br><span class="hljs-comment">// 编译出错，因为 List&lt;CenteredCircle&gt; 中保存的是 CenteredCircle 实例</span><br>shapes.add(<span class="hljs-keyword">new</span> CenteredSquare(<span class="hljs-number">2.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// List&lt;CenteredCircle&gt;::get() 返回一个 CenteredCircle 实例，放大转换无需校正</span><br>CenteredCircle c = shapes.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="2-3-2-类型参数"><a href="#2-3-2-类型参数" class="headerlink" title="2.3.2 类型参数"></a>2.3.2 类型参数</h3><p><strong>&lt;T&gt;</strong>  是负载类型，也是 <strong>「类型参数」</strong>。因此，泛型也被称为 <strong>「参数化类型」</strong>。这表明，容器类型由负载类型参数化</p><p><strong>类型参数只能代表引用类型，类型参数的值不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer 是类型参数的值</span><br>List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="hljs-comment">// 合法，Interger 是 int 的包装类，属于引用类型</span><br>List&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>&gt;();          <span class="hljs-comment">// 不合法</span><br></code></pre></td></tr></table></figure><h3 id="2-3-3-菱形句法"><a href="#2-3-3-菱形句法" class="headerlink" title="2.3.3 菱形句法"></a>2.3.3 菱形句法</h3><p>创建泛型的实例时，推荐使用 <strong>「菱形句法」&lt;&gt;</strong> 省略赋值语句右侧重复的类型参数的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;CenteredCircle&gt; shapes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><h3 id="2-3-4-类型擦除"><a href="#2-3-4-类型擦除" class="headerlink" title="2.3.4 类型擦除"></a>2.3.4 类型擦除</h3><p>通过 <strong>「类型擦除」</strong> 实现 <code>List</code> 和 <code>List&lt;String&gt;</code> 的兼容，非泛型的 <code>List</code> 一般被称为「原始类型」</p><p><strong>擦除类型后只剩下容器的原始类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderCounter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">totalOrders</span><span class="hljs-params">(Map&lt;String, List&lt;String&gt;&gt; orders)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">totalOrders</span><span class="hljs-params">(Map&lt;String, Integer&gt; orders)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>看似合法，但无法编译。因为这两个方法虽然看起来像是常规的重载，但擦除类型后，两个方法的签名都变成了：<code>int totalOrders(Map);</code>。运行时无法通过签名区分这两个方法</li><li>泛型的类型参数仅在编译时可见，在运行时不可见。即 Javac 会擦除类型参数，且在字节码中不体现出来</li></ul><h3 id="2-3-5-通配符"><a href="#2-3-5-通配符" class="headerlink" title="2.3.5 通配符"></a>2.3.5 通配符</h3><p>如果我们不知道对象的负载类型，那么应该怎样实例化对象？</p><p>参数化类型，例如 <code>ArrayList&lt;T&gt;</code>，不能实例化。这是因为 <code>&lt;T&gt;</code> 是类型参数，只是真实类型的占位符。只有为类型参数提供具体的值之后（例如 <code>ArrayList&lt;String&gt;</code>），这个类型才算完整，才能实例化<br><img src="https://s.im5i.com/2021/06/02/eeZqo.png" alt="通配符的子类关系"></p><p><strong>使用 &lt;?&gt; 表示「未知类型」</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;T&gt; mysteryList = unknownList();   <span class="hljs-comment">// 不合法</span><br><br>ArrayList&lt;?&gt; mysteryList = unknownList();   <span class="hljs-comment">// 合法</span><br>Object o = mysteryList.get(<span class="hljs-number">0</span>);<br><br>mysteryList.add(<span class="hljs-keyword">new</span> Object());              <span class="hljs-comment">// 不会编译</span><br></code></pre></td></tr></table></figure><ul><li><code>ArrayList&lt;?&gt;</code> 和 <code>ArrayList&lt;T&gt;</code> 不一样，前者是变量可以使用的完整类型，后者是不能实例化的参数类型</li><li>我们不知道 <code>mysteryList</code> 的负载类型。例如， 如果 <code>mysteryList</code> 是 <code>ArrayList&lt;String&gt;</code> 类型的实例，那么就不能把 <code>Object</code> 对象存入其中</li></ul><p><strong>String 是 Object 的子类型，但 List&lt;String&gt; 不是 List&lt;Object&gt; 的子类型。List&lt;String&gt; 是 List&lt;?&gt; 的子类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(); <span class="hljs-comment">// 不会编译</span><br>List&lt;?&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();      <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><ul><li>如果想让容器的类型具有父子关系，需要使用未知类型</li><li>不管 <code>T</code> 的值是什么，<code>List&lt;?&gt;</code> 都不是 <code>List&lt;T&gt;</code> 的子类型</li></ul><h4 id="1-上界通配符-lt-extend-T-gt"><a href="#1-上界通配符-lt-extend-T-gt" class="headerlink" title="1. 上界通配符 &lt;? extend T&gt;"></a>1. 上界通配符 &lt;? extend T&gt;</h4><p>上界通配符 <code>&lt;? extend T&gt;</code> 匹配 T 及 T 的子类。例如，<code>List&lt;? extend Number&gt;</code> 表示 <code>List</code> 中可以存放 <code>Number</code> 及 <code>Number</code> 的子类的实例（但只能存放一种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(List&lt;? extend NUmber&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> s = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (Number n : list) &#123;<br>            s += n.doubleValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; li = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-string">&quot;sum = &quot;</span> + sum(li));<br>        <br>        List&lt;Double&gt; ld = Arrays.asList(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">2.5</span>);<br>System.out.println(<span class="hljs-string">&quot;sum = &quot;</span> + sum(ld));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>List&lt;? extend T&gt; get 合法，add 不合法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span> </span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Apple 是 Fruit 的子类，List&lt;Apple&gt; 和 List&lt;Fruit&gt; 都是 List&lt; ? extends Fruit&gt; 的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 合法</span><br>    List&lt;? extend Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;();<br>    List&lt;? extend Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br>        <br>        <span class="hljs-comment">// 不合法，必须是 Fruit 或 Fruit 的子类</span><br>    List&lt;? extend Fruit&gt; slist = <span class="hljs-keyword">new</span> ArrayList&lt;Food&gt;();<br>        <br>        <span class="hljs-comment">// get 合法</span><br>        Fruit f = list.get(<span class="hljs-number">0</span>);<br>        Object f = list.get(<span class="hljs-number">0</span>);<br>        Apple f = (Apple) list.get(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// get 不合法</span><br>        Apple f = list.get(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// add 不合法</span><br>        list.add(<span class="hljs-keyword">new</span> Fruit());<br>        list.add(<span class="hljs-keyword">new</span> Apple());<br>        list.add((Fruit) <span class="hljs-keyword">new</span> Fruit());<br>        list.add((Fruit) <span class="hljs-keyword">new</span> Apple());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>get</code> 合法。因为取出的元素可以直接赋给 <code>Fruit</code>（推荐），也可以强制转换为 <code>Fruit</code> 的子类</li><li><code>add</code> 不合法。因为 <code>List&lt;T&gt;</code> 中只能存放一种类型，而 <code>?</code> 具体是什么只有运行时才知道，假设运行时 ? 为 <code>Apple、Banana、Orange</code>（即 <code>new</code> 出的对象），显然不能统一隐式转换为它们的父类 <code>Fruit</code>，因为 <code>List&lt;T&gt;</code> 中存放的必须是 <code>T</code> 或 <code>T</code> 的子类</li></ul><h4 id="2-下界通配符-lt-super-T-gt"><a href="#2-下界通配符-lt-super-T-gt" class="headerlink" title="2. 下界通配符 &lt;? super T&gt;"></a>2. 下界通配符 &lt;? super T&gt;</h4><p>下界通配符 <code>&lt;? super T&gt;</code> 匹配 T 及 T 的父类。例如，<code>List&lt;? super Integer&gt;</code> 表示 <code>List</code> 中可以存放 <code>Integer</code> 及 <code>Integer</code> 的父类的实例（但只能存放一种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Integer&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        list.add(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>List&lt;? super T&gt; add 合法，get 不合法（只能赋给 Object 类，或使用强制转换）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 合法</span><br>    List&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;();<br>    List&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br>        <br>        <span class="hljs-comment">// 不合法，必须是 Fruit 或 Fruit 的父类</span><br>    List&lt;? <span class="hljs-keyword">super</span> Fruit&gt; slist = <span class="hljs-keyword">new</span> ArrayList&lt;Food&gt;();<br>        <br>        <span class="hljs-comment">// add 合法，但必须是 Fruit 或 Fruit 的子类，因为只有这样才能隐式转换为 Fruit 的对象</span><br>        list.add(<span class="hljs-keyword">new</span> Fruit);<br>        list.add(<span class="hljs-keyword">new</span> Apple);<br>        list.add((Fruit) <span class="hljs-keyword">new</span> Food());<span class="hljs-comment">// 强制转换也是可以的</span><br>        <br>        <span class="hljs-comment">// add 不合法</span><br>        list.add(<span class="hljs-keyword">new</span> Food());<br>        <br>        <span class="hljs-comment">// get 合法</span><br>        Object a = list.get(<span class="hljs-number">0</span>);<br>        Fruit a = (Fruit) list.get(<span class="hljs-number">0</span>);<br>        Apple a = (Apple) list.get(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// get 不合法</span><br>        list.add(<span class="hljs-keyword">new</span> Apple());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-无界通配符-lt-gt"><a href="#2-无界通配符-lt-gt" class="headerlink" title="2. 无界通配符 &lt;?&gt;"></a>2. 无界通配符 &lt;?&gt;</h4><p>无界通配符 <code>&lt;?&gt;</code> 实际上是 <code>&lt;? extends Object&gt;</code>，因此所有 <code>List&lt;Integer&gt;、List&lt;Double&gt;</code> 等都是 <code>List&lt;?&gt;</code> 的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Object elem : list)<br>        System.out.print(elem + <span class="hljs-string">&quot; &quot;</span>);<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-通配符的继承关系"><a href="#4-通配符的继承关系" class="headerlink" title="4. 通配符的继承关系"></a>4. 通配符的继承关系</h4><p>箭头表示的继承关系：<code>List&lt;Integer&gt;</code> 是 <code>List&lt;? extends Integer</code> 的子类</p><p><img src="https://s.im5i.com/2021/06/02/eeZqo.png" alt="通配符的继承关系"></p><h3 id="2-3-6-编译时和运行时类型"><a href="#2-3-6-编译时和运行时类型" class="headerlink" title="2.3.6 编译时和运行时类型"></a>2.3.6 编译时和运行时类型</h3><p><code>l</code> 是什么类型？答案取决于在编译时（javac 看到的类型），还是运行时（JVM 看到的类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>System.out.println(l);<br></code></pre></td></tr></table></figure><ul><li>javac 把 <code>l</code> 看成 <code>List-of-String</code> 类型，而且会用这个类型信息仔细检查句法错误，例如不能使用 <code>add()</code> 方法添加不合法的类型</li><li>JVM 把 <code>l</code> 看成 <code>ArrayList</code> 类型的对象。因为编译时 javac 已擦除类型，所以运行时 <code>l</code> 是原始类型</li></ul><p>编译时和运行时的类型稍微有些不同。这个不同点是，运行时类型既比编译时类型精确，又没有编译时类型精确</p><ul><li>运行时类型没有编译时类型精确。因为负载类型的信息被擦除了，运行时的类型只是原始类型</li><li>编译时类型没有运行时类型精确。因为不知道 <code>l</code> 具体是什么类型（只有运行时才知道），只知道是一种和 <code>List</code> 兼容的类型</li></ul><h2 id="2-4-枚举和注解"><a href="#2-4-枚举和注解" class="headerlink" title="2.4 枚举和注解"></a>2.4 枚举和注解</h2><h3 id="2-4-1-枚举"><a href="#2-4-1-枚举" class="headerlink" title="2.4.1 枚举"></a>2.4.1 枚举</h3><p><code>PrimaryColor</code> 类型的实例可以按照静态字段的方式引用：<code>PrimaryColor.RED、PrimaryColor.GREEN、PrimaryColor.BLUE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PrimaryColor</span> </span>&#123;<br>    <span class="hljs-comment">// 实例列表末尾的分号是可选的</span><br>    RED, GREEN, BLUE<br>&#125;<br></code></pre></td></tr></table></figure><p>如果字段或方法有主体，那么实例列表后面必须加上分号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RegularPolygon</span> </span>&#123;<br>    <span class="hljs-comment">// 有参数的枚举必须使用分号</span><br>    TRIANGLE(<span class="hljs-number">3</span>), SQUARE(<span class="hljs-number">4</span>), PENTAGON(<span class="hljs-number">5</span>), HEXAGON(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-keyword">private</span> Shape shape;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> shape;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RegularPolygon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sides)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (sides) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                shape = <span class="hljs-keyword">new</span> Triangle(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">60</span>,<span class="hljs-number">60</span>,<span class="hljs-number">60</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                shape = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                shape = <span class="hljs-keyword">new</span> Pentagon(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">108</span>,<span class="hljs-number">108</span>,<span class="hljs-number">108</span>,<span class="hljs-number">108</span>,<span class="hljs-number">108</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                shape = <span class="hljs-keyword">new</span> Hexagon(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-枚举的特性"><a href="#1-枚举的特性" class="headerlink" title="1. 枚举的特性"></a>1. 枚举的特性</h4><ul><li>枚举都隐式扩展自 <code>java.lang.Enum</code> 类</li><li>可以实现接口</li></ul><h4 id="2-枚举的限制"><a href="#2-枚举的限制" class="headerlink" title="2. 枚举的限制"></a>2. 枚举的限制</h4><ul><li>不能泛型化，不能被扩展</li><li>如果枚举中的所有值都有实现主体，那么只能定义为抽象方法</li><li>只能有一个私有（或使用默认访问权限）的构造方法</li></ul><h3 id="2-4-2-注解"><a href="#2-4-2-注解" class="headerlink" title="2.4.2 注解"></a>2.4.2 注解</h3><p>注解没有直接作用。例如，<code>@Override</code> 只是为注解的方法提供额外的信息，注明这个方法覆盖了超类中的方法。如果开发者把方法的名称拼写错了，而这个方法本来是要覆盖超类的方法，那么，在这个名称拼错的方法上使用 <code>@Override</code> 注解，可以提醒编译器什么地方出错了</p><p><strong>与普通的接口相比，注解的特殊特性</strong></p><h4 id="1-注解的特性"><a href="#1-注解的特性" class="headerlink" title="1. 注解的特性"></a>1. 注解的特性</h4><ul><li>注释都隐式扩展自 <code>java.lang.annotation.Annotation</code> 接口</li><li>接口（包括注解）的所有成员都隐式声明为 <code>public</code></li></ul><h4 id="2-注解的限制"><a href="#2-注解的限制" class="headerlink" title="2. 注解的限制"></a>2. 注解的限制</h4><ul><li>不能泛型化（接口可以泛型化），不能扩展其他接口</li><li>只能定义没有参数的方法</li><li>不能定义会抛出异常的方法</li><li>方法的返回类型有限制，方法可以有一个默认返回值</li></ul><h2 id="2-5-嵌套类型"><a href="#2-5-嵌套类型" class="headerlink" title="2.5 嵌套类型"></a>2.5 嵌套类型</h2><p>嵌套类型有两个独立的目的，但都和封装有关</p><ul><li>如果某个类型需要特别深入地访问另一个类型的内部实现，可以嵌套定义这个类型。作为成员类型的嵌套类型，其访问方式与访问成员变量和方法的方式一样，且能打破封装的规则</li><li>某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。这个类型应该密封在一个小范围内，因为它其实是实现细节的一部分，应该封装在一个系统的其他部分无法接触到的地方</li></ul><p><strong>嵌套类型实现的四种方式</strong></p><p><strong>1. 静态成员类型</strong></p><p>静态成员类型是声明为 <code>static</code> 的成员类型。嵌套的「接口、枚举和注解」都隐式声明为静态成员类型（不管是否使用 <code>static</code> 关键字）</p><p><strong>2. 非静态成员类</strong></p><p>非静态成员类是没有声明为 <code>static</code> 的成员类。只有「类」才能作为非静态成员类型</p><p><strong>2. 局部类</strong></p><p>局部类是在 Java 代码块中定义的类，只在这个块中可见。「<del>接口、枚举和注解</del>」不能定义为局部类型</p><p><strong>2. 匿名类</strong></p><p>匿名类是一种局部类，但没有名称。「<del>接口、枚举和注解</del>」不能定义为匿名类型</p><h3 id="2-5-1-静态成员类型"><a href="#2-5-1-静态成员类型" class="headerlink" title="2.5.1 静态成员类型"></a>2.5.1 静态成员类型</h3><p>静态成员类型是声明为 <code>static</code> 的成员类型。嵌套的「接口、枚举和注解」都隐式声明为静态成员类型（不管是否使用 <code>static</code> 关键字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> a = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 静态成员接口。static 是可选的，因为所有嵌套接口都是静态成员类型</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Linkable</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> b = a;      <span class="hljs-comment">// 静态成员类型只能访问外层类型的「静态成员」</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Linkable node)</span></span>;<br>    &#125;<br><br>    Linkable head;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Linkable node)</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个类实现前面定义的静态成员接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkableInteger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LinkedStack</span>.<span class="hljs-title">Linkable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    LinkedStack.Linkable next;      <span class="hljs-comment">// Linkable 接口声明为 public</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkableInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> LinkedStack.<span class="hljs-function">Linkable <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(LinkedStack.Linkable node)</span> </span>&#123;<br>        next = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>允许（但不推荐）使用 <code>import</code> 直接或间接导入静态成员类型。导入后，虽然引用嵌套类型时可以直接使用 <code>Linkable</code>，但丢失了一定的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> pkg.LinkedStack.Linkable;<br><span class="hljs-keyword">import</span> pkg.LinkedStack.*;<br></code></pre></td></tr></table></figure><h4 id="1-静态成员类型的特性"><a href="#1-静态成员类型的特性" class="headerlink" title="1. 静态成员类型的特性"></a>1. 静态成员类型的特性</h4><ul><li>静态成员类型类似于类的其他静态成员：静态字段和静态方法</li><li>静态成员类型使用其他静态成员时，无需使用所在类型的名称限定成员的名称</li><li>嵌套的「接口、枚举和注解」都隐式声明为静态成员类型（不管是否使用 <code>static</code> 关键字）</li><li>接口（包括注解）的所有成员都隐式声明为 <code>public</code>，所以嵌套在接口或注解中的静态成员类型不能声明为 <code>protected</code> 或 <code>private</code></li></ul><h4 id="2-静态成员类型的限制"><a href="#2-静态成员类型的限制" class="headerlink" title="2. 静态成员类型的限制"></a>2. 静态成员类型的限制</h4><ul><li><p>静态成员类型和所在类的任何实例都不关联（即没有 <code>this</code> 对象）</p></li><li><p>静态成员类型只能在「顶层类型、其他静态成员类型」中定义，不能在其他嵌套类型中定义</p></li><li><p>静态成员类型的代码只能访问外层类型的「静态成员」（包括私有成员和其他静态成员类型）</p></li><li><p>但是，导入嵌套类型模糊了这个类型和外层类型之间的关系，而这种关系往往很重要，因此很少这么做</p></li></ul><h3 id="2-5-2-非静态成员类"><a href="#2-5-2-非静态成员类" class="headerlink" title="2.5.2 非静态成员类"></a>2.5.2 非静态成员类</h3><p>非静态成员类是没有声明为 <code>static</code> 的成员类，只有「类」才能作为非静态成员类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> </span>&#123;<br>    <span class="hljs-comment">// 静态成员接口，隐式声明为 static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Linkable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Linkable node)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Linkable head;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Linkable node)</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 返回一个 Iterator 对象，供 LinkedStack 类使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;Linkable&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedIterator();<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个非静态成员类实现 Iterator 接口</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Linkable</span>&gt; </span>&#123;<br>        Linkable current;<br><br>        <span class="hljs-comment">// 非静态成员类的代码可以访问外层类型的所有字段和方法（静态和非静态的都能访问，不管是否声明为 private）</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedIterator</span><span class="hljs-params">()</span> </span>&#123;<br>            current = head;                         <span class="hljs-comment">// 隐式引用</span><br>            <span class="hljs-comment">// 因为成员类不能和任何外层类同名，所以，引用外层实例时，推荐在 this 前面使用外层类名</span><br>            <span class="hljs-keyword">this</span>.current = LinkedStack.<span class="hljs-keyword">this</span>.head;   <span class="hljs-comment">// 显式引用（推荐）</span><br>        &#125;<br><br>        <span class="hljs-comment">// 实现 Iterator 接口的方法</span><br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">// 注解</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> current != <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.util.NoSuchElementException();<br>            &#125;<br>            Linkable value = current;<br>            current = current.getNext();<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>非静态成员类和类的任何成员一样，可以使用一个标准的访问控制修饰符。例如，<code>LinkedIterator</code> 类声明为 <code>protected</code>，所以使用 <code>LinkedStack</code> 类的代码（不同包）不能访问 <code>LinkedIterator</code> 类，但是 <code>LinkedStack</code> 的子类可以访问（不管是否与 <code>LinkedStack</code> 同包）</li></ul><h4 id="1-非静态成员类的特性"><a href="#1-非静态成员类的特性" class="headerlink" title="1. 非静态成员类的特性"></a>1. 非静态成员类的特性</h4><ul><li>如果把「静态成员类型」比作类字段或类方法，那么「非静态成员类」可以比作实例字段或实例方法</li><li>一个非静态成员类的实例始终关联一个外层类型的实例</li><li>非静态成员类的代码可以访问外层类型的所有成员（包括私有成员、静态成员和非静态成员）</li></ul><h4 id="2-非静态成员类的限制"><a href="#2-非静态成员类的限制" class="headerlink" title="2. 非静态成员类的限制"></a>2. 非静态成员类的限制</h4><ul><li>非静态成员类不能和任何外层类或包同名。这是一个重要的规则，但不适用于字段和方法</li><li>非静态成员类不能包含任何 「<del>静态字段、方法或类型</del>」，但可以包含同时声明为 <code>static</code> 和 <code>final</code> 的常量字段</li></ul><h4 id="3-两种独立的层次结构"><a href="#3-两种独立的层次结构" class="headerlink" title="3. 两种独立的层次结构"></a>3. 两种独立的层次结构</h4><p>第一种是从「超类到子类」的 <strong>「继承层次结构」</strong>，定义成员类继承的字段和方法<br>第二种是从「外层类到内层类」的 <strong>「包含层次结构」</strong>，定义在成员类作用域中的字段和方法</p><ul><li>这两种层次结构完全相互独立，一定不能混淆</li><li>避免命名冲突，即超类的字段或方法不能和外层类的字段或方法同名</li><li>如果出现了命名冲突，那么继承的字段或方法取代外层类的同名字段或方法</li><li>继承的字段和方法作用域在继承它们的类中，会取代外层作用域中的同名字段和方法</li><li>为了避免混淆继承层次结构和包含层次结构，包含层次结构不要太深</li><li>如果类嵌套超过两层，可能导致更大的混乱</li><li>如果类的继承层次结构很深（即有很多祖先），可以考虑不把它定义为非静态成员类，而是定义为顶层类</li></ul><h3 id="2-5-3-局部类"><a href="#2-5-3-局部类" class="headerlink" title="2.5.3 局部类"></a>2.5.3 局部类</h3><p>局部类在一个 Java 代码块中声明，不是类的成员，只有「类」才能局部定义。「<del>接口、枚举和注解</del>」不能局部定义</p><p><strong>局部类通常在方法中定义</strong>，但也可以在类的静态初始化程序或实例初始化程序中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> </span>&#123;<br>    <span class="hljs-comment">// 静态成员接口，隐式声明为 static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Linkable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Linkable node)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Linkable head;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Linkable node)</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// ---------------------- 局部类通常在方法中定义 -------------------</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;Linkable&gt; <span class="hljs-title">Iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 局部类不能声明为 public、protected、private 或 static</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Linkable</span>&gt; </span>&#123;<br>            Linkable current;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedIterator</span><span class="hljs-params">()</span> </span>&#123;<br>                current = head;                         <span class="hljs-comment">// 隐式引用</span><br>                <span class="hljs-keyword">this</span>.current = LinkedStack.<span class="hljs-keyword">this</span>.head;   <span class="hljs-comment">// 显式引用（推荐）</span><br>            &#125;<br><br>            <span class="hljs-comment">// 实现 Iterator 接口的方法</span><br>            <span class="hljs-meta">@Override</span>                                   <span class="hljs-comment">// 注解（覆盖接口的实例方法）</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> current != <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.util.NoSuchElementException();<br>                &#125;<br>                Linkable value = current;<br>                current = current.getNext();<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedIterator();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        Iterator&lt;Linkable&gt; it = Iterator();<br>        it.hashNext();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-局部类的特性"><a href="#1-局部类的特性" class="headerlink" title="1. 局部类的特性"></a>1. 局部类的特性</h4><ul><li>与成员类（静态和非静态）一样，局部类的代码可以访问外层类型的所有字段和方法（静态和非静态的都能访问，不管是否声明为 <code>private</code>）</li><li>局部类访问的「局部方法」中的「局部变量、方法参数和常参数」都隐式声明为 <code>final</code>，局部类访问后都不能被修改</li><li><strong>因为，局部类对象的生命周期可能比它所在局部方法的生命周期长。如果局部类中使用了局部方法中的普通变量，当创建完局部类对象后（退出局部方法），局部类对象不能再访问局部方法中的非 final 变量，而 final 变量存放在常量区，其作用域在定义它的局部方法之外仍有效</strong></li><li>局部类用到的每个局部变量都有一个私有副本（这些副本由 javac 自动生成）。因此，局部类没有访问局部变量，真正访问的是局部变量的私有副本，只有 <code>final</code> 局部变量才能保证局部变量和私有副本始终保持一致</li></ul><h4 id="2-局部类的限制"><a href="#2-局部类的限制" class="headerlink" title="2. 局部类的限制"></a>2. 局部类的限制</h4><ul><li>局部类不能声明为 <code>public、protected、private、static</code></li><li>局部类的名称只存在于定义它的块中，在块的外部不能使用。但在类的作用域中创建的局部类实例，在这个作用域之外仍能使用</li><li>与成员类一样，局部类不能包含任何 「<del>静态字段、方法或类型</del>」。但可以包含同时声明为 <code>static final</code> 的常量字段</li><li>局部类和成员类一样，不能与任何外层类同名</li></ul><h4 id="2-局部类的作用域"><a href="#2-局部类的作用域" class="headerlink" title="2. 局部类的作用域"></a>2. 局部类的作用域</h4><p>局部类可以访问的字段和变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> b = <span class="hljs-string">&#x27;b&#x27;</span>; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> d = <span class="hljs-string">&#x27;d&#x27;</span>;<br><br>   <span class="hljs-comment">// 嵌套的「接口、枚举和注解」都隐式声明为静态成员类型，不管是否使用 static 关键字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IntLocal</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;           <span class="hljs-comment">// 接口（包括注解）的所有成员都隐式声明为 public</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IntLocal <span class="hljs-title">createLocal</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> e)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> f = <span class="hljs-string">&#x27;f&#x27;</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Local</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IntLocal</span> </span>&#123;<br>            <span class="hljs-keyword">char</span> g = <span class="hljs-string">&#x27;g&#x27;</span>;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(a);      <span class="hljs-comment">// C.this.a --- 外层类继承的实例字段</span><br>                System.out.println(b);      <span class="hljs-comment">// this.b ----- 这个类继承的实例字段</span><br>                System.out.println(c);      <span class="hljs-comment">// C.this.c --- 外层类的实例字段</span><br>                System.out.println(d);      <span class="hljs-comment">// C.d -------- 外层类的类字段</span><br>                System.out.println(e);      <span class="hljs-comment">// e ---------- 声明为 final 的局部参数</span><br>                System.out.println(f);      <span class="hljs-comment">// f ---------- 声明为 final 的局部变量</span><br>                System.out.println(g);      <span class="hljs-comment">// this.g ----- 这个类的实例字段</span><br>                System.out.println(i);      <span class="hljs-comment">// i ---------- 局部方法的局部变量</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 局部变量 i 在局部类中被访问，因此 i 被隐式声明为 final，以后都不能再被修改</span><br>        i = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 不必显示转换 return (IntLocal) new Local();</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Local();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> e = <span class="hljs-string">&#x27;e&#x27;</span>;<br>        IntLocal loc = createLocal(e);<br>        loc.print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        c.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-4-匿名类"><a href="#2-5-4-匿名类" class="headerlink" title="2.5.4 匿名类"></a>2.5.4 匿名类</h3><p><strong>匿名类是没有名称的局部类</strong>，局部类是 Java 代码块中的一个语句，而匿名类是一个表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> </span>&#123;<br>    <span class="hljs-comment">// 静态成员接口，隐式声明为 static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Linkable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Linkable node)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Linkable head;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Linkable node)</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// ---------------------- 匿名类在 return 语句中定义 -------------------</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;Linkable&gt; <span class="hljs-title">Iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义匿名类时，在父类后面的括号中指定的参数，会隐式传给父类的构造方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;Linkable&gt;() &#123;<br>            Linkable current;<br><br>            <span class="hljs-comment">// 匿名类没有名称，因此不能定义构造方法。把构造方法换成实例初始化程序</span><br>            &#123; current = head; &#125;<br><br>            <span class="hljs-comment">// 实现 Iterator 接口的方法</span><br>            <span class="hljs-meta">@Override</span>   <span class="hljs-comment">// 注解（覆盖接口的实例方法）</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> current != <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Linkable <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.util.NoSuchElementException();<br>                &#125;<br>                Linkable value = current;<br>                current = current.getNext();<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>            &#125;<br>        &#125;;  <span class="hljs-comment">// 注意，需要使用分号，结束 return 语句</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        Iterator&lt;Linkable&gt; it = Iterator();<br>        it.hashNext();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-匿名类的特性"><a href="#1-匿名类的特性" class="headerlink" title="1. 匿名类的特性"></a>1. 匿名类的特性</h4><ul><li>匿名类使用 <code>new</code> 运算符同时声明和实例化一个类。Java 8 之后，大多数情况下都把匿名类换成了 <code>lambda</code> 表达式</li><li>定义匿名类时，在父类后面的括号中指定的参数，会隐式传给父类的构造方法</li><li>匿名类一般用于创建构造方法不接受任何参数的简单类的子类。所以，在定义匿名类的句法中，括号经常都是空的</li></ul><h4 id="2-匿名类的限制"><a href="#2-匿名类的限制" class="headerlink" title="2. 匿名类的限制"></a>2. 匿名类的限制</h4><ul><li>匿名类没有名称，因此不能定义构造方法。如果类需要构造方法，必须使用局部类。也可以把构造方法换成实例（或静态）初始化程序，详见 2.2.4 节</li><li>虽然实例（或静态）初始化程序不局限于在匿名类中使用，但就是因为在匿名类中不能定义构造方法才引入 Java 的</li><li>匿名类无法指定 <code>extends</code> 子句和 <code>implements</code> 子句</li><li>匿名类就是一种局部类，与局部类和成员类一样。匿名类不能包含任何 「<del>静态字段、方法或类型</del>」。但可以包含同时声明为 <code>static final</code> 的常量字段</li><li>与局部类一样，匿名类不能声明为 <code>public、private、protected、static</code></li><li>定义匿名类的同时实例化了这个类。如果每次执行外层块时创建的实例不止一个，那么就不能用匿名类代替局部类</li></ul><h3 id="2-5-5-嵌套类型的运作方式"><a href="#2-5-5-嵌套类型的运作方式" class="headerlink" title="2.5.5 嵌套类型的运作方式"></a>2.5.5 嵌套类型的运作方式</h3><p>引入嵌套类型后，Java 虚拟机和 Java 类文件的格式并没有变化。对 Java 解释器而言，并没有所谓的嵌套类型，所有类都是普通的顶层类。</p><p>为了让嵌套类型看起来是在另一个类中定义的，Java 编译器会在它生成的类中插入 「隐藏字段、方法和构造方法参数」。这些隐藏字段和方法经常称为 <strong>「合成物」</strong>。可以使用反汇编程序 javap 反汇编某些嵌套类型的类文件</p><p>在第一个 <code>LinkedStack</code> 类的示例中，定义了一个 <code>Linkable</code> 的静态成员接口。编译这个 <code>LinkedStack</code> 类时，编译器会生成两个类文件：第一个是预期的 <code>LinkedStack.class</code>；第二个类文件名为 <code>LinkedStack$Linkable.class</code>，其中，<code>$</code> 由 javac 自动插入。这个类文件中包含静态成员接口 <code>Linkable</code> 的实现</p><p>因为嵌套类型编译成普通的顶层类，所以不能直接访问外层类型中有特定权限的成员。因此，如果静态成员类型使用了外层类型的私有成员（或具有其他权限的成员），编译器会生成合成的访问方法（具有默认的包访问权限），然后把访问私有成员的表达式转换成调用合成方法的表达式</p><h4 id="1-四种嵌套类型的类文件的命名规约"><a href="#1-四种嵌套类型的类文件的命名规约" class="headerlink" title="1. 四种嵌套类型的类文件的命名规约"></a>1. 四种嵌套类型的类文件的命名规约</h4><h5 id="（1）静态或非静态成员类型"><a href="#（1）静态或非静态成员类型" class="headerlink" title="（1）静态或非静态成员类型"></a>（1）静态或非静态成员类型</h5><p>根据 <code>EnclosingType$Member.class</code> 格式命名成员类型的类文件</p><h5 id="（2）匿名类"><a href="#（2）匿名类" class="headerlink" title="（2）匿名类"></a>（2）匿名类</h5><p>匿名类没有名称，所以类文件的名称由实现细节决定。Oracle/OpenJDK 中的 javac 使用数字表示匿名类的名称。例如 <code>EnclosingType$1.class</code></p><h5 id="（3）局部类"><a href="#（3）局部类" class="headerlink" title="（3）局部类"></a>（3）局部类</h5><p>局部类的类文件综合使用前两种方式命名。例如 <code>EnclosingType$1Member.class</code></p><h4 id="2-为每种嵌套类型提供合成访问能力"><a href="#2-为每种嵌套类型提供合成访问能力" class="headerlink" title="2. 为每种嵌套类型提供合成访问能力"></a>2. 为每种嵌套类型提供合成访问能力</h4><h5 id="（1）非静态成员类的实现"><a href="#（1）非静态成员类的实现" class="headerlink" title="（1）非静态成员类的实现"></a>（1）非静态成员类的实现</h5><p>非静态成员类的每个实例都和一个外层类的实例关联</p><p>为了实现这种关联，编译器为每个成员类定义了一个名为 <code>this$0</code> 的合成字段，用于保存一个外层实例的引用。编译器为每个非静态成员类的构造方法提供了一个额外的参数，用于初始化这个字段。每次调用成员类的构造方法时，编译器都会自动把这个额外参数的值设为外层类的引用</p><h5 id="（2）局部类和匿名类的实现"><a href="#（2）局部类和匿名类的实现" class="headerlink" title="（2）局部类和匿名类的实现"></a>（2）局部类和匿名类的实现</h5><p>局部类之所以能访问外层类的字段和方法，原因和非静态成员类一模一样。编译器把一个外层类的隐藏引用传入局部类的构造方法，并且把这个引用存储在编译器合成的一个私有字段中</p><p>和非静态成员类一样，局部类也能使用外层类的私有字段和方法，因为编译器会插入任何所需的访问器方法</p><h2 id="2-6-代理"><a href="#2-6-代理" class="headerlink" title="2.6 代理"></a>2.6 代理</h2><h3 id="2-6-1-何时使用代理"><a href="#2-6-1-何时使用代理" class="headerlink" title="2.6.1 何时使用代理"></a>2.6.1 何时使用代理</h3><p>假设有一个表示接口的对象，它的确切类型在编译时无法知道。要想构造一个实现这些接口的类，就需要使用 <code>newlnstance</code> 方法或「反射」找出这个类的构造器</p><p>但是，接口不能实例化，需要在程序处于运行状态时定义一个新类</p><p>为了解决这个问题，有些程序将会生成代码；将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。显然，这样做的速度会比较慢，并且需要将编译器与程序放在一起</p><p><strong>「代理」</strong>是一种更好的解决方案。代理类可以在运行时创建全新的类，代理类能够实现指定接口（通常是 <code>InvocationHandler</code> 接口）。代理类具有以下方法：</p><ul><li>接口中的全部抽象方法</li><li><code>Object</code> 类中的全部方法。例如，<code>toString、equals</code></li></ul><p>然而，不能在运行时定义这些方法的新代码，而是提供一个调用处理器。<strong>「调用处理器」</strong>是实现了 <code>InvocationHandler</code> 接口的类对象。这个接口中只有一个抽象方法 <code>invoke</code> </p><p><strong>代理的用途</strong></p><ul><li>路由对远程服务器的方法调用</li><li>在程序运行期间，将用户接口事件与动作关联起来</li><li>调试，跟踪方法调用</li></ul><h3 id="2-6-2-创建代理对象"><a href="#2-6-2-创建代理对象" class="headerlink" title="2.6.2 创建代理对象"></a>2.6.2 创建代理对象</h3><p>使用 <code>Proxy</code> 类的 <code>newProxylnstance</code> 方法创建一个代理对象，该方法包含三个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class[] interfaces = <span class="hljs-keyword">new</span> Class[]&#123;Comparable.class&#125;;<br>InvocationHandler handler = <span class="hljs-keyword">new</span> TraceHandler(value);<span class="hljs-comment">// TraceHandler：实现了 InvocationHandler 接口的类</span><br>Object proxy = Proxy.newProxyInstance(<span class="hljs-keyword">null</span>, interfaces, handler);<br></code></pre></td></tr></table></figure><ul><li>类加载器：Java 安全模型的一部分，对于系统类和从因特网上下载下来的类，可以使用不同的类加载器。目前，用 <code>null</code> 表示使用默认的类加载器</li><li><code>Class</code> 对象数组：每个元素都是需要实现的接口</li><li>调用处理器 <code>hander</code></li></ul><h3 id="2-6-3-跟踪二分查找的方法调用"><a href="#2-6-3-跟踪二分查找的方法调用" class="headerlink" title="2.6.3 跟踪二分查找的方法调用"></a>2.6.3 跟踪二分查找的方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraceHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.print(target);<br>        System.out.print(<span class="hljs-string">&quot;.&quot;</span> + method.getName() + <span class="hljs-string">&quot;(&quot;</span>);<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                System.out.print(args[i]);<br>                <span class="hljs-keyword">if</span> (i &lt; args.length - <span class="hljs-number">1</span>) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-keyword">return</span> method.invoke(target, args);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TraceHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object[] nums = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            Integer value = i + <span class="hljs-number">1</span>;<br>            Class[] interfaces = <span class="hljs-keyword">new</span> Class[]&#123;Comparable.class&#125;;<br>            <span class="hljs-comment">// 调用处理器</span><br>            InvocationHandler handler = <span class="hljs-keyword">new</span> TraceHandler(value);<br>            Object proxy = Proxy.newProxyInstance(<span class="hljs-keyword">null</span>, interfaces, handler);<br>            nums[i] = proxy;<br>        &#125;<br><br>        Integer key = <span class="hljs-keyword">new</span> Random().nextInt(nums.length) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = Arrays.binarySearch(nums, key);<br>        <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;key:\t&quot;</span> + nums[res]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">500.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">250.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">125.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">187.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">218.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">202.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">194.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">190.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">192.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">191.</span>compareTo(<span class="hljs-number">191</span>)<br><span class="hljs-number">191.</span>toString()<br>key:<span class="hljs-number">191</span><br></code></pre></td></tr></table></figure><ul><li>代理对象 <code>proxy</code> 是在运行时创建的代理类（如 <code>$ProxyO</code> ) 的对象，这个类也实现了 <code>Comparable</code> 接口，它的 <code>compareTo</code> 方法调用了代理处理器的 <code>invoke</code> 方法，这个方法打印出了方法名和参数，之后用包装好的 <code>Integer</code> 对象 <code>value</code> 调用 <code>compareTo</code></li><li>所有的代理类都扩展自 <code>Proxy</code> 类。一个代理类只有一个实例域（调用处理器），它定义在 <code>Proxy</code> 的超类中。为了履行代理对象的职责， 所需的任何数据都必须存储在调用处理器中。例如，代理 <code>Comparable</code> 对象时，<code>TraceHandler</code> 包装了实际的对象</li><li>所有的代理类都覆盖了 <code>Object</code> 类中的方法 <code>toString、equals、hashCode</code>。和所有的代理方法一样， 这些方法仅仅调用了调用处理器的 <code>invoke</code> 方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口</tag>
      
      <tag>泛型</tag>
      
      <tag>枚举和注解</tag>
      
      <tag>嵌套类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 基础操作</title>
    <link href="/2021/05/15/Git/gitee_depositary/"/>
    <url>/2021/05/15/Git/gitee_depositary/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-基础知识"><a href="#Git-基础知识" class="headerlink" title="Git 基础知识"></a>Git 基础知识</h2><h3 id="Git-四大区域"><a href="#Git-四大区域" class="headerlink" title="Git 四大区域"></a>Git 四大区域</h3><p><img src="https://s.im5i.com/2021/05/15/9akqo.jpg" alt="Git common commands"></p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：本地仓库或版本库</li><li>remote repository：远程仓库</li></ul><h2 id="上传本地项目至-Gitee"><a href="#上传本地项目至-Gitee" class="headerlink" title="上传本地项目至 Gitee"></a>上传本地项目至 Gitee</h2><h3 id="Git-全局设置"><a href="#Git-全局设置" class="headerlink" title="Git 全局设置"></a>Git 全局设置</h3><p>某账号下所有的 Git 仓库都有效（推荐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;your username&quot;<br>git config --global user.email &quot;your email&quot;<br></code></pre></td></tr></table></figure><p>只对当前 Git 仓库有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --local user.name &quot;your username&quot;<br>git config --local user.email &quot;your email&quot;<br></code></pre></td></tr></table></figure><h3 id="创建远程-Git-仓库"><a href="#创建远程-Git-仓库" class="headerlink" title="创建远程 Git 仓库"></a>创建远程 Git 仓库</h3><p>打开 Gitee 官网，登录账号，点击右上角的 <strong>+**，然后进入下方的 **「新建仓库」</strong> 界面</p><p><img src="https://s.im5i.com/2021/05/15/9aC6W.png" alt="Build depositary"></p><h3 id="新建一个本地项目并上传至-Git-仓库"><a href="#新建一个本地项目并上传至-Git-仓库" class="headerlink" title="新建一个本地项目并上传至 Git 仓库"></a>新建一个本地项目并上传至 Git 仓库</h3><h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><table><thead><tr><th>__ java</th></tr></thead></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git">mkdir Blog<br>cd Blog<br>git init<br>touch README.md<br>git add .<br>git commit -m &quot;first commit&quot;<br>git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;docker-rain&#x2F;MarkDown-Blog<br>git push -u origin master<br></code></pre></td></tr></table></figure><h4 id="修改本地并再次上传"><a href="#修改本地并再次上传" class="headerlink" title="修改本地并再次上传"></a>修改本地并再次上传</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">touch new.md<br>git add .<br>git commit -m &quot;add a new.md&quot;<br>git push                    &#x2F;&#x2F; 前面用了 -u，后面都可以省略<br></code></pre></td></tr></table></figure><h4 id="在上一次的提交基础上修改提交信息"><a href="#在上一次的提交基础上修改提交信息" class="headerlink" title="在上一次的提交基础上修改提交信息"></a>在上一次的提交基础上修改提交信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">touch new.md<br>git add .<br>git commit --amend          &#x2F;&#x2F; 在 vim 中可修改上次和本次的提交信息<br>git push -f                 &#x2F;&#x2F; 强制推送<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>第一次上传至远程 Git 仓库时，需保证 Git 仓库为空（否则建议 <code>-f</code> 强制推送）</li><li><code>git push -u origin master</code> 中的 <code>master</code> 是本地和远程的分支名，可通过 <code>git branch</code> 查看本地分支名</li><li>若远程没有 <code>master</code> 分支，则会新创建一个 <code>master</code> 分支，并将本地项目上传至该分支中</li><li>通常 <code>master</code> 分支为默认分支，也可修改默认分支</li></ul><h3 id="上传本地已有项目至-Git-仓库"><a href="#上传本地已有项目至-Git-仓库" class="headerlink" title="上传本地已有项目至 Git 仓库"></a>上传本地已有项目至 Git 仓库</h3><h4 id="在项目文件夹中右键打开-Git-Bash"><a href="#在项目文件夹中右键打开-Git-Bash" class="headerlink" title="在项目文件夹中右键打开 Git Bash"></a>在项目文件夹中右键打开 Git Bash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br>git add .<br>git commit -m &quot;first commit&quot;<br>git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;docker-rain&#x2F;MarkDown-Blog<br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="修改提交的单个文件大小"><a href="#修改提交的单个文件大小" class="headerlink" title="修改提交的单个文件大小"></a>修改提交的单个文件大小</h3><p>Github 中单个文件的大小限制是 100MB，修改至 500MB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global http.postBuffer 524288000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章 类和对象</title>
    <link href="/2021/05/15/Java/%E7%AC%AC1%E7%AB%A0%20%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/05/15/Java/%E7%AC%AC1%E7%AB%A0%20%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-定义类"><a href="#1-1-定义类" class="headerlink" title="1.1 定义类"></a>1.1 定义类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span> </span>&#123;<br>    <span class="hljs-comment">// 这里是类的成员</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code> 关键字前面可以放修饰符关键字或注解</li><li>如果类扩展其他类，类名后面要加上 <code>extends</code> 关键字和要扩展的类名</li><li>如果类实现一个或多个接口，类名或 <code>extends</code> 子句之后要加上 <code>implements</code> 关键字和用逗号分隔的接口名</li></ul><h2 id="1-2-字段和方法"><a href="#1-2-字段和方法" class="headerlink" title="1.2 字段和方法"></a>1.2 字段和方法</h2><h3 id="1-2-1-类成员和实例成员"><a href="#1-2-1-类成员和实例成员" class="headerlink" title="1.2.1 类成员和实例成员"></a>1.2.1 类成员和实例成员</h3><ul><li>类成员（静态成员）：关联在类自身上。包括使用 <code>static</code> 字段修饰的类字段（全局变量）和类方法（全局方法）。类外调用时，类名.类成员</li><li>实例成员：关联在类的单个实例（对象）上。包括未使用 <code>static</code> 字段修饰的实例字段和实例方法</li></ul><h3 id="1-2-2-注意"><a href="#1-2-2-注意" class="headerlink" title="1.2.2 注意"></a>1.2.2 注意</h3><ul><li>类方法只能使用「类字段和类方法」，实例方法可以使用「类字段、类方法、实例字段和实例方法」</li><li>类方法不能使用实例字段或实例方法，因为类方法不关联在类的实例身上，即没有 <code>this</code> 引用指向当前对象</li><li>实例字段和实例方法必须通过 <code>this</code> 引用调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> X = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 类字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;               <span class="hljs-comment">// 实例字段</span><br><br>    <span class="hljs-comment">// 类方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_X</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(X);      <span class="hljs-comment">// 类方法调用类字段</span><br>        <span class="hljs-keyword">int</span> tmp_X = get_X();        <span class="hljs-comment">// 类方法调用类方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_X</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-keyword">return</span> X;                 <span class="hljs-comment">// 类方法调用类字段</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法 ---- 隐藏一个指向调用对象的 this 引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_y</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(X);      <span class="hljs-comment">// 实例方法调用类字段，也可以 this.X</span><br>        <span class="hljs-keyword">int</span> tmp_X = get_X();        <span class="hljs-comment">// 实例方法调用类方法，也可以 this.get_X()</span><br><br>        System.out.println(y);      <span class="hljs-comment">// 实例方法调用实例字段，也可以 this.y</span><br>        <span class="hljs-keyword">int</span> tmp_y = get_y();        <span class="hljs-comment">// 实例方法调用实例方法，也可以 this.get_y()</span><br><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_y</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// 实例方法调用实例字段</span><br>        <span class="hljs-keyword">return</span> y;                   <span class="hljs-comment">// 也可以是 this.y</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-创建并初始化对象"><a href="#1-3-创建并初始化对象" class="headerlink" title="1.3 创建并初始化对象"></a>1.3 创建并初始化对象</h2><h3 id="1-3-1-构造方法"><a href="#1-3-1-构造方法" class="headerlink" title="1.3.1 构造方法"></a>1.3.1 构造方法</h3><ul><li>构造方法的名称始终和类名一样</li><li>声明构造方法时不指定返回值类型，连 <code>void</code> 都不用</li><li>构造方法的主体初始化对象。可以把主体的作用想象为设定 <code>this</code> 引用的内容</li><li>构造方法不能返回 <code>this</code> 引用或任何其他值</li></ul><h3 id="1-3-2-多个构造方法"><a href="#1-3-2-多个构造方法" class="headerlink" title="1.3.2 多个构造方法"></a>1.3.2 多个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123;<br>    r = <span class="hljs-number">1.0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.r = r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-3-this：在一个构造方法中调用另一个构造方法"><a href="#1-3-3-this：在一个构造方法中调用另一个构造方法" class="headerlink" title="1.3.3 this：在一个构造方法中调用另一个构造方法"></a>1.3.3 this：在一个构造方法中调用另一个构造方法</h3><p>在一个构造方法中可以使用 <code>this</code> 关键字调用同一个类中的另一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> X = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 类字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;               <span class="hljs-comment">// 实例字段</span><br><br>    <span class="hljs-comment">// 构造方法 ---- 创建对象时初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-comment">// Solution obj = new Solution(10)</span><br>        <span class="hljs-keyword">this</span>.y = y;                 <span class="hljs-comment">// 实例字段 y = 10</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">// Solution obj = new Solution()</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">3</span>);                    <span class="hljs-comment">// 实例字段 y = 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果一些构造方法共用大量的初始化代码，这种技术是有用的，因为能避免代码重复</li><li>如果构造方法执行很多初始化操作，在这种复杂的情况下，这种技术十分有用</li><li><strong>使用 this() 时有个重大的限制：</strong> 只能出现在构造方法的第一个语句中</li></ul><h3 id="1-3-4-字段的默认值和初始化程序"><a href="#1-3-4-字段的默认值和初始化程序" class="headerlink" title="1.3.4 字段的默认值和初始化程序"></a>1.3.4 字段的默认值和初始化程序</h3><h4 id="1-字段的默认值"><a href="#1-字段的默认值" class="headerlink" title="1. 字段的默认值"></a>1. 字段的默认值</h4><p>类中的字段不一定要初始化。如果没有指定初始值，字段自动使用默认值初始化：<code>false、\u0000、0、0.0、null</code></p><h4 id="2-初始化程序"><a href="#2-初始化程序" class="headerlink" title="2. 初始化程序"></a>2. 初始化程序</h4><p>实例字段声明不是任何方法的一部分。Javac 会自动为实例字段生成「实例初始化代码」。<strong>这些实例初始化代码按照「实例字段在源码中出现的顺序」插入构造方法。</strong> 因此，实例字段的实例初始化代码可以使用在其之前声明的任何字段的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] table = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleClass</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            table[i] = i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Javac 生成的构造方法和下述代码等效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleClass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 实例初始化代码按照「实例字段在源码中出现的顺序」插入构造方法</span><br>    len = <span class="hljs-number">10</span>;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        table[i] = i;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>如果某个构造方法的开头使用 <code>this()</code> 调用其他构造方法，那么字段的初始化程序不会出现在这个构造方法中。此时，初始化由 <code>this()</code> 调用的构造方法处理</li></ul><p><strong>实例字段在构造方法中初始化，那么类字段在哪初始化？</strong></p><ul><li>即使不创建类的实例，类字段也关联在类身上。因此，类字段必须在调用构造方法之前初始化</li><li>Javac 将为每个类自动生成一个初始化类字段的 <strong>「类初始化方法」</strong>。这个方法只在首次使用类之前调用一次（经常在 JVM 首次加载类时）</li><li>和实例字段的初始化一样，类字段初始化表达式按照「类字段在源码中的顺序」插入类初始化方法。因此，类字段的初始化表达式可以使用在其之前声明的类字段</li><li>类初始化方法是内部方法，对 Java 程序员不可见</li></ul><h4 id="3-静态初始化程序"><a href="#3-静态初始化程序" class="headerlink" title="3. 静态初始化程序"></a>3. 静态初始化程序</h4><p>类有一个「类初始化方法」，这个方法不能像构造方法那样显式定义主体。不过，Java 允许编写 <strong>「静态初始化程序」</strong> 用于初始化类字段。静态初始化程序由 <code>static</code> 关键字及随后的花括号中的代码块组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrigCircle</span> </span>&#123;<br>    <span class="hljs-comment">// 静态查找表，及其各自的初始化程序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMPTS = <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> sines[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[NUMPTS];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> cosines[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[NUMPTS];<br><br>    <span class="hljs-comment">// 静态初始化程序，用于填充上述数组</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">double</span> x = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">double</span> delta_x = (Circle.PI / <span class="hljs-number">2</span>) / (NUMPTS - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, x = <span class="hljs-number">0.0</span>; i &lt; NUMPTS; i++, x += delta_x) &#123;<br>            sines[i] = Math.sin(x);<br>            cosines[i] = Math.cos(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一个类可以有任意多个静态初始化程序</li><li>「每个静态初始化程序 + 所有类字段初始化表达式」一起合并到类初始化方法中</li><li>静态初始化程序和类方法的相同点：不能使用 <code>this</code> 关键字，也不能使用类中的实例字段或实例方法</li></ul><h4 id="4-实例初始化程序"><a href="#4-实例初始化程序" class="headerlink" title="4. 实例初始化程序"></a>4. 实例初始化程序</h4><p><strong>实例初始化程序与静态初始化程序类似，但不使用 static 关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrigCircle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMPTS = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[NUMPTS];<br><br>    <span class="hljs-comment">// 实例初始化程序，用于填充上述数组</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMPTS; i++) &#123;<br>            data[i] = i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一个类可以有多个实例初始化程序，且实例初始化程序可以放在字段和方法定义能出现的任何位置。一般把实例初始化程序放在实例字段后面</li><li>「每个实例初始化程序 + 所有实例字段初始化表达式」一起放在类中每个构造方法的开头</li><li>实例初始化程序可以初始化数组或其他需要复杂初始化操作的字段。不过，现实中很少使用实例初始化程序</li></ul><h2 id="1-4-继承"><a href="#1-4-继承" class="headerlink" title="1.4 继承"></a>1.4 继承</h2><h3 id="1-4-1-超类和子类"><a href="#1-4-1-超类和子类" class="headerlink" title="1.4.1 超类和子类"></a>1.4.1 超类和子类</h3><h4 id="1-超类-Circle"><a href="#1-超类-Circle" class="headerlink" title="1. 超类 Circle"></a>1. 超类 Circle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">1.14159</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> r;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">1.0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">radiansToDegrees</span><span class="hljs-params">(<span class="hljs-keyword">double</span> rad)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rad * <span class="hljs-number">180</span> / PI;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> PI * r * r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circumference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * PI * r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-子类-PlaneCircle"><a href="#2-子类-PlaneCircle" class="headerlink" title="2. 子类 PlaneCircle"></a>2. 子类 PlaneCircle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlaneCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> cx = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> cy = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlaneCircle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(r);       <span class="hljs-comment">// 调用超类的构造函数 Circle(double r);</span><br>        <span class="hljs-keyword">this</span>.cx = x;<br>        <span class="hljs-keyword">this</span>.cy = y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCentreX</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cx;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getCentreY</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">radiansToDegrees</span><span class="hljs-params">(<span class="hljs-keyword">double</span> rad)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rad;<br>    &#125;<br><br>    <span class="hljs-comment">// 这个方法使用了继承的实例字段 r</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> dx = x - cx;<br>        <span class="hljs-keyword">double</span> dy = y - cy;<br>        <span class="hljs-keyword">double</span> dist = Math.sqrt(dx * dx + dy * dy);<br>        <span class="hljs-keyword">return</span> dist &lt; r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="super：子类调用超类的构造方法"><a href="#super：子类调用超类的构造方法" class="headerlink" title="super：子类调用超类的构造方法"></a>super：子类调用超类的构造方法</h5><p>在子类的构造方法中使用 <code>super()</code> 调用超类的构造方法与使用 <code>this()</code> 调用构造方法都有同样的限制</p><ul><li>只能在构造方法中使用 <code>super()</code></li><li>必须在构造方法的第一个语句中调用超类的构造方法，甚至要放在局部变量声明之前</li><li><code>Object</code> 类是 Java 中唯一一个没有超类的类，所有 Java 类都从 <code>Object</code> 类中继承方法</li></ul><h4 id="3-强制类型转换"><a href="#3-强制类型转换" class="headerlink" title="3. 强制类型转换"></a>3. 强制类型转换</h4><ul><li>把子类对象赋值给超类对象时无需强制转换</li><li>把超类对象赋值给子类对象时需强制转换</li></ul><h4 id="4-不能继承：final-类和方法"><a href="#4-不能继承：final-类和方法" class="headerlink" title="4. 不能继承：final 类和方法"></a>4. 不能继承：final 类和方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">PlaneCircle pc = <span class="hljs-keyword">new</span> PlaneCircle(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>Circle c = pc;<br>PlaneCircle pc2 = (PlaneCircle) c;<br><span class="hljs-keyword">boolean</span> origininside = ((PlaneCircle) c).isInside(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure><ul><li>如果声明类时使用了 <code>final</code> 修饰符，那么这个类无法作为超类或子类</li><li>子类不能重写超类的 <code>final</code> 方法</li></ul><h3 id="1-4-2-构造方法链"><a href="#1-4-2-构造方法链" class="headerlink" title="1.4.2 构造方法链"></a>1.4.2 构造方法链</h3><p>如果构造方法的第一个语句没有使用 <code>this()</code> 或 <code>super()</code> 显式调用另一个构造方法，Javac 编译器会插入 <code>super()</code>。即调用超类的构造方法，且不传入参数</p><p><strong>以 <code>PlaneCircle</code> 类为例，创建实例时会经过以下过程</strong></p><p>从下到上调用构造方法</p><ul><li>首先，调用 <code>PlaneCircle</code> 类的构造方法 <code>PlaneCircle()</code></li><li><code>PlaneCircle()</code> 显示调用 <code>super(r)</code>，即调用 <code>Circle</code> 类的构造方法 <code>Circle(double r)</code></li><li><code>Circle(double r)</code> 隐式调用 <code>super()</code>，即调用 <code>Circle</code> 类的超类 <code>Object</code> 类的构造方法。<code>Object</code> 类只有一个构造方法</li></ul><p>从上到下执行构造方法</p><ul><li>首先，执行 <code>Object</code> 类的构造方法的主体</li><li>其次，执行 <code>Circle</code> 类的构造方法 <code>Circle(double r)</code> 的主体</li><li>最后，执行 <code>PlaneCircle</code> 类的构造方法 <code>PlaneCircle()</code> 中剩余的语句</li></ul><h3 id="1-4-3-遮盖和覆盖"><a href="#1-4-3-遮盖和覆盖" class="headerlink" title="1.4.3 遮盖和覆盖"></a>1.4.3 遮盖和覆盖</h3><h4 id="1-遮盖超类的字段、类方法"><a href="#1-遮盖超类的字段、类方法" class="headerlink" title="1. 遮盖超类的字段、类方法"></a>1. 遮盖超类的字段、类方法</h4><p>假如有三个类 A、B 和 C，它们都定义了一个名为 x 的字段，而且 C 是 B 的子类，B 是 A 的子类</p><p>那么，C 类的方法中可以按照下面的方式引用这些不同的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">x               <span class="hljs-comment">// C 类的 x 字段</span><br><span class="hljs-keyword">this</span>.x          <span class="hljs-comment">// C 类的 x 字段</span><br><span class="hljs-keyword">super</span>.x         <span class="hljs-comment">// B 类的 x 字段</span><br>((B)<span class="hljs-keyword">this</span>).x     <span class="hljs-comment">// B 类的 x 字段</span><br>((A)<span class="hljs-keyword">this</span>).x     <span class="hljs-comment">// A 类的 x 字段</span><br><span class="hljs-keyword">super</span>.<span class="hljs-keyword">super</span>.x   <span class="hljs-comment">// 非法，不能这样引用 A 类的 x 字段</span><br></code></pre></td></tr></table></figure><p>类似地，如果 c 是 C 类的实例，那么可以按照下面的方式引用这三个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">c.x             <span class="hljs-comment">// C 类的 x 字段</span><br>((B)c).x        <span class="hljs-comment">// B 类的 x 字段</span><br>((A)c).x        <span class="hljs-comment">// A 类的 x 字段</span><br></code></pre></td></tr></table></figure><p>类字段也能被遮盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">1.14159265358979323846</span>; <span class="hljs-comment">// PlaneCircle 类中重新定义 PI</span><br>PI 或 PlaneCircle.PI   <span class="hljs-comment">// PlaneCircle 类的 PI</span><br><span class="hljs-keyword">super</span>.PI 或 Circle.PI  <span class="hljs-comment">// Circle 类的 PI</span><br></code></pre></td></tr></table></figure><h4 id="2-覆盖超类的实例方法"><a href="#2-覆盖超类的实例方法" class="headerlink" title="2. 覆盖超类的实例方法"></a>2. 覆盖超类的实例方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> i; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>; &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;                      <span class="hljs-comment">// 遮盖 A 类的字段 i</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> -i; &#125;          <span class="hljs-comment">// 覆盖 A 类的方法 f()</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>; &#125; <span class="hljs-comment">// 遮盖 A 类的类方法 g()</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        B b = <span class="hljs-keyword">new</span> B();<br>        System.out.println(b.i);    <span class="hljs-comment">// 引用 B.i，打印 2</span><br>        System.out.println(b.f());  <span class="hljs-comment">// 引用 B.f()，打印 -2</span><br>        System.out.println(b.g());  <span class="hljs-comment">// 引用 B.g()，打印 B</span><br>        System.out.println(B.g());  <span class="hljs-comment">// 调用 B.g() 更好的方式</span><br><br>        A a = (A) b;                <span class="hljs-comment">// 也可以隐式转换，A a = b;</span><br>        System.out.println(a.i);    <span class="hljs-comment">// 现在引用的是 A.i，打印 1</span><br>        System.out.println(a.f());  <span class="hljs-comment">// 还是引用 B.f()，打印 -2。超类 A 的实例方法 f() 被子类 B 覆盖</span><br>        System.out.println(a.g());  <span class="hljs-comment">// 引用 A.g()，打印 A</span><br>        System.out.println(A.g());  <span class="hljs-comment">// 调用 A.g() 更好的方式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-super：引用被遮盖的字段和被覆盖的方法"><a href="#3-super：引用被遮盖的字段和被覆盖的方法" class="headerlink" title="3. super：引用被遮盖的字段和被覆盖的方法"></a>3. super：引用被遮盖的字段和被覆盖的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 引用被遮盖的字段时，两者等价</span><br>        i = <span class="hljs-keyword">super</span>.i + <span class="hljs-number">1</span>;<br>        i = ((A)<span class="hljs-keyword">this</span>).i + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 引用被覆盖的方法 A.f()，两者不等价</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.f() + i;<br>        <span class="hljs-keyword">return</span> ((A)<span class="hljs-keyword">this</span>).f() + i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>super</code> 引用被遮盖的字段时，相当于把 <code>this</code> 校正为超类类型，然后通过超类类型访问字段</li><li>不过，使用 <code>super</code> 引用被覆盖的方法和校正 <code>this</code> 引用不是一回事</li><li>也即，表达式 <code>super.f()</code> 和 <code>((A)this).f()</code> 的作用不一样</li></ul><p><strong>解释器使用 <code>super</code> 句法调用实例方法时，会执行一种修改过的虚拟方法查找</strong></p><ul><li>第一步和常规的虚拟方法查找一样，确定调用方法的对象属于哪个类。运行时会在这个类中寻找对应的方法定义</li><li>但是，使用 <code>super</code> 句法调用方法时，先在这个类的超类中查找。如果超类直接实现了这个方法，那就调用这个方法。如果超类继承了这个方法，那就调用继承的方法</li></ul><p><strong><code>super</code> 调用的是方法的直接覆盖版本</strong></p><ul><li>假设 A 类有个子类 B，B 类有个子类 C，且这三个类都定义了同一个方法 <code>f()</code></li><li>在 <code>C.f()</code> 方法中使用 <code>super.f()</code> 调用的是方法 <code>B.f()</code>，因为 <code>C.f()</code> 直接覆盖了 <code>B.f()</code></li><li>但是，<code>C.f()</code> 不能直接调用 <code>A.f()</code>，因为 <code>super.super.f()</code> 是不合法的</li></ul><p><strong>注意区分：调用被覆盖方法的 super 和构造方法中调用超类构造方法的 super()</strong></p><ul><li>可以在类中的任何位置使用 <code>super</code> 调用超类中被覆盖的方法</li><li>但是只能在构造方法的第一个语句中使用 <code>super()</code> 调用超类的构造方法</li></ul><h3 id="1-4-4-Object：所有类的超类"><a href="#1-4-4-Object：所有类的超类" class="headerlink" title="1.4.4 Object：所有类的超类"></a>1.4.4 Object：所有类的超类</h3><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1. equals"></a>1. equals</h4><p>默认方法 <code>equals</code>：判断两个引用是否相同（指向同一个对象）</p><h5 id="（1）equals-方法应具备的特性"><a href="#（1）equals-方法应具备的特性" class="headerlink" title="（1）equals 方法应具备的特性"></a>（1）equals 方法应具备的特性</h5><ul><li>自反性：对于任何非空引用 <code>x</code>，<code>x.equals(x)</code> 应返回 <code>true</code></li><li>对称性：对于任何引用 <code>x、y</code>，当且仅当 <code>y.equals(x)</code> 返回 <code>true</code> 时，<code>x.equals(y)</code> 也应该返回 <code>true</code></li><li>传递性：对于任何引用 <code>x、y、z</code>，如果 <code>x.equals(y)、y.equals(z)</code> 都返回 <code>true</code>，则 <code>x.equals(z)</code> 也应返回 <code>true</code></li><li>一致性：如果 <code>x、y</code> 引用的对象没有发生变化，反复调用 <code>x.eqialS(y)</code> 应始终返回相同的结果</li><li>对于任何非空引用 <code>x</code>，<code>x.equals(null)</code> 应返回 <code>false</code></li></ul><h5 id="（2）引用相同和对象相等"><a href="#（2）引用相同和对象相等" class="headerlink" title="（2）引用相同和对象相等"></a>（2）引用相同和对象相等</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>&#125;;<br><span class="hljs-keyword">int</span>[] nums2 = nums;<br><span class="hljs-keyword">int</span>[] nums3 = nums.clone();<br><br><span class="hljs-comment">// 两个引用指向同一个对象，为真</span><br><span class="hljs-keyword">if</span> (nums.equals(nums2)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 两个引用指向的不是同一个对象，为假</span><br><span class="hljs-keyword">if</span> (nums.equals(nums3)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 两个对象的内容相等，为真</span><br><span class="hljs-keyword">if</span> (java.util.Arrays.equals(nums, nums3)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若想判断两个不同的对象是否相等，可以在一个对象上调用 <code>equals</code> 方法，然后把另一个对象作为参数传入该方法</li><li>所有对象都从 <code>Object</code> 类继承了 <code>equals</code> 方法，但是默认实现是使用 <code>==</code> 判断引用是否相同，而不判断对象内容是否相等</li><li>数组没有定义 <code>equals</code> 方法，但 <code>String</code> 类自定义了。因此，数组调用的 <code>equals</code> 方法与 <code>==</code> 运算符的作用一样</li><li>判断数组的内容是否相等可以使用 <code>java.util.Arrays.equals()</code> 方法</li></ul><h5 id="（3）实现-equals-方法的建议"><a href="#（3）实现-equals-方法的建议" class="headerlink" title="（3）实现 equals 方法的建议"></a>（3）实现 equals 方法的建议</h5><ul><li>显式参数命名为 <code>otherObject</code></li><li>检测 <code>this </code>与 <code>otherObject</code> 是否引用同一个对象：<code>if (this == otherObject) return true;</code></li><li>检测 <code>otherObject</code> 是否为 <code>null</code>，如果为 <code>null</code>，返回 <code>false</code>：<code>if (otherObject = null ) return false;</code></li><li>比较 <code>this</code> 与 <code>otherObject</code> 是否属于同一个类。如果 <code>equals</code> 的语义在每个子类中有所改变，那么使用 <code>getClass</code> 检测：<code>if (getClass() != otherObject.getCIass()) return false;</code></li><li>如果所有的子类都拥有统一的语义，那么使用 <code>instanceof</code> 检测：<code>if (!(otherObject instanceof ClassName)) return false;</code></li><li>将 <code>otherObject</code> 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherObject</code></li><li>使用 <code>==</code> 比较基本类型，使用 <code>equals</code> 比较对象。若所有的域都匹配，则返回 <code>true</code>；否则返回 <code>false</code>。可以使用静态方法 <code>Arrays.equals</code> 检测数组元素是否相等</li></ul><h5 id="（4）-运算符"><a href="#（4）-运算符" class="headerlink" title="（4）== 运算符"></a>（4）== 运算符</h5><p><code>==</code> 运算符比较基本值和引用是否相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String letter = <span class="hljs-string">&quot;o&quot;</span>;<br>String s = <span class="hljs-string">&quot;hello&quot;</span>;<br>String t = <span class="hljs-string">&quot;hell&quot;</span> + letter; <span class="hljs-comment">// s 和 t 保存的文本完全一样</span><br><br><span class="hljs-keyword">if</span> (s == t) &#123;               <span class="hljs-comment">// 两个引用指向的不是同一个对象，为假</span><br>    System.out.println(<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (s.equals(t)) &#123;           <span class="hljs-comment">// 两个对象的内容相等，为真</span><br>    System.out.println(<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>比较基本值时，只判断两个值是否一样。即每一位的值都完全相同</li><li>比较引用类型对象时，比较的是引用而不是对象。即 <code>==</code> 判断两个引用是否指向同一个对象，而不判断两个对象的内容是否相等</li></ul><h4 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2. hashCode"></a>2. hashCode</h4><p>默认方法 <code>hashCode</code>：返回每个对象的散列码，其值为对象的存储地址。如果 x 和 y 是两个不同的对象，那么 <code>x.hashCode()</code> 与<code>y.hashCode()</code> 基本上不会相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;Ok&quot;</span>;<br>String t = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Ok&quot;</span>);<br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(s);<br>StringBuilder tb = <span class="hljs-keyword">new</span> StringBuilder(t);<br><br>System.out.println(s.hashCode() + <span class="hljs-string">&quot; &quot;</span> + sb.hashCode());<br>System.out.println(t.hashCode() + <span class="hljs-string">&quot; &quot;</span> + tb.hashCode());<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2556</span> <span class="hljs-number">295530567</span><br><span class="hljs-number">2556</span> <span class="hljs-number">1452126962</span><br></code></pre></td></tr></table></figure><ul><li>字符串 <code>s、t</code> 的散列码相同，因为字符串的散列码是由内容导出的。<code>s、t</code> 的内容相同，因此它们的散列码相同</li><li>字符串缓冲 <code>sb、tb</code> 的散列码不同， 因为 <code>StringBuffer</code> 类中没有定义 <code>hashCode</code> 方法，其散列码是由 <code>Object</code> 类的默认<code>hashCode</code> 方法导出的对象存储地址。<code>sb、tb</code> 是两个对象，因此它们的散列码不同</li></ul><h5 id="（1）Objects-hash"><a href="#（1）Objects-hash" class="headerlink" title="（1）Objects.hash"></a>（1）Objects.hash</h5><p><code>Objects.hash</code>：散列码由多个值的散列码组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(name, salary, hireDay);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）Arrays-hashCode"><a href="#（2）Arrays-hashCode" class="headerlink" title="（2）Arrays.hashCode"></a>（2）Arrays.hashCode</h5><p><code>Arrays.hashCode</code>：散列码由数组元素的散列码组成</p><h5 id="（3）hashCode-和-equals-必须同时实现"><a href="#（3）hashCode-和-equals-必须同时实现" class="headerlink" title="（3）hashCode 和 equals 必须同时实现"></a>（3）hashCode 和 equals 必须同时实现</h5><p>如果重新定义 <code>equals</code> 方法，那么必须重新定义 <code>hashCode</code> 方法， 以便用户可以将对象插人到散列表中</p><p><code>equals</code> 与 <code>hashCode</code> 的定义必须一致：如果 <code>x.equals(y)</code> 返回 <code>true</code>，那么 <code>x.hashCode()</code> 与 <code>y.hashCode()</code> 的散列码必须相同</p><h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3. toString"></a>3. toString</h4><p>默认方法 <code>toString</code>：返回表示对象值的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() +<br>        <span class="hljs-string">&quot;&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>        <span class="hljs-string">&quot;, hireDay=&quot;</span> + hireDay +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只要将对象和字符串通过 <code>+</code> 连接起来，就会自动调用 <code>toString</code> 方法。例如，使用 <code>&quot;Hello&quot; + obj</code> 时，实际上是调用 <code>&quot;Hello&quot; + obj.toString()</code> </li><li>数组继承了 Object 类的 <code>toString</code> 方法，可以使用 <code>Arrays.toString(nums)</code> 打印一位数组，使用 <code>Arrays.deepToString(matrix)</code> 打印多维数组</li></ul><h4 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">private</span> LocalDate hireDay;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        <span class="hljs-keyword">this</span>.hireDay = LocalDate.of(year, month, day);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hireDay;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span> </span>&#123;<br>        salary += salary * byPercent / <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == otherObj) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherObj == <span class="hljs-keyword">null</span> || getClass() != otherObj.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Employee other = (Employee) otherObj;<br>        <span class="hljs-keyword">return</span> Objects.equals(name, other.name) &amp;&amp;<br>                Double.compare(other.salary, salary) == <span class="hljs-number">0</span> &amp;&amp;<br>                Objects.equals(hireDay, other.hireDay);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, salary, hireDay);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() +<br>                <span class="hljs-string">&quot;&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>                <span class="hljs-string">&quot;, hireDay=&quot;</span> + hireDay +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> bonus;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, salary, year, month, day);<br>        bonus = <span class="hljs-number">0.0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.getSalary();<br>        <span class="hljs-keyword">return</span> baseSalary + bonus;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBonus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bonus;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == otherObj) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherObj == <span class="hljs-keyword">null</span> || (getClass() != otherObj.getClass())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">super</span>.equals(otherObj)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Manager other = (Manager) otherObj;<br>        <span class="hljs-keyword">return</span> Double.compare(other.bonus, bonus) == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        return Objects.hash(super.hashCode(), bonus);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.hashCode() + <span class="hljs-number">17</span> * Double.valueOf(bonus).hashCode();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Manager&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;bonus=&quot;</span> + bonus +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-5-自动装箱"><a href="#1-4-5-自动装箱" class="headerlink" title="1.4.5 自动装箱"></a>1.4.5 自动装箱</h3><p>包装类：<code>Boolean、Byte、Short、Character、Integer、Long、Float、Double</code>，每个实例只保存一个基本值</p><p>包装类一般在把基本值存储在集合中时使用，例如 <code>java.util.List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">// List 接口</span><br>Integer i = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 自动装包 int -&gt; Integer</span><br>numbers.add(i);<br>numbers.add(<span class="hljs-number">2</span>);         <span class="hljs-comment">// 自动装包 int -&gt; Integer</span><br><span class="hljs-keyword">int</span> j = numbers.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 自动拆包 Integer -&gt; int</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 把 int 类型字面量 0 装包到 Integer 对象中</span><br>Number n = <span class="hljs-number">0.0f</span>;    <span class="hljs-comment">// 把 float 类型字面量装包到 Float 对象中，然后放大转换成 Number类型</span><br>Integer i = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 这是装包转换</span><br><span class="hljs-keyword">int</span> j = i;          <span class="hljs-comment">// i在这里拆包</span><br>i++;                <span class="hljs-comment">// 拆包 i，递增，再装包</span><br>Integer k = i + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 拆包 i，再装包两数之和</span><br>i = <span class="hljs-keyword">null</span>;<br>j = i;              <span class="hljs-comment">// null 只能赋给引用类型，抛出 NullPointerException 异常</span><br></code></pre></td></tr></table></figure><h3 id="1-4-6-访问控制"><a href="#1-4-6-访问控制" class="headerlink" title="1.4.6 访问控制"></a>1.4.6 访问控制</h3><h4 id="1-成员访问"><a href="#1-成员访问" class="headerlink" title="1. 成员访问"></a>1. 成员访问</h4><p>默认的访问规则比 <code>protected</code> 严格，因为默认规则不允许在包外部的子类中访问成员</p><ul><li>类中的所有字段和方法在类的主体里始终可以使用</li><li>如果类的成员使用 <code>public</code> 修饰符声明，那么可以在能访问这个类的任何地方访问这个成员</li><li>如果类的成员声明为 <code>private</code>，那么除了在类内部之外，其他地方都不能访问这个成员</li><li>如果类的成员声明为 <code>protected</code>，那么包里的所有类都能访问这个成员（等同于默认的包访问规则），且在这个类的任何子类的主体中也能访问这个成员（不管子类在哪个包中定义）</li><li>如果声明类的成员时没使用任何修饰符，那么使用默认的访问规则（有时叫包访问）。即包中的所有类都能访问这个成员，但在包外部不能访问</li></ul><p>使用 protected 成员时的注意事项</p><ul><li>假设 A 类使用 <code>protected</code> 声明了一个字段 x，而且在另一个包中定义的 B 类继承 A 类（重点是 B 类在另一包中定义）</li><li>因此，B 类继承了这个 <code>protected</code> 声明的字段 x，那么，在 B 类的代码中可以访问当前实例的这个字段，而且引用 B 类实例的代码也能访问这个字段</li><li><strong>但是，在 B 类的代码中不能访问 A 类实例的受保护字段 x</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javanut6.ch03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">examine</span><span class="hljs-params">(A a)</span> </span>&#123;    <span class="hljs-comment">// B 类的代码中不能访问 A 类实例的受保护字段</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B sees: &quot;</span> + a.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javanut6.ch03.different;<br><span class="hljs-keyword">import</span> javanut6.ch03.A;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">examine</span><span class="hljs-params">(B b)</span> </span>&#123;    <span class="hljs-comment">// 引用 B 类实例的代码也能访问这个字段</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B sees another B: &quot;</span> + b.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-访问控制和继承"><a href="#2-访问控制和继承" class="headerlink" title="2 访问控制和继承"></a>2 访问控制和继承</h4><ul><li>子类继承超类中所有可以访问的实例字段和实例方法</li><li>如果子类和超类在同一个包中定义，那么子类继承所有未使用 <code>private</code> 声明的实例字段和方法</li><li>如果子类在其他包中定义，那么它继承所有使用 <code>protected</code> 和 <code>public</code> 声明的实例字段和方法</li><li>使用 <code>private</code> 声明的字段和方法绝不会被继承，类字段和类方法也一样</li><li>构造方法不会被继承（而是链在一起调用）</li></ul><h4 id="3-成员访问规则总表"><a href="#3-成员访问规则总表" class="headerlink" title="3 成员访问规则总表"></a>3 成员访问规则总表</h4><table><thead><tr><th align="left">能否访问</th><th align="left">public</th><th align="left">protected</th><th align="left">默认</th><th align="left">private</th></tr></thead><tbody><tr><td align="left">定义成员的类</td><td align="left">是</td><td align="left">是</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">同一个包中的类</td><td align="left">是</td><td align="left">是</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">不同包中的子类</td><td align="left">是</td><td align="left">是</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">不同的包，也不是子类</td><td align="left">是</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr></tbody></table><h2 id="1-5-抽象类"><a href="#1-5-抽象类" class="headerlink" title="1.5 抽象类"></a>1.5 抽象类</h2><p>Java 中的抽象方法与 C++ 中的纯虚拟函数（即声明为 <code>= 0</code> 的虚函数）类似。在 C++ 中，包含纯虚拟函数的类是抽象类，不能实例化。包含抽象方法的 Java 类也一样不能实例化</p><h3 id="1-5-1-抽象类的特性"><a href="#1-5-1-抽象类的特性" class="headerlink" title="1.5.1 抽象类的特性"></a>1.5.1 抽象类的特性</h3><ul><li>只要类中有一个 <code>abstract</code> 方法，那么这个类自动声明为 <code>abstract</code> 类，且必须声明为 <code>abstract</code> 类，否则会编译出错</li><li>声明为 <code>static</code>、<code>private</code> 或 <code>final</code> 的方法不是抽象方法，因为子类不能被覆盖这三种方法。类似地，<code>final</code> 类中不能有任何 <code>abstract</code> 方法</li><li>就算类中没有 <code>abstract</code> 方法，这个类也能声明为 <code>abstract</code>。使用这种方式声明的 <code>abstract</code> 类表明实现的不完整，要交给子类实现。这种类不能实例化</li></ul><h3 id="1-5-2-抽象类的限制"><a href="#1-5-2-抽象类的限制" class="headerlink" title="1.5.2 抽象类的限制"></a>1.5.2 抽象类的限制</h3><ul><li><code>abstract</code> 类无法实例化</li><li><code>abstract</code> 类的子类必须实现 <code>abstract</code> 类的每个 <code>abstract</code> 方法才能实例化。这种子类一般称为<strong>「具体子类」</strong></li><li>如果 <code>abstract</code> 类的子类没有实现继承的所有 <code>abstract</code> 方法，那么这个子类还是抽象类，且必须声明为 <code>abstract</code>， 也不能实例化</li><li>如果一个类扩展了抽象类，那么就不能再扩展其他类</li></ul><h3 id="1-5-3-Demo"><a href="#1-5-3-Demo" class="headerlink" title="1.5.3 Demo"></a>1.5.3 Demo</h3><p>抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-comment">// 两个抽象方法 --- 由具体子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circumference</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">1.14159265358979323846</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> r;<br>    <br><span class="hljs-comment">// 具体子类自己的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现抽象类的两个抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> PI * r * r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circumference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * PI * r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> w, h;<br><br><span class="hljs-comment">// 具体子类自己的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> w, <span class="hljs-keyword">double</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.w = w;<br>        <span class="hljs-keyword">this</span>.h = h;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现抽象类的两个抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> w * h;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circumference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (w + h);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-修饰符总表"><a href="#1-6-修饰符总表" class="headerlink" title="1.6 修饰符总表"></a>1.6 修饰符总表</h2><table>    <tr>        <th>修饰符</th>        <th>作用域</th>        <th>说明</th>      </tr >    <tr >        <td rowspan = "3"><b>abstract</td>        <td>类</td>        <td>抽象类不能实例化，而且可能包含未实现的方法</td>    </tr>    <tr>        <td>接口</td>        <td>所有接口都是抽象的。声明接口时这个修饰符是可选的</td>    </tr>    <tr>        <td>方法</td>        <td>抽象方法没有主体，主体由子类提供。所在的类必须也是抽象的</td>    </tr>    <tr>        <td rowspan = "4"><b>final</td>        <td>类</td>        <td>不能创建这个类的子类</td>    </tr>    <tr>        <td>方法</td>        <td>不能覆盖这个方法</td>    </tr>    <tr>        <td>字段</td>        <td>不能修改这个字段的值。static final 修饰的字段是编译时常量</td>    </tr>    <tr>        <td>变量</td>        <td>值不能改变的局部变量、方法参数或异常参数</td>    </tr>    <tr>        <td rowspan = "1"><b>private</td>        <td>成员</td>        <td>这个成员只在定义它的类中可以访问</td>    </tr>    <tr>        <td rowspan = "1"><b>protected</td>        <td>成员</td>        <td>这个成员只在定义它的包中和子类中可以访问（不管子类在哪个包中定义）</td>    </tr>    <tr>        <td rowspan = "3"><b>public</td>        <td>类</td>        <td>能访问所在包的地方都能访问这个类</td>    </tr>    <tr>        <td>接口</td>        <td>能访问所在包的地方都能访问这个接口</td>    </tr>    <tr>        <td>成员</td>        <td>能访问所在类的地方都能访问这个成员</td>    </tr>    <tr>        <td rowspan = "4"><b>static</td>        <td>类</td>        <td>使用 static 声明的内部类是顶层类，而不是所在类的成员</td>    </tr>    <tr>        <td>方法</td>        <td>static 方法是类方法。不隐式传入 this 对象引用。可通过类名调用</td>    </tr>    <tr>        <td>字段</td>        <td>static 字段是类字段。不管创建多少类实例，这个字段都只有一个实例。可通过类名访问</td>    </tr>    <tr>        <td>初始化程序</td>        <td>这个初始化程序在加载类时运行，而不是创建实例时运行</td>    </tr>    <tr>        <td rowspan = "1"><b>defult</td>        <td>方法</td>        <td>这个接口方法的实现是可选的。接口为不想实现这个方法的类提供了一个默认实现</td>    </tr>    <tr>        <td rowspan = "3"><b>无</td>        <td>类</td>        <td>未声明为 public 的类只能在包中访问</td>    </tr>    <tr>        <td>接口</td>        <td>未声明为 public 的接口只能在包中访问</td>    </tr>    <tr>        <td>成员</td>        <td>未声明为 private、protected 或 public 的成员具有包可见性，只能在包中访问</td>    </tr>    <tr>        <td rowspan = "1">native</td>        <td>方法</td>        <td>这个方法使用某种与平台无关的方式实现（经常使用 C 语言）。没有提供主体，签名后面是一个分号</td>    </tr>    <tr>        <td rowspan = "1">synchronized</td>        <td>方法</td>        <td>这个方法对类或实例执行非原子操作，所以必须小心，确保不能让两个线程同时修改类或实例。对 static 方法来说，执行方法之前先为类获取一个锁。对非 static 方法来说，会为具体的对象实例获取一个锁</td>    </tr>    <tr>        <td rowspan = "1">transient</td>        <td>字段</td>        <td>这个字段不是对象持久化状态的一部分，因此不会随对象一起序列化。在对象序列化时使用，参见 java.io.ObjectOutputStream</td>    </tr>    <tr>        <td rowspan = "1">volatile</td>        <td>字段</td>        <td>这个字段能被异步线程访问，因此必须对其做些特定的优化。这个修饰符有时可以替代  synchronized</td>    </tr>    <tr>        <td rowspan = "2">strictfp</td>        <td>类</td>        <td>这个类中的所有方法都隐式声明为 strictfp</td>    </tr>    <tr>        <td>方法</td>        <td>这个方法必须使用严格遵守 IEEE 754 标准的方式执行浮点运算。具体而言，所有数值，包括中间结果，都要使用 IEEE float 或 double 类型表示，而且不能利用本地平台浮点格式或硬件提供的额外精度或取值范围。这个修饰符极少使用</td>    </tr></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类</tag>
      
      <tag>对象</tag>
      
      <tag>字段</tag>
      
      <tag>方法</tag>
      
      <tag>修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件传输</title>
    <link href="/2021/05/12/Linux/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <url>/2021/05/12/Linux/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h2 id="安全文件传输协议-SFTP"><a href="#安全文件传输协议-SFTP" class="headerlink" title="安全文件传输协议 SFTP"></a>安全文件传输协议 SFTP</h2><p><strong>SFTP (Secure File Transfer Protocol)</strong> 与 FTP 相比，为文件传输提供了一种安全的网络加密方法</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><h4 id="sftp-远程连接服务器"><a href="#sftp-远程连接服务器" class="headerlink" title="sftp 远程连接服务器"></a>sftp 远程连接服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sftp username@hostname (ip)<br></code></pre></td></tr></table></figure><h4 id="将客户端的文件上传至服务器"><a href="#将客户端的文件上传至服务器" class="headerlink" title="将客户端的文件上传至服务器"></a>将客户端的文件上传至服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">put [local_file] [remote_file]<br>put -r [local_directory] [remote_directory]<br></code></pre></td></tr></table></figure><h4 id="将服务器的文件下载至客户端"><a href="#将服务器的文件下载至客户端" class="headerlink" title="将服务器的文件下载至客户端"></a>将服务器的文件下载至客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">get [remote_file] [local_file]<br>get -r [remote_directory] [local_directory]<br></code></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>使用 SecureCRT 远程登录虚拟机 VMware Workstation 中的 Ubuntu 和 Centos</p><ul><li>VMware Workstation 16 Pro</li><li>SecureCRT 8.5.0</li><li>Ubuntu 16.04（As a Client）</li><li>Centos 7（As a Server）</li></ul><h4 id="sftp-远程连接服务器-Centos"><a href="#sftp-远程连接服务器-Centos" class="headerlink" title="sftp 远程连接服务器 Centos"></a>sftp 远程连接服务器 Centos</h4><p><img src="https://s.im5i.com/2021/05/13/9UAJW.png" alt="Connect server by sftp"></p><h4 id="将客户端-Ubuntu-的文件上传至服务器-Centos"><a href="#将客户端-Ubuntu-的文件上传至服务器-Centos" class="headerlink" title="将客户端 Ubuntu 的文件上传至服务器 Centos"></a>将客户端 Ubuntu 的文件上传至服务器 Centos</h4><p><img src="https://s.im5i.com/2021/05/13/9UH2q.png" alt="Client to server"></p><h4 id="将服务器-Centos-的文件下载至客户端-Ubuntu"><a href="#将服务器-Centos-的文件下载至客户端-Ubuntu" class="headerlink" title="将服务器 Centos 的文件下载至客户端 Ubuntu"></a>将服务器 Centos 的文件下载至客户端 Ubuntu</h4><p><img src="https://s.im5i.com/2021/05/13/9Um0Q.png" alt="Server to client"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sftp</tag>
      
      <tag>scp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDFS</title>
    <link href="/2021/05/10/Hadoop/HDFS/"/>
    <url>/2021/05/10/Hadoop/HDFS/</url>
    
    <content type="html"><![CDATA[<p>HDFS</p>]]></content>
    
    
    <categories>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce</title>
    <link href="/2021/05/10/Hadoop/MapReduce/"/>
    <url>/2021/05/10/Hadoop/MapReduce/</url>
    
    <content type="html"><![CDATA[<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map-reduce"></a>map-reduce</h2><p>数据以一条记录为单位，经过 map 方法映射成 key-val，相同的 key 为一组，一组调用一次 reduce 方法，</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>以一条记录为单位做映射，实现 key-val (键值对)</p><ul><li>映射、变换、过滤</li><li>1 进 N 出</li></ul><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><ul><li>分解、缩小、归纳</li><li>一组进 N 出</li></ul><h2 id="group-key"><a href="#group-key" class="headerlink" title="group(key)"></a>group(key)</h2><p>键值相同作为一组（最小单元）</p><p><strong>block &gt; split</strong>: 1:1, N:1, 1:N<br>split &gt; map — 1:1<br>map &gt; reduce — N:1, N:N,: 1:1, 1:N<br>group(key) &gt; partition 1:1, N:1, N:N, 1:N<br>sfdasf fasdf asdf sd</p>]]></content>
    
    
    <categories>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mapper</tag>
      
      <tag>reducer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>套接字 socket</title>
    <link href="/2021/03/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%A5%97%E6%8E%A5%E5%AD%97-socket/"/>
    <url>/2021/03/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%A5%97%E6%8E%A5%E5%AD%97-socket/</url>
    
    <content type="html"><![CDATA[<h2 id="socket-分类"><a href="#socket-分类" class="headerlink" title="socket 分类"></a>socket 分类</h2><h3 id="流-stream"><a href="#流-stream" class="headerlink" title="流 stream"></a>流 stream</h3><p>流 socket 基于 TCP 协议，面向连接的可靠服务。保证数据按序到达</p><h3 id="数据报-datagram"><a href="#数据报-datagram" class="headerlink" title="数据报 datagram"></a>数据报 datagram</h3><p>数据报 socket 基于 UDP 协议，无连接的不可靠服务。数据可能会丢失，不保证按序到达，且数据包长度有限制，但传输效率高（无连接、无确认）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络休系结构</title>
    <link href="/2021/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%91%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2021/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%91%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><h3 id="广义观点"><a href="#广义观点" class="headerlink" title="广义观点"></a>广义观点</h3><ol><li><p>只要是能实现远程信息处理和资源共享的系统，都是计算机网络</p></li><li><p>广义观点定义了一个计算机通信网络，在物理结构上具有了计算机网络的雏形，但资源共享能力弱，是计算机网络发展的低级阶段</p></li></ol><h3 id="资源共享观点"><a href="#资源共享观点" class="headerlink" title="资源共享观点"></a>资源共享观点</h3><p>计算机网络是 “以能够相互共享资源的方式互联起来的自治计算机系统的集合”</p><p>该定义包含三层含义<br>_ 目的：资源共享<br>_ 组成单元：分布在不同地理位置的多台独立的 “自治计算机” * 网络协议：网络中的计算机必须遵循的统一规则</p><h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><h3 id="从组成部分上"><a href="#从组成部分上" class="headerlink" title="从组成部分上"></a>从组成部分上</h3><p>一个完整的计算机网络的组成：硬件、软件、协议</p><ul><li>硬件：包括主机 (端系统)、通信链路 (双绞线、光纤)、交换设备 (路由器、交换机) 和通信处理机 (网卡) 等。<br>计算机网络中必须要有操作系统、服务器、客户机；可以没有数据库管理系</li><li>软件：包括各种实现资源共享的软件和用户软件（如网络操作系统、邮件收发程序、FTP 程序、聊天程序）</li><li>协议：计算机网络的核心</li></ul><h3 id="从工作方式上"><a href="#从工作方式上" class="headerlink" title="从工作方式上"></a>从工作方式上</h3><p><strong>计算机网络（这里指因特网）可分为边缘部分和核心部分</strong></p><ul><li>边缘部分：由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据）和资源共享</li><li>核心部分：由大量的网络和连接网络的路由器组成，为边缘部分提供连通性和交换服务</li></ul><h3 id="从功能组成上"><a href="#从功能组成上" class="headerlink" title="从功能组成上"></a>从功能组成上</h3><p><strong>计算机网络由通信子网和资源子网组成</strong></p><ul><li>通信子网：由各种传输介质、通信设备和相应的网络协议组成，使网络具有数据传输、交换、控制和存储的能力</li><li>资源子网：实现资源共享的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件、软件和数据资源的服务</li><li>因此，计算机网络的资源主要是计算机硬件、软件和数据</li></ul><h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><p><strong>三大主要功能：数据通信、资源共享、分布式处理</strong></p><ul><li>数据通信：计算机网络最基本和最重要的功能，实现联网计算机之间的信息传输</li><li>资源共享：可以是硬件共享、软件共享和数据共享，提高资源利用率</li><li>分布式处理：当某个计算机系统负荷过重时，可以将某个复杂任务分配给网络中的其他空闲计算机，以提高整个系统的利用率</li><li>提高可靠性：计算机网络中的各台计算机可以通过网络互为替代机</li><li>负载均衡：将任务均衡地分配给计算机网络中的各台计算机</li></ul><blockquote><p>计算机网络使各计算机之间的联系更加紧密而非相对独立</p></blockquote><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按分布范围"><a href="#按分布范围" class="headerlink" title="按分布范围"></a>按分布范围</h3><h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网 LAN"></a>局域网 LAN</h4><ul><li>局域网使用广播技术，工作在数据链路层。局域网通过路由器接入广域网</li><li>典型的局域网：以太网（分组交换）、令牌环网、令牌总线网</li><li>覆盖范围：几十米到几千米</li></ul><h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网 WAN"></a>广域网 WAN</h4><ul><li>广域网使用交换技术，属于点对点网络（一般为网状形结构），是因特网的核心部分</li><li>覆盖范围：几十千米到几千千米</li></ul><h4 id="城域网-MAN"><a href="#城域网-MAN" class="headerlink" title="城域网 MAN"></a>城域网 MAN</h4><ul><li>城域网大多采用以太网技术，因此仍属于局域网</li><li>覆盖范围：5~50 km</li></ul><h4 id="个人区域网-PAN"><a href="#个人区域网-PAN" class="headerlink" title="个人区域网 PAN"></a>个人区域网 PAN</h4><ul><li>也称无线个人区域网 WPAN，覆盖范围约为 10m</li></ul><h3 id="按传输技术"><a href="#按传输技术" class="headerlink" title="按传输技术"></a>按传输技术</h3><blockquote><p>是否采用分组存储转发和路由选择是点对点式网络与广播式网络的主要区别</p></blockquote><h4 id="广播式网络（局域网）"><a href="#广播式网络（局域网）" class="headerlink" title="广播式网络（局域网）"></a>广播式网络（局域网）</h4><ul><li><p>广播式网络共享广播信道（如总线），通常是局域网的一种通信方式（局域网工作在数据链路层），因此不需要网络层，也不存在路由选择问题。但数据链路层使用物理层的服务必须通过服务访问点 SAP 实现</p></li><li><p>当一台计算机利用共享通信信道发送报文分组时，自己和其他所有的计算机都会 <strong>「收听」</strong> 到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组</p></li><li><p>局域网基本上都采用广播式通信技术，广域网中的无线（CSMA/CA 协议）、卫星通信网络也采用广播式通信技术</p></li></ul><h4 id="点对点网络（广域网）"><a href="#点对点网络（广域网）" class="headerlink" title="点对点网络（广域网）"></a>点对点网络（广域网）</h4><ul><li>每条物理线路连接一对计算机</li><li>若通信的两台主机之间没有直接通路，则它们之间的分组传输就要通过中间结点（路由器）的存储转发，直至目的结点</li><li>广域网属于点对点网络</li></ul><h3 id="按交换技术"><a href="#按交换技术" class="headerlink" title="按交换技术"></a>按交换技术</h3><h4 id="交换技术（点对点）"><a href="#交换技术（点对点）" class="headerlink" title="交换技术（点对点）"></a>交换技术（点对点）</h4><p>指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式</p><h4 id="电路交换网络"><a href="#电路交换网络" class="headerlink" title="电路交换网络"></a>电路交换网络</h4><ul><li><p>在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段</p></li><li><p>优点：数据直接传送、时延小</p></li><li><p>缺点：线路利用率低、不能充分利用线路容量、不便差错控制</p></li></ul><h4 id="报文交换网络（存储转发网络）"><a href="#报文交换网络（存储转发网络）" class="headerlink" title="报文交换网络（存储转发网络）"></a>报文交换网络（存储转发网络）</h4><ul><li>报文：用户数据加上源地址、目的地址、校验码等辅助信息，封装成报文</li><li>特点：整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点</li><li>优点：充分利用线路容量，可以实现不同链路之间不同数据率、格式的转换，实现一对多、多对一的访问，差错控制</li><li>缺点：资源开销大</li></ul><h4 id="分组交换网络（包交换网络）"><a href="#分组交换网络（包交换网络）" class="headerlink" title="分组交换网络（包交换网络）"></a>分组交换网络（包交换网络）</h4><ul><li><strong>「分组」</strong>：将大数据块分成若干固定长度的小数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输</li><li>特点：单个分组（只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点</li><li>优点：除具备报文交换网络的优点外，缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化</li><li>缺点：资源开销大，附加信息开销大。现在的主流网络基本上都可视为分组交换网络</li></ul><h3 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h3><p>主要指通信子网的拓扑结构</p><h4 id="总线形网络"><a href="#总线形网络" class="headerlink" title="总线形网络"></a>总线形网络</h4><ul><li>优点：建网容易、增减结点方便、节省线路</li><li>缺点：重负载时通信效率不高、总线任意一处对故障敏感</li><li></li></ul><h4 id="星形网络"><a href="#星形网络" class="headerlink" title="星形网络"></a>星形网络</h4><ul><li>每个终端或计算机都以单独的线路与中央设备相连</li><li>中央设备早期是计算机，现在一般是交换机或路由器</li><li>优点：便于集中控制和管理，因为端用户之间的通信必须经过中央设备</li><li>缺点：成本高、中心结点对故障敏感</li></ul><h4 id="环形网络"><a href="#环形网络" class="headerlink" title="环形网络"></a>环形网络</h4><ul><li>所有计算机接口设备连接成一个环</li><li>环形网络最典型的例子：令牌环局域网</li><li>环可以是单环，也可以是双环，环中信号是单向传输的</li></ul><h4 id="网状形网络"><a href="#网状形网络" class="headerlink" title="网状形网络"></a>网状形网络</h4><ul><li>一般每个结点至少有两条路径与其他结点相连，多用在广域网中。有规则型和非规则型两种</li><li>优点：可靠性高</li><li>缺点：控制复杂、线路成本高</li></ul><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><p>带宽：最高数据率，单位 b/s<br>速率：也称数据率或比特率，单位 b/s。最高数据率称为带宽<br>往返时延 $RTT$：指从发送端发送数据开始，到发送端收到来自接收端的确认共经历的时延</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ul><li>发送时延：发送时延 ＝ 分组长度 / 信道宽度</li><li>传播时延：传播时延 ＝ 信道长度 / 信道上的传播速率</li><li>处理时延：数据在交换结点为存储转发而进行的一些必要的处理所花费的时间</li><li>排队时延：分组在进入路由器后要先在输入队列中排队等待处理</li></ul><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><ul><li>链路长度：时延带宽积 ＝ 传播时延 × 信道带宽</li><li>假设链路是一个圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量</li></ul><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><ul><li>信道利用率 ＝ 有数据通过时间 / (有+无) 数据通过时间</li></ul><h2 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h2><h3 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>计算机网络中的层次、各层的协议及层间接口的集合</p><h4 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h4><ul><li>每层都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务</li><li>整个分层结构应能促进标准化工作</li></ul><h4 id="协议数据单元-PDU"><a href="#协议数据单元-PDU" class="headerlink" title="协议数据单元 PDU"></a>协议数据单元 PDU</h4><p><strong>「实体」</strong>：任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块<br><strong>「对等层」</strong>：不同机器上的同一层<br><strong>「对等实体」</strong>：同一层的实体。n 层实体为 n+1 层服务</p><p><strong>n-SDU + n-PCI = n-PDU = (n-1)-SDU</strong></p><ul><li>服务数据单元 SDU：为完成用户所要求的功能而应传送的数据。第 n 层的服务数据单元记为 n-SDU</li><li>协议控制信息 PCI：控制协议操作的信息。第 n 层的协议控制信息记为 n-PCI</li><li>协议数据单元 PDU：对等层次之间传送的数据单位称为该层的 PDU。第 n 层的协议数据单元记为 n-PDU</li></ul><blockquote><p>物理层的 PDU 称为比特，链路层的 PDU 称为帧，网络层的 PDU 称为分组，传输层的 PDU 称为报文</p></blockquote><h4 id="层次结构的含义"><a href="#层次结构的含义" class="headerlink" title="层次结构的含义"></a>层次结构的含义</h4><ul><li>第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，还要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和</li><li>最低层只提供服务，是整个层次结构的基础；最高层面向用户提供服务。中间各层既是下一层的服务使用者，又是上一层的服务提供者</li><li>上一层只能通过相邻层间的接口使用下一层的服务；下一层所提供服务的实现细节对上一层透明</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方（实际过程是一个 U 形）</li></ul><h3 id="协议、接口、服务"><a href="#协议、接口、服务" class="headerlink" title="协议、接口、服务"></a>协议、接口、服务</h3><h4 id="协议（水平的）"><a href="#协议（水平的）" class="headerlink" title="协议（水平的）"></a>协议（水平的）</h4><ul><li>协议由语法、语义和同步组成。只有对等实体之间才存在协议，协议是 “水平的”</li><li>语法：规定了传输数据的格式</li><li>语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答</li><li>同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明</li><li>一个完整的协议通常应具有线路管理（建立、释放连接）、差错控制、数据转换等功能</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定</li><li>每层只能为紧邻层之间定义接口，而不能跨层定义接口</li><li>在典型的接口上，同一结点相邻两层的实体通过服务访问点 SAP 进行交互</li></ul><p><strong>服务访问点 SAP</strong></p><ul><li>物理层：网卡接口</li><li>数据链路层：MAC 地址（网卡地址、硬件地址）</li><li>网络层：IP 地址（网络地址）</li><li>传输层：端口号</li><li>应用层：用户界面</li></ul><h4 id="服务（垂直的）"><a href="#服务（垂直的）" class="headerlink" title="服务（垂直的）"></a>服务（垂直的）</h4><p>服务是指下层为紧邻的上层提供的功能调用，服务是 “垂直的”</p><p>② 对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务<br>③ 有应答服务包括全部 4 类原语；无应答服务只有请求和指示两类原语<br>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在 OSI 中称为服务原语<br>① 请求：服务用户 -&gt; 服务提供者，请求完成某项工作<br>② 指示：服务提供者 -&gt; 服务用户，指示用户做某件事情<br>③ 响应：服务用户 -&gt; 服务提供者，作为对指示的响应<br>④ 证实：服务提供者 -&gt; 服务用户，作为对请求的证实<br>协议与服务的区别<br>① 只有本层协议的实现才能保证向上一层提供服务<br>② 本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的<br>③ 协议是水平的，即协议是控制对等实体之间通信的规则；服务是垂直的，即服务是由下层通过层间接口向上层提供的<br>④ 在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体 “看得见” 的功能才能称为服务<br>计算机网络提供的服务<br>① 面向连接（带确认的可靠服务）：分为连接建立、数据传输和连接释放三个阶段（TCP）<br>② 无连接（带确认或无确认的不可靠服务）：称为 “尽最大努力交付”（IP、UDP）<br>③ 可靠服务：网络具有纠错、检错、应答机制，能保证数据正确、按序到达（有编号机制）<br>④ 不可靠服务：网络只是尽量正确、可靠地传送，并不能保证数据正确、按序到达（无编号机制）<br>⑤ 带确认服务：接收方在收到数据后向发送方回复 ACK（文件传输协议 FTP、MAC 协议中的 CSMA/CA）<br>⑥ 无确认服务：接收方收到数据后不自动给出应答，若需要应答，则由高层实现（IP、UDP）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2 二叉树</title>
    <link href="/2021/02/13/LeetCode/4%20%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/02/13/LeetCode/4%20%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-二叉树的结构体"><a href="#1-1-二叉树的结构体" class="headerlink" title="1.1 二叉树的结构体"></a>1.1 二叉树的结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(): val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    TreeNode(<span class="hljs-keyword">int</span> x): val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode* left, TreeNode* right): val(x), left(left), right(right) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1-2-二叉树遍历"><a href="#1-2-二叉树遍历" class="headerlink" title="1.2 二叉树遍历"></a>1.2 二叉树遍历</h2><h3 id="1-2-1-先序遍历"><a href="#1-2-1-先序遍历" class="headerlink" title="1.2.1 先序遍历"></a>1.2.1 先序遍历</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h4><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    preOrder(root-&gt;left);<br>    preOrder(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder_iter</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br><br>    <span class="hljs-keyword">while</span> (!stk.empty() || root != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br><br>        root = stk.top();<br>        stk.pop();<br>        root = root-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h4 id="3-Morris-先序遍历"><a href="#3-Morris-先序遍历" class="headerlink" title="3. Morris 先序遍历"></a>3. Morris 先序遍历</h4><h5 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h5><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h3 id="1-2-2-中序遍历"><a href="#1-2-2-中序遍历" class="headerlink" title="1.2.2 中序遍历"></a>1.2.2 中序遍历</h3><h4 id="1-递归-1"><a href="#1-递归-1" class="headerlink" title="1. 递归"></a>1. 递归</h4><h5 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    inOrder(root-&gt;left);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    inOrder(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h4 id="2-迭代-1"><a href="#2-迭代-1" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><h5 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder_iter</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br><br>    <span class="hljs-keyword">while</span> (!stk.empty() || root != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br><br>        root = stk.top();<br>        stk.pop();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        root = root-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h4 id="3-Morris-中序遍历"><a href="#3-Morris-中序遍历" class="headerlink" title="3. Morris 中序遍历"></a>3. Morris 中序遍历</h4><p>**时间复杂度 $O(2h)$，空间复杂度 $O(1)$，不需要栈 **</p><ol><li>$root$ 无左孩子<ul><li>$root$ 加入结果</li><li>$x = x.right$（$root$ 无右子树时，通过第一次遍历时添加的线索，找到 $root$ 的直接后继；$root$ 有右子树时，开始遍历 $root$ 的右子树）</li></ul></li><li>$root$ 有左孩子，找到 $root$ 在中序遍历下的直接前驱 $pre$<ul><li>$pre$ 的右孩子为空，$pre.right = root$<strong>「线索」</strong>，$root = root.left$（开始遍历 $root$ 的左子树）</li><li>$pre$ 的右孩子不为空，则其右孩子就是 $root$（第一次遍历时添加的线索）。说明已经遍历完 $root$ 的左子树，将 $pre$ 的右孩子置空（第二次遍历时置空，恢复为原来的左子树）。$root$ 加入结果，$root = root.right$（开始遍历 $root$ 的右子树）</li></ul></li><li>重复上述操作，直到 $root == NULL$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder_Morris</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-comment">// root 无右子树时，通过第一次遍历时添加的线索，找到 root 的直接后继</span><br>            <span class="hljs-comment">// root 有右子树时，开始遍历 root 的右子树</span><br>            root = root-&gt;right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode* pre = root-&gt;left;<br>            <span class="hljs-keyword">while</span> (pre-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;right != root) &#123;<br>                pre = pre-&gt;right;   <span class="hljs-comment">// 找到 root 的直接前驱</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (pre-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>                pre-&gt;right = root;  <span class="hljs-comment">// 第一次遍历时添加（线索）</span><br>                root = root-&gt;left;  <span class="hljs-comment">// 开始遍历 root 的左子树</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 线索 --- pre-&gt;right == root</span><br>                <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                pre-&gt;right = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 第二次遍历时置空，恢复为原来的左子树</span><br>                root = root-&gt;right; <span class="hljs-comment">// 开始遍历 root 的右子树</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-3-后序遍历"><a href="#1-2-3-后序遍历" class="headerlink" title="1.2.3 后序遍历"></a>1.2.3 后序遍历</h3><h4 id="1-递归-2"><a href="#1-递归-2" class="headerlink" title="1. 递归"></a>1. 递归</h4><h5 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    postOrder(root-&gt;left);<br>    postOrder(root-&gt;right);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：递归过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下为 $O(n)$，树呈现链状</p></li></ul><h4 id="2-迭代-2"><a href="#2-迭代-2" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><h5 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder_Interation</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">while</span> (!stk.empty() || root != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br><br>        root = stk.top();<br>        stk.pop();<br><br>        <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">NULL</span> || root-&gt;right == pre) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            pre = root;<br>            root = <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stk.push(root);<br>            root = root-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><p>时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。每个节点恰好被遍历一次</p></li><li><p>空间复杂度：迭代过程中栈的开销。平均情况下为 $O(\log n)$；最坏情况下树呈现链状，为 $O(n)$</p></li></ul><h4 id="3-Morris-后序遍历"><a href="#3-Morris-后序遍历" class="headerlink" title="3. Morris 后序遍历"></a>3. Morris 后序遍历</h4><p>新建临时节点，令该节点为 root；</p><p>如果当前节点的左子节点为空，则遍历当前节点的右子节点；</p><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；</p><p>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。</p><p>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。</p><p>重复步骤 2 和步骤 3，直到遍历结束。</p><h5 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h5><h5 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><h3 id="1-2-4-层序遍历"><a href="#1-2-4-层序遍历" class="headerlink" title="1.2.4 层序遍历"></a>1.2.4 层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layerOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>    que.push(root);<br><br>    <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>        TreeNode* root = que.front();<br>        que.pop();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>            que.push(root-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>            que.push(root-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-二叉树重建"><a href="#1-3-二叉树重建" class="headerlink" title="1.3 二叉树重建"></a>1.3 二叉树重建</h2><h3 id="1-3-1-中序-先序"><a href="#1-3-1-中序-先序" class="headerlink" title="1.3.1 中序 + 先序"></a>1.3.1 中序 + 先序</h3><h4 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode | 105. 从先序与中序遍历序列构造二叉树</a></p><h4 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree_byInPre</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> inLen = inorder.size();<br><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; inMap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inLen; ++i) &#123;<br>        inMap[inorder[i]] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> buildTree_byInPre(preorder, <span class="hljs-number">0</span>, inLen - <span class="hljs-number">1</span>, inMap, <span class="hljs-number">0</span>, inLen - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree_byInPre</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; inMap, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR || inL &gt; inR) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rootVal = preorder[preL];<br>    <span class="hljs-keyword">int</span> pivot = inMap[rootVal];<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(rootVal);<br><br>    root-&gt;left = buildTree_byInPre(preorder, preL + <span class="hljs-number">1</span>, preL + pivot - inL, inMap, inL, pivot - <span class="hljs-number">1</span>);<br>    root-&gt;right = buildTree_byInPre(preorder, preL + pivot - inL + <span class="hljs-number">1</span>, preR, inMap, pivot + <span class="hljs-number">1</span>, inR);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-中序-后序"><a href="#1-3-2-中序-后序" class="headerlink" title="1.3.2 中序 + 后序"></a>1.3.2 中序 + 后序</h3><h4 id="题目地址-1"><a href="#题目地址-1" class="headerlink" title="题目地址"></a>题目地址</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode | 106. 从中序与后序遍历序列构造二叉树</a></p><h4 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree_byInPost</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> inLen = inorder.size();<br><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; inMap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inLen; ++i) &#123;<br>        inMap[inorder[i]] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> buildTree_byInPost(postorder, <span class="hljs-number">0</span>, inLen - <span class="hljs-number">1</span>, inMap, <span class="hljs-number">0</span>, inLen - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree_byInPost</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-keyword">int</span> postL, <span class="hljs-keyword">int</span> postR, <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; inMap, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (postL &gt; postR || inL &gt; inR) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rootVal = postorder[postR];<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(rootVal);<br>    <span class="hljs-keyword">int</span> pivot = inMap[rootVal];<br><br>    root-&gt;left = buildTree_byInPost(postorder, postL, postL + pivot - inL - <span class="hljs-number">1</span>, inMap, inL, pivot - <span class="hljs-number">1</span>);<br>    root-&gt;right = buildTree_byInPost(postorder, postL + pivot - inL, postR - <span class="hljs-number">1</span>, inMap, pivot + <span class="hljs-number">1</span>, inR);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>$root$ 无左孩子<ul><li>$root$ 加入结果</li><li>$x = x.right$（$root$ 无右子树时，通过第一次遍历时添加的线索，找到 $root$ 的直接后继；$root$ 有右子树时，开始遍历 $root$ 的右子树）</li></ul></li><li>$root$ 有左孩子，找到 $root$ 在中序遍历下的直接前驱 $pre$<ul><li>$pre$ 的右孩子为空，$pre.right = root$<strong>「线索」</strong>，$root = root.left$（开始遍历 $root$ 的左子树）</li><li>$pre$ 的右孩子不为空，则其右孩子就是 $root$（第一次遍历时添加的线索）。说明已经遍历完 $root$ 的左子树，将 $pre$ 的右孩子置空（第二次遍历时置空，恢复为原来的左子树）。$root$ 加入结果，$root = root.right$（开始遍历 $root$ 的右子树）</li></ul></li></ol><h2 id="1-4-二叉搜索树-BST"><a href="#1-4-二叉搜索树-BST" class="headerlink" title="1.4 二叉搜索树 BST"></a>1.4 二叉搜索树 BST</h2><h3 id="不同的二叉搜索树-Ⅱ"><a href="#不同的二叉搜索树-Ⅱ" class="headerlink" title="不同的二叉搜索树 Ⅱ"></a>不同的二叉搜索树 Ⅱ</h3><h4 id="题目地址-2"><a href="#题目地址-2" class="headerlink" title="题目地址"></a>题目地址</h4><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">LeetCode | 95. 不同的二叉搜索树 Ⅱ</a></p><h4 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> generateTrees(<span class="hljs-number">1</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; Trees;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; ++i) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; rightTrees = generateTrees(i + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; left : leftTrees) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; right : rightTrees) &#123;<br>                TreeNode* tree = <span class="hljs-keyword">new</span> TreeNode(i, left, right);<br>                Trees.push_back(tree);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Trees;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-完全二叉树"><a href="#1-5-完全二叉树" class="headerlink" title="1.5 完全二叉树"></a>1.5 完全二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">LeetCode | 222. 完全二叉树的节点个数</a></p><h3 id="二分查找-位运算"><a href="#二分查找-位运算" class="headerlink" title="二分查找 + 位运算"></a>二分查找 + 位运算</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>假设，完全二叉树的层数为 $h$（根节点所在层数为 1），则</p><ul><li>前 $h-1$ 层的节点总数 $= 2^{h-1}-1$</li><li>前 $h$ 层的节点总数 $= 2^h-1$</li><li>第 $h$ 层的节点编号 $\in [2^{h-1}, 2^h-1]$</li></ul><p>我们可以在 $[2^{h-1}, 2^h-1]$ 范围内使用二分查找得到最大节点编号</p><p><strong>具体方法</strong></p><p>当节点 $mid$ 存在时，最大节点编号一定在 $mid$ 的右边（包括 $mid$），即 $left = mid$<br>当节点 $mid$ 不存在时，最大节点编号一定在 $mid$ 的左边，即 $right = mid - 1$</p><p><strong>如何判断节点 $mid$ 是否存在</strong></p><p>显然，如果我们能够通过根节点到达节点 $mid$，即可通过判断节点 $mid$ 是否为 $NULL$ 判断节点 $mid$ 是否存在</p><p>因此，问题的关键就变成如何找到根节点到节点 $mid$ 的一条路径，可以通过 <strong>「位运算」</strong> 来实现</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>从根节点到目的节点的一条路径，无非就是不断地向左走或向右走，最终到达目的节点</p><p>我们写出所有节点编号的二进制，发现每个子节点都是在父节点后面 + 0/1。具体来说，左孩子 +0，右孩子 +1<br>因此，我们可以从二进制的第 2 位开始，判断每一位是 0 是 1，是 0 则向左走，是 1 则向右走</p><p>可以发现，叶节点的二进制去掉最高位即为 <strong>「哈夫曼编码」</strong></p><p><strong>举例说明</strong></p><p>6 号节点的二进制为 110</p><ul><li>第 2 位是 1，则从根节点向右走</li><li>第 3 位是 0，则继续向左走，最终到达 6 号节点</li></ul><p><strong>如何判断当前位是 0 是 1</strong></p><ul><li>判断 110 的第 2 位，可以通过 010 &amp; 110 = 010 ≠ 0，即第 2 位是 1</li><li>判断 110 的第 3 位，可以通过 001 &amp; 110 = 000 = 0，即第 3 位是 0</li></ul><p><strong>代码如何实现</strong></p><ul><li>假设完全二叉树的层数为 $h$，则初始化一个变量 $bits = 1 &lt;&lt; (h-2)$。例如，下图中完全二叉树的层数为 3，则初始化 $bits = 010$</li><li>每次进行位运算 $bits$ &amp; $mid$ 后，$bits &gt;&gt; 1$</li></ul><p><img src="https://s.im5i.com/2021/05/13/9UPvD.png" alt="Bit calculate"></p><h4 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>    TreeNode* node = root;<br>    <br>    <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>        level++;<br>        node = node-&gt;left;<br>    &#125;<br>    <br>    <span class="hljs-comment">// level 层完全二叉树的结点数范围为 [2^(level-1), 2^level-1]</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> right = (<span class="hljs-number">1</span> &lt;&lt; level) - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> ()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><ul><li><p>完全二叉树的每个节点对应一个二进制码（与哈夫曼编码类似）。规定根结点编码为 1，根结点往左边走为 0，往右边走为 1</p></li><li><p>例如，第 2 层的第一个结点编码为 10，第二个结点编码为 11。可以发现，结点编码对应结点编号。可以通过计算目的结点的编码，从编码的第 2 位开始，0 表示向左走，1 表示向右走。从而，快速找到从根结点到目的结点的一条路径<br>如果中途有结点 == NULL，则说明目的结点不存在</p><p>例如，12 号结点编码为 1100，从第 2 位开始判断当前位是0是1<br>可以用 0100 &amp; 1100 ，得到 0100 != 0，即第 2 位为 1，从根结点向右走<br>同样，用 0010 &amp; 1100，得到 0000 == 0，即第 3 位为 0，继续向左走<br>最后，用 0001 &amp; 1100，得到 0000 == 0，即第 4 位为 0，继续向左走<br>最后判断 12 号结点是否存在</p></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;    <span class="hljs-keyword">return</span> root == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-1-题目"><a href="#5-1-1-题目" class="headerlink" title="5.1.1 题目"></a>5.1.1 题目</h3><p><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104. 二叉树寻路</a></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>假设完全二叉树的根结点编号为 $1$ ，对于编号为 $i$ 的结点 $x$，二叉树具有以下性质：</p><ul><li>$x.left$ 的编号为 $2*x$</li><li>$x.right$ 的编号为 $2*x + 1$</li><li>同理，结点 $x$ 的父结点的编号为 $\frac{x}{2}$</li></ul><p>因此，对于编号为 $label$ 的结点，可以在完全二叉树中找编号从 $label$ 到 $1$ 的一条到达根结点的路径。</p><p>注意，上面所述的完全二叉树要么都是按「从左到右」进行编号，要么都是按「从右到左」进行编号，而题目中完全二叉树的奇数层按「从左到右」进行编号，偶数层（根结点在第 $1$ 层）按「从右到左」进行编号。</p><p><strong>那么，编号逆转后会发生哪些变化呢？</strong></p><p>考虑第 $3$ 层，如果从左到右进行编号，结果为 $[4,5,6,7]$；如果从右到左进行编号，结果为 $[7,6,5,4]$。可以发现，对于第一个结点，编号由 $4$ 变成了 $7$；对于第二个结点，编号由 $5$ 变成了 $6$，而他们的和均为 $11$。因此，我们有理由相信，每一层都有一个和 $sum$，使得对于固定位置的结点 $x$，逆转前的编号为 $num$，逆转后的编号则为 $sum - num$。</p><p>接下来，我们通过下表找规律</p><table><thead><tr><th>第 $i$ 层</th><th>逆转前（假设从左到右进行编号）</th><th>逆转后</th><th>$sum$</th></tr></thead><tbody><tr><td>$1$</td><td>$[1]$</td><td>$[1]$</td><td>$1$</td></tr><tr><td>$2$</td><td>$[2, 3]$</td><td>$[3,2]$</td><td>$2+3=5$</td></tr><tr><td>$3$</td><td>$[4,5,6,7]$</td><td>$[7,6,5,4]$</td><td>$4+7=11$</td></tr><tr><td>$4$</td><td>$[8,9,10,11,12,13,14,15]$</td><td>$[15,14,13,12,11,10,9,8]$</td><td>$8+15=23$</td></tr></tbody></table><p>我们可以大胆猜测，第 $5$ 的 $sum = 47$，第 $6$ 层的 $sum = 95$，为什么呢？</p><p>找规律可以发现，从第 $3$ 层开始，$11=5<em>2+1，$$23=11</em>2+1$，可能看上去这样的猜想过于草率，但无数的发现不都是从所谓的直觉开始的吗？事实上，我做这道题时，也不知道完全二叉树有这样的性质，我也是通过找规律发现这个结论的。</p><p>不过不用担心，我们可以通过严格的数学推导证明这个结论，但对于解题而言，追求严格的数学证明显然不是明智之举，我们先根据这个结论来解题，数学推导放在最后，留给感兴趣的同学！</p><p><strong>那么，这个看似正确的结论对于我们解题有什么帮助吗？答案是肯定的。</strong></p><p>以示例 $2$ 为例，$label = 26$，输出应为 $[1,2,6,10,26]$，逆转前的结果为 $[1,3,6,13,26]$。</p><p>我们可以不必关系奇偶层数，只需知道 $label$ 所在的层数与其上一层的编号方向一定是相反的（不必关心从左到右，还是从右到左），而与其上两层的编号方向一定是相同的。那么，通过上面的结论，只要发生逆转，编号就从 $num$ 变成 $sum-num$。</p><p>因此，对于逆转前的结果 $[1,3,6,13,26]$，逆转操作：$26$ 的上一层是第 $4$ 层的 $13$，逆转后应为 $23-13=10$，而第 $2$ 层的 $3$ 逆转后应为 $5-3=2$，最后输出 $[1,2,6,10,26]$</p><p>假设，结果列表大小为 $size$，可以从 $i=size-2$ 开始从右向左修改编号，步长为 $i-=2$，因为第一个编号始终为 $1$，所以边界为 $i&gt;0$</p><p>此外，我们需要一个数组 $sum[]$ 保存前面提到的 $sum$，因为最后一个编号 $label$ 一定不会被修改，所以 $sum[]$ 的大小为 $size-1$</p><h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">pathInZigZagTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> label)</span> </span>&#123;<br>        List&lt;Integer&gt; rev = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (label &gt;= <span class="hljs-number">1</span>) &#123;<br>            rev.add(label);<br>            label &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = rev.size();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            res.add(rev.get(i));<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sum.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) &#123;<br>                sum[i] = (i == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">5</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum[i] = (sum[i - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>) &#123;<br>            res.set(i, sum[i] - res.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="放在最后，数学证明"><a href="#放在最后，数学证明" class="headerlink" title="放在最后，数学证明"></a>放在最后，数学证明</h3><p>我们需要证明</p><ul><li>$S(1)=1$</li><li>$S(2)=5$</li><li>$S(i)=2S(i-1)+1$，$i≥3$</li></ul><p>首先，我们需要知道完全二叉树的基本性质，$$</p><ul><li>前 $i(i≥1)$ 层的结点数 = $2^{i}-1$</li><li>第 $i(i≥1)$ 层的结点数 = $2^{i-1}$</li></ul><p>假设完全二叉树从做左到右进行编号，那么</p><ul><li>第 $i(i≥2)$ 层的最左边结点的编号 = 前 $i-1$ 层的结点数 + $1$ = $2^{i-1}-1+1 = 2^{i-1}$</li><li>第 $i(i≥2)$ 层的最右边结点的编号 = 前 $i$ 层的结点数 = $2^{i}-1$</li></ul><p>设第 $i$ 层的 $sum$ 为 $S(i)$，那么</p><ul><li>$i≥2$ 时，$S(i) = 2^{i-1}+2^{i}-1$</li><li>$i≥3$ 时，$S(i) = 2(2^{i-2}+2^{i-1})-1 = 2(2^{i-2}+2^{i-1}-1)+1$</li><li>$i≥3$ 时，$S(i) = 2S(i-1)+1$，证毕</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>遍历</tag>
      
      <tag>DFS</tag>
      
      <tag>BSF</tag>
      
      <tag>完全二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5 双指针</title>
    <link href="/2021/02/12/LeetCode/6%20%20%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2021/02/12/LeetCode/6%20%20%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">LeetCode | 209. 长度最小的子数组</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>当单个元素 ≥ $target$ 时，返回 1</li><li>当 $[start, end]$ 的元素之和 &lt; $target$ 时，$end = end + 1$</li><li>当 $[start, end]$ 的元素之和 ≥ $target$ 时，若当前长度 &lt; $minLen$，更新 $minLen$。同时 $start = start + 1$</li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">int</span> minLen = n + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sum = nums[start];<br><br>    <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>            <span class="hljs-keyword">if</span> (end - start + <span class="hljs-number">1</span> &lt; minLen) &#123;<br>                minLen = end - start + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (minLen == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            sum -= nums[start++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (end == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 没有该句，可能发生溢出</span><br>            sum += nums[++end];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> minLen == n + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : minLen;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3 二分查找</title>
    <link href="/2021/02/08/LeetCode/5%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/02/08/LeetCode/5%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-两个有序数组的中位数"><a href="#3-1-两个有序数组的中位数" class="headerlink" title="3.1 两个有序数组的中位数"></a>3.1 两个有序数组的中位数</h2><h3 id="3-1-1-题目地址"><a href="#3-1-1-题目地址" class="headerlink" title="3.1.1 题目地址"></a>3.1.1 题目地址</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode | 4. 寻找两个有序数组的中位数</a></p><h3 id="3-1-2-解题思路"><a href="#3-1-2-解题思路" class="headerlink" title="3.1.2 解题思路"></a>3.1.2 解题思路</h3><p>假设数组 $nums1$ 的长度为 $m$，数组 $nums2$ 的长度为 $n$<br>我们需要使用二分查找，寻找一条分割线，将 $m+n$ 个元素均分，使得分割线左边的元素 ≤ 分割线右边的元素<br>我们假设，分割线左边的元素个数至多比分割线右边的元素个数多 1 个</p><h4 id="1-两种情况"><a href="#1-两种情况" class="headerlink" title="1. 两种情况"></a>1. 两种情况</h4><p>当 $(m+n)%2=0$ 时，$size_{left} = size_{right}$，中位数 = 分割线左边的最大值</p><p><img src="https://s.im5i.com/2021/05/13/9dYkM.png" alt="Even"></p><p>当 $(m+n)%2=1$ 为奇数时，$size_{left} = size_{right} + 1$，中位数 = 分割线左边的最大值与分割线右边的最小值的平均值</p><p><img src="https://s.im5i.com/2021/05/13/9diOX.png" alt="Odd"></p><p>因此<br>$$<br>size_{left} = \frac{m+n+1}{2}<br>$$</p><h4 id="2-如何定义分割线"><a href="#2-如何定义分割线" class="headerlink" title="2. 如何定义分割线"></a>2. 如何定义分割线</h4><p>我们可以将 $nums1$ 中分割线右边元素的索引定义为 $i$，$nums2$ 中分割线右边元素的索引定义为 $j$</p><p>在 $nums1$ 中，使用二分查找找到最终 $i$ 的位置，则 $j = size_{left} - i$</p><h4 id="3-最后的结果"><a href="#3-最后的结果" class="headerlink" title="3. 最后的结果"></a>3. 最后的结果</h4><p>当 $(m+n)%2=0$ 时<br>$$<br>中位数 = max(nums1[i-1], nums2[j-1])<br>$$<br>当 $(m+n)%2=1$ 时<br>$$<br>中位数 = \frac{max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])} {2}<br>$$</p><h4 id="4-四种特殊情况"><a href="#4-四种特殊情况" class="headerlink" title="4. 四种特殊情况"></a>4. 四种特殊情况</h4><p><img src="https://s.im5i.com/2021/05/13/9dLDf.png" alt="Four special cases"></p><h3 id="3-1-3-Code"><a href="#3-1-3-Code" class="headerlink" title="3.1.3 Code"></a>3.1.3 Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp = nums1;<br>        nums1 = nums2;<br>        nums2 = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> m = nums1.size();<br>    <span class="hljs-keyword">int</span> n = nums2.size();<br>    <span class="hljs-keyword">int</span> totalLeft = m + (n - m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = m;<br><br>    <span class="hljs-comment">// 在 nums1 的区间 [0, m] 里查找恰当的分割线</span><br>    <span class="hljs-comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span><br><br>    <span class="hljs-comment">// ---------------- 以 nums1[i - 1] &lt;= nums2[j] 为条件 ---------------</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> i = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> j = totalLeft - i;<br>        <span class="hljs-comment">// [left, right] = [0, 1] 时，i = 1，故 i-1 不会越界</span><br>        <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] &gt; nums2[j]) &#123;<br>            right = i - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = totalLeft - i;<br><br>    <span class="hljs-keyword">int</span> nums1LeftMax = i == <span class="hljs-number">0</span> ? INT_MIN : nums1[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> nums1RightMin = i == m ? INT_MAX : nums1[i];<br>    <span class="hljs-keyword">int</span> nums2LeftMax = j == <span class="hljs-number">0</span> ? INT_MIN : nums2[j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> nums2RightMin = j == n ? INT_MAX : nums2[j];<br><br>    <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 中位数为分割线左边的最大值</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)max(nums1LeftMax, nums2LeftMax);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 中位数为分割线左边的最大值和右边的最小值的平均值</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(max(nums1LeftMax, nums2LeftMax) + min(nums1RightMin, nums2RightMin)) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------------- 以 nums1[j - 1] &lt;= nums2[i] 为条件 ---------------</span><br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-keyword">int</span> i = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">// 不能 +1, 会发生死循环</span><br>    <span class="hljs-keyword">int</span> j = totalLeft - i;<br>    <span class="hljs-keyword">if</span> (nums2[j - <span class="hljs-number">1</span>] &gt; nums1[i]) &#123;<br>        left = i + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 动态规划</title>
    <link href="/2021/01/31/LeetCode/3%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/01/31/LeetCode/3%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-最长回文子串"><a href="#3-1-最长回文子串" class="headerlink" title="3.1 最长回文子串"></a>3.1 最长回文子串</h2><h3 id="3-1-1-题目地址"><a href="#3-1-1-题目地址" class="headerlink" title="3.1.1 题目地址"></a>3.1.1 题目地址</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode | 5. 最长回文子串</a></p><h3 id="3-1-2-解题思路"><a href="#3-1-2-解题思路" class="headerlink" title="3.1.2 解题思路"></a>3.1.2 解题思路</h3><h4 id="1-状态"><a href="#1-状态" class="headerlink" title="1. 状态"></a>1. 状态</h4><p>$dp[i][j]$ 表示子串 $s[i..j]$ 是否为回文串，<strong>注意 $j &gt; i$</strong></p><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><p>每个字符本身是一个长度为 1 的回文子串，故 $dp[i][i] = true$<br>要求 $j &gt; i$，故对角线左下方的值应初始化为 $false$，实际上并不会用到该部分的值</p><h4 id="3-边界条件"><a href="#3-边界条件" class="headerlink" title="3. 边界条件"></a>3. 边界条件</h4><p>$j &gt; i$，即只需关心 $dp[i][j]$ 对角线右上方的值<br>$j - i &lt; 3$，即 $s[i..j]$ 长度为 2 或 3 时，不用检查子串 $dp[i+1][j-1]$ 是否是回文串</p><h4 id="4-状态转移方程"><a href="#4-状态转移方程" class="headerlink" title="4. 状态转移方程"></a>4. 状态转移方程</h4><ul><li><p>$s[i] ≠ s[j]$ 时，$dp[i][j] = false$</p></li><li><p>$s[i] = s[j]$ 时，若 $j - i &lt; 3$，则 $dp[i][j] = true$。如 $aba,aa$<br>否则 $dp[i][j] = dp[i+1][j-1]$。如 $abca$，$j - i = 3$，需要参考 $dp[i+1][j-1]$ 的状态</p></li></ul><h4 id="5-输出"><a href="#5-输出" class="headerlink" title="5. 输出"></a>5. 输出</h4><p>$dp[i][j] = true$ 时，若当前长度 &gt; 最大长度，则记录当前起始位置并更新最大长度，填完表后再截取</p><h4 id="6-填表方向"><a href="#6-填表方向" class="headerlink" title="6. 填表方向"></a>6. 填表方向</h4><p>因为 $dp[i][j]$ 可能会参考其左下方 $dp[i+1][j-1]$ 的值，故须保证 $dp[i+1][j-1]$ 的值已经给出，即填表方向应为上下左右（或下上左右）</p><h3 id="3-1-3-Code"><a href="#3-1-3-Code" class="headerlink" title="3.1.3 Code"></a>3.1.3 Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[i][i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// dp[i][j] == true, 表示 s[i..j] 是回文，此时记录回文长度和其实位置</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                maxLen = j - i + <span class="hljs-number">1</span>;<br>                begin = i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> s.substr(begin, maxLen);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-最长公共子序列"><a href="#3-2-最长公共子序列" class="headerlink" title="3.2 最长公共子序列"></a>3.2 最长公共子序列</h2><h3 id="3-2-1-题目地址"><a href="#3-2-1-题目地址" class="headerlink" title="3.2.1 题目地址"></a>3.2.1 题目地址</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode | 1143. 最长公共子序列</a></p><h3 id="3-2-2-解题思路"><a href="#3-2-2-解题思路" class="headerlink" title="3.2.2 解题思路"></a>3.2.2 解题思路</h3><h4 id="1-状态-1"><a href="#1-状态-1" class="headerlink" title="1. 状态"></a>1. 状态</h4><p>$dp[i][j]$ 表示 $text1[1..i],text2[1..j]$ 的最长公共子序列的长度</p><h4 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><p>$dp[0][0:] = dp[0:][0] = 0$</p><ul><li>$dp[0][0:]$ 表示第 0 行的第 0 列及其后面的所有元素，$dp[0:][0]$ 同理</li><li>在 $text1$ 前面插入一个任意字符（下方代码以一个空格为例），保证下标都从 1 开始，同时初始化后使得代码更加简洁</li><li>并将该字符即 $text1[0]$ 看作是一个空字符</li><li>则 $dp[0][0..j]$ 表示 $text1[0]$ 和 $text2[0..j]$ 的最长公共子序列的长度。显然，$dp[0][0:] = 0$</li><li>同理，$dp[0:][0] = 0$</li></ul><h4 id="3-边界条件-1"><a href="#3-边界条件-1" class="headerlink" title="3. 边界条件"></a>3. 边界条件</h4><p>$1 ≤ i ≤ M,1 ≤ j ≤  N$，其中 $M, N$ 分别表示 $text1, text2$ 插入首字符前的长度</p><h4 id="4-状态转移方程-1"><a href="#4-状态转移方程-1" class="headerlink" title="4. 状态转移方程"></a>4. 状态转移方程</h4><p>$text1[i] = text2[j]$ 时，$dp[i][j] = dp[i-1][j-1] + 1$<br>$text1[i] ≠ text2[j]$ 时，$dp[i][j] = max(dp[i][j-1], dp[i-1][j])$</p><h4 id="5-输出-1"><a href="#5-输出-1" class="headerlink" title="5. 输出"></a>5. 输出</h4><p>$dp[M][N]$ 表示 $text1, text2$ 的最长公共子序列的长度</p><h4 id="6-填表方向-1"><a href="#6-填表方向-1" class="headerlink" title="6. 填表方向"></a>6. 填表方向</h4><p>左右上下（或上下左右）</p><h3 id="3-2-3-Code"><a href="#3-2-3-Code" class="headerlink" title="3.2.3 Code"></a>3.2.3 Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text1, <span class="hljs-built_in">string</span> text2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> M = text1.size();<br>    <span class="hljs-keyword">int</span> N = text2.size();<br><br>    text1 = <span class="hljs-string">&#x27; &#x27;</span> + text1;<span class="hljs-comment">// 在 text1 和 text2 前面插入任意字符(这里插入一个空格)</span><br>    text2 = <span class="hljs-string">&#x27; &#x27;</span> + text2;<span class="hljs-comment">// 保证下标都从1开始，同时初始化后使得代码更加简洁</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(M + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 初始化为 0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= M; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (text1[i] == text2[j]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[M][N];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-4-拓展：输出最长公共子序列"><a href="#3-2-4-拓展：输出最长公共子序列" class="headerlink" title="3.2.4 拓展：输出最长公共子序列"></a>3.2.4 拓展：输出最长公共子序列</h3><h4 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1. 解题思路"></a>1. 解题思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">从 dp[M][N] 出发<br><span class="hljs-keyword">if</span> (text1[M] == text2[N]) &#123;<br>    比较 text1[M<span class="hljs-number">-1</span>] 和 text2[N<span class="hljs-number">-1</span>]<br>    并记录 text1[M]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (dp[M]&#123;N&#125; == dp[M][N<span class="hljs-number">-1</span>]) 比较 text1[M] 和 text2[N<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">if</span> (dp[M]&#123;N&#125; == dp[M<span class="hljs-number">-1</span>][N]) 比较 text1[M<span class="hljs-number">-1</span>] 和 text2[N]<br>&#125;<br>边界条件：M &gt; <span class="hljs-number">0</span> &amp;&amp; N &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://s.im5i.com/2021/05/13/9dUYy.png" alt="Longest common subsequence"></p><h4 id="2-Code"><a href="#2-Code" class="headerlink" title="2. Code"></a>2. Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printLCS</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-keyword">while</span> (M &gt; <span class="hljs-number">0</span> &amp;&amp; N &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (text1[M] == text2[N]) &#123;<br>            res = text1[M] + res;<br>            --M;<br>            --N;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (dp[M][N] == dp[M][N - <span class="hljs-number">1</span>]) &#123;<br>                --N;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --M;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-不同的二叉搜索树"><a href="#3-3-不同的二叉搜索树" class="headerlink" title="3.3 不同的二叉搜索树"></a>3.3 不同的二叉搜索树</h2><h3 id="3-3-1-题目地址"><a href="#3-3-1-题目地址" class="headerlink" title="3.3.1 题目地址"></a>3.3.1 题目地址</h3><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode | 95. 不同的二叉搜索树</a></p><h3 id="3-3-2-解题思路"><a href="#3-3-2-解题思路" class="headerlink" title="3.3.2 解题思路"></a>3.3.2 解题思路</h3><h4 id="1-状态-2"><a href="#1-状态-2" class="headerlink" title="1. 状态"></a>1. 状态</h4><p>$dp[i]$ 表示 $i$ 个结点构成的二叉搜索树（BST）个数</p><h4 id="2-初始化-2"><a href="#2-初始化-2" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><p>$i = 0$ 时，无根结点时 (空树)，BST 个数规定为 1，即 $dp[0] = 1$<br>$i = 1$ 时，根结点为 1 时，BST 个数 = 1，即 $dp[1] = dp[0]×dp[0] = 1$</p><h4 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3. 状态转移方程"></a>3. 状态转移方程</h4><p>设根结点为 $j\in [1,i]$ 的 BST 个数为 $root(j)$<br>(左子树) $j-1$ 个结点构成的 BST 个数为 $dp[j-1]$<br>(右子树) $i-j$ 个结点构成的 BST 个数为 $dp[i-j]$</p><p>则 $$dp[i] = \sum_{j=1}^i root(j) = \sum_{j=1}^i (dp[j-1] × dp[i-j])$$</p><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p>$dp[1] = dp[0]×dp[0]$<br>$dp[2] = dp[0]×dp[1] + dp[1]×dp[0] = 1 + 1 =2$<br>$dp[3] = dp[0]×dp[2] + dp[1]×dp[1] + dp[2]×dp[0] = 2 + 1 + 2 = 5$</p><p><img src="https://s.im5i.com/2021/05/13/9ddVh.png" alt="Different binary search trees"></p><h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4. 输出"></a>4. 输出</h4><p>$dp[n]$ 表示 $n$ 个结点构成的二叉搜索树（BST）个数</p><h4 id="5-填表方向"><a href="#5-填表方向" class="headerlink" title="5. 填表方向"></a>5. 填表方向</h4><p>左右</p><h3 id="3-2-3-Code-1"><a href="#3-2-3-Code-1" class="headerlink" title="3.2.3 Code"></a>3.2.3 Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;<br>            dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试</title>
    <link href="/2021/01/21/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/01/21/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="华信（华为面）—-2020-1-21，21-00-21-50"><a href="#华信（华为面）—-2020-1-21，21-00-21-50" class="headerlink" title="华信（华为面）— 2020/1/21，21:00-21:50"></a>华信（华为面）— 2020/1/21，21:00-21:50</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li>vector 和 list 的区别</li><li>map 和 set 的区别</li><li>C++11 新特性</li><li>智能指针</li><li>lambda</li><li>free 后指针和指针指向的内存内容如何变化（都不变，只是该块内存能被其他进程占用，即失去所有权）</li><li>全局变量、局部变量、静态变量所在的内存位置</li><li>指针函数和函数指针</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>二叉树遍历（非递归）</li></ul><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>C/C++ 编译过程</li><li>lib 和 dll 的区别</li><li>dll（window） 和 so（linux）的区别</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>生产者与消费者模型</li><li>同步与异步</li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><ul><li>调试（内存泄露、地址越界）</li><li>测试用例如何编写</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li>字节码</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华信（华为面）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 程序设计</title>
    <link href="/2021/01/17/Linux/shell%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/01/17/Linux/shell%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="shell-的语法"><a href="#shell-的语法" class="headerlink" title="shell 的语法"></a>shell 的语法</h2><ul><li>变量：字符串、数字、环境和参数</li><li>条件：shell中的布尔值</li><li>程序控制：if、elif、for、while、until、case</li><li>命令列表</li><li>函数</li><li>shell 内置命令</li><li>获取命令的执行结果</li><li>here 文档</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>须知</p></blockquote><ul><li>默认情况下，所有变量都被看作字符串并以字符串来存储，即使它们被赋值为数值时也是如此</li><li>shell 和一些工具程序会在需要时把数值型字符串转换为对应的数值以对它们进行操作</li><li>Linux 是一个区分大小写的系统，因此 shell 认为变量 foo 与 Foo 是不同的</li></ul><blockquote><p>在变量名前加一个 <code>$</code> 符号来访问它的内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> var=hello</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span></span><br>hello<br><span class="hljs-meta">$</span><span class="bash"> var=<span class="hljs-string">&quot;hello world&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span></span><br>hello world<br><span class="hljs-meta">$</span><span class="bash"> var=7+5</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span></span><br>7+5<br></code></pre></td></tr></table></figure><ul><li>为变量赋值时，只需要使用变量名，该变量会根据需要被自动创建</li><li>若字符串里包含空格，则必须用引号把它们括起来</li><li>等号两边不能有空格</li></ul><blockquote><p>使用 <code>read</code> 命令将用户的输入赋值给一个变量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">read</span> var</span><br>my name is Ken.<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span></span><br>my name is Ken.<br></code></pre></td></tr></table></figure><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><blockquote><p>创建一个文件，并使用 <code>vi</code> 命令进入 <code>vim</code> 编辑器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> touch useVar.sh   <span class="hljs-comment"># linux 中文件后缀并不重要，而指明后缀只是让用户清楚文件类型</span></span><br><span class="hljs-meta">$</span><span class="bash"> vi useVar.sh</span><br></code></pre></td></tr></table></figure><blockquote><p>在 <code>vim</code> 中编辑文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">！/bin/sh</span><br>myvar=&quot;Hi there&quot;<br><br>echo $myvar<br>echo &quot;$myvar&quot;<br>echo &#x27;$myvar&#x27;<br>echo \$myvar<br><br>echo Enter some text:<br>read myvar<br><br>echo &#x27;$myvar&#x27; == $myvar<br>exit 0<br></code></pre></td></tr></table></figure><ul><li>第一行的 <code>#!/bin/sh</code> 是一种特殊的注释，<code>#!</code> 字符后面紧跟的参数用于指明执行本文件的程序</li><li>本例中，<code>/bin/sh</code> 是默认的 shell 程序</li></ul><blockquote><p>两种执行脚本的方法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> /bin/sh useVar.sh     <span class="hljs-comment"># 调用 shell 程序，并将文件名作为一个参数</span></span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> chmod +x useVar.sh    <span class="hljs-comment"># 将文件模式修改为 -&gt; 可执行</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./useVar.sh           <span class="hljs-comment"># 执行文件。注意是当前目录 ./useVar.sh，而不是根目录 /usevar.sh</span></span><br></code></pre></td></tr></table></figure><blockquote><p>输出结果</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi there<br>Hi there<br><span class="hljs-meta">$</span><span class="bash">myvar</span><br><span class="hljs-meta">$</span><span class="bash">myvar</span><br>Enter some text:<br>Hello World<br><span class="hljs-meta">$</span><span class="bash">myvar == Hello World</span><br></code></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li><code>$HOME</code> 当前用户的家目录</li><li><code>$PATH</code> 以冒号分隔的用来搜索命令的目录列表</li><li><code>$PS1</code> 命令提示符。通常是 <code>$</code> 字符</li><li><code>$PS2</code> 二级提示符。用来提示后续的输入，通常是&gt;字符</li><li><code>$IFS</code> 输入域分隔符。通常是空格、制表符和换行符</li><li><code>$0</code> shell 脚本的名字。默认是 bash</li><li><code>$#</code> 传递给脚本的参数个数</li><li><code>$$</code> shell 脚本的进程号。可以用 <code>ps</code> 命令查看当前运行的所有进程</li></ul><h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h3><ul><li><code>$1, $2, ...</code> 传递给脚本的参数</li><li><code>$*</code> 在一个变量中列出所有的参数，各个参数之间用环境变量IFS中的第一个字符分隔开</li><li><code>$@</code> 不使用 <code>IFS</code> 环境变量，所以即使 <code>IFS</code> 为空，参数也不会挤在一起。访问脚本参数时，应使用 <code>$@</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用类</title>
    <link href="/2021/01/09/C++/%E4%BD%BF%E7%94%A8%E7%B1%BB/"/>
    <url>/2021/01/09/C++/%E4%BD%BF%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Time &amp;t) <span class="hljs-keyword">const</span>;<br>Time Time::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Time &amp;t) <span class="hljs-keyword">const</span>&#123;   <br>    Time sum;<br>    sum.minutes = minutes + t.minutes;<br>    sum.hours = hours + t.hours + sum.minutes / <span class="hljs-number">60</span>;<br>    sum.minutes %= <span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">return</span> sum;     <span class="hljs-comment">// 返回对象不应是引用，避免返回指向局部变量或临时对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">t4 = t1 + t2 + t3;<br>=&gt;<br>t4 = t1.<span class="hljs-keyword">operator</span>+(t2 + t3);<br>t4 = t1.<span class="hljs-keyword">operator</span>+(t2.<span class="hljs-keyword">operator</span>+(t3));<br></code></pre></td></tr></table></figure><h3 id="作为成员函数还是友元函数"><a href="#作为成员函数还是友元函数" class="headerlink" title="作为成员函数还是友元函数"></a>作为成员函数还是友元函数</h3><blockquote><p>成员函数：一个操作数通过 <code>this</code> 指针隐式传递，另一个操作数作为函数参数显式传递</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Time &amp;t);<br></code></pre></td></tr></table></figure><blockquote><p>友元函数：两个操作数都作为参数来传递</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Time &amp;t1, <span class="hljs-keyword">const</span> Time &amp;t2);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">T1 = T2 + T3;<br>=&gt;<br>T1 = T2.<span class="hljs-keyword">operator</span>+(T3);  <span class="hljs-comment">// 成员函数</span><br>T2 = <span class="hljs-keyword">operator</span>+(T2, T3); <span class="hljs-comment">// 友元函数</span><br></code></pre></td></tr></table></figure><ul><li>友元函数所需的形参数目与运算符使用的操作数数目相同</li><li>成员函数所需的参数数目少一个，因为其中的一个操作数被隐式地传递的调用对象</li><li>不能同时定义这两种函数</li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><h3 id="如何创建-1"><a href="#如何创建-1" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> m, <span class="hljs-keyword">const</span> Time &amp;t)&#123;<br>    <span class="hljs-keyword">return</span> t * m;   <span class="hljs-comment">// t.operator*(m)</span><br>&#125;<br><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> m, <span class="hljs-keyword">const</span> Time &amp;t);<br></code></pre></td></tr></table></figure><ul><li>友元函数是可以直接访问类的私有成员的非成员函数</li><li>声明在类中（可以在私有部分和公有部分中声明，没有区别），定义在类外（不需要 <code>ClassName::</code>）</li><li>一个函数可以是多个类的友元函数，只需在各个类中分别声明</li></ul><h3 id="如何调用-1"><a href="#如何调用-1" class="headerlink" title="如何调用"></a>如何调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">A = <span class="hljs-number">2.75</span> * B;<br>A = <span class="hljs-keyword">operator</span>*(<span class="hljs-number">2.75</span>, B);<br></code></pre></td></tr></table></figure><h3 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载 &lt;&lt; 运算符"></a>重载 &lt;&lt; 运算符</h3><h4 id="为什么必须使用友元函数"><a href="#为什么必须使用友元函数" class="headerlink" title="为什么必须使用友元函数"></a>为什么必须使用友元函数</h4><ul><li>若使用 <code>Time</code> 成员函数来重载 &lt;&lt;，则 <code>Time</code> 对象将是第一个操作数：<code>trip &lt;&lt; cout</code></li><li>这样会令人迷惑，但通过友元函数，可以这样使用：<code>cout &lt;&lt; trip;</code></li></ul><h4 id="两种-lt-lt-重载版本"><a href="#两种-lt-lt-重载版本" class="headerlink" title="两种 &lt;&lt; 重载版本"></a>两种 &lt;&lt; 重载版本</h4><blockquote><p>版本一</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Time &amp;t)&#123;<br>    os &lt;&lt; t.hours &lt;&lt; <span class="hljs-string">&quot;hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="hljs-string">&quot;minutes&quot;</span>;<br>&#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Time &amp;t);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; trip;  <span class="hljs-comment">// 可行</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Trip time: &quot;</span> &lt;&lt; trip &lt;&lt; <span class="hljs-string">&quot;(Tuesday)\n&quot;</span>;  <span class="hljs-comment">// 不可行</span><br></code></pre></td></tr></table></figure><ul><li>该函数接受一个 <code>ostream</code> 参数和一个 <code>Time</code> 参数</li><li>因为它直接访问了 <code>Time</code> 对象的私有成员，所以必须是 <code>Time</code> 类的友元</li><li>但它并不直接访问 <code>ostream</code> 对象的私有成员，所以不必是 <code>ostream</code> 类的友元</li><li><code>cout &lt;&lt; trip</code> 应使用 <code>cout</code> 对象本身，而不是它的拷贝，因此按引用传递 <code>cout</code></li></ul><blockquote><p>版本二</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Time &amp;t)&#123;<br>    os &lt;&lt; t.hours &lt;&lt; <span class="hljs-string">&quot;hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="hljs-string">&quot;minutes&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-keyword">const</span> Time &amp;t);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Trip time: &quot;</span> &lt;&lt; trip &lt;&lt; <span class="hljs-string">&quot;(Tuesday)\n&quot;</span>;<br>=&gt;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Trip time: &quot;</span><br><span class="hljs-built_in">cout</span> &lt;&lt; trip;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;(Tuesday)\n&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>cout &lt;&lt; x &lt;&lt; y;</code> 由于 <code>&lt;&lt;</code> 运算符要求左边是一个 <code>ostream</code> 对象，因此 <code>cout &lt;&lt; x</code> 也应是一个 <code>ostream</code> 对象</li><li><code>ostream</code> 类将 <code>operator&lt;&lt;()</code> 函数返回一个指向 <code>ostream</code> 对象的引用</li><li>可以对友元函数采用相同的方法，使它返回指向 <code>ostream</code> 对象的引用</li><li>函数的返回值就是传递给它的对象，因此可以连续使用 <code>&lt;&lt;</code> 运算符</li></ul><h4 id="友元函数没有-this-指针，参数的三种情况"><a href="#友元函数没有-this-指针，参数的三种情况" class="headerlink" title="友元函数没有 this 指针，参数的三种情况"></a>友元函数没有 this 指针，参数的三种情况</h4><ul><li>访问非 <code>static</code> 成员时，需要对象做参数</li><li>访问 <code>static</code> 成员或全局变量时，不需要对象做参数</li><li>若做参数的对象是全局对象，则不需要对象做参数</li><li>可以直接调用友元函数，不需要通过对象或指针</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符重载</tag>
      
      <tag>友元函数</tag>
      
      <tag>类的自动转换和强制类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象和类</title>
    <link href="/2021/01/09/C++/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
    <url>/2021/01/09/C++/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="类的基本概念"><a href="#类的基本概念" class="headerlink" title="类的基本概念"></a>类的基本概念</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><blockquote><p><code>private</code> 私有部分</p></blockquote><ul><li>数据应被封装到私有部分中，即数据隐藏</li><li>私有成员只能通过成员函数进行访问</li></ul><blockquote><p><code>public</code> 公有部分</p></blockquote><ul><li>作为公有接口的成员函数应被声明在公有部分中</li><li>类对象可以通过公有接口（成员函数）访问私有成员</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>公有接口和实现细节应分开</li><li>数据应封装到私有部分，即数据隐藏</li><li>类声明和类定义应放在不同的文件中</li></ul><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><blockquote><p>声明与定义</p></blockquote><ul><li>定义成员函数时，使用类名和作用域解析运算符 <code>::</code> 标识函数所属的类。如 <code>Stock::update() &#123;&#125;</code></li><li>在类声明中声明成员函数时，则不需要。如 <code>update()</code></li><li>类声明通常将短小的成员函数自动作为内联函数。如 <code>show() &#123;return date;&#125;</code></li></ul><blockquote><p>const 成员函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>Stock land = Stock(<span class="hljs-string">&quot;NanoSmart&quot;</span>);<br>land.show();<br></code></pre></td></tr></table></figure><p>【注】可以避免调用对象 <code>land</code> 在成员函数 <code>show()</code> 中被无意修改</p><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="作用与要点"><a href="#作用与要点" class="headerlink" title="作用与要点"></a>作用与要点</h4><blockquote><p>作用</p></blockquote><ul><li>创建对象，并为其对象的数据成员赋初值</li><li>初始化对象时，将自动调用构造函数</li></ul><blockquote><p>要点</p></blockquote><ul><li>构造函数的参数名不能与数据成员名相同</li><li>构造函数用于创建对象，而无法通过对象来调用</li><li>接受一个参数的构造函数可以使用赋值语句为创建的对象赋值</li></ul><h4 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abc</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    Abc();      <span class="hljs-comment">// 默认构造函数</span><br>    Abc(<span class="hljs-keyword">int</span> v); <span class="hljs-comment">// 构造函数重载</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123; <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; A &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br>Abc::Abc()&#123;&#125;<br>Abc::Abc(<span class="hljs-keyword">int</span> v)&#123; a = v; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>隐式调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Abc b;      <span class="hljs-comment">// 调用默认构造函数</span><br><span class="hljs-function">Abc <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 调用 Abc(int v);</span><br>b.show();   <span class="hljs-comment">// a = 0</span><br>c.show();   <span class="hljs-comment">// a = 100</span><br></code></pre></td></tr></table></figure><blockquote><p>显式调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 法 1</span><br>Abc b = Abc();<br>Abc c = Abc(<span class="hljs-number">100</span>);<br>b.show();<br>c.show();<br><span class="hljs-comment">// 法 2</span><br>Abc *b = <span class="hljs-keyword">new</span> Abc;<br>Abc *b = <span class="hljs-keyword">new</span> Abc();<br>Abc *c = <span class="hljs-keyword">new</span> Abc(<span class="hljs-number">100</span>);<br>b-&gt;show();<br>c-&gt;show();<br></code></pre></td></tr></table></figure><blockquote><p>一个参数的构造函数可以直接为创建的对象赋值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Abc b = <span class="hljs-number">100</span>;<br>b.show();<br></code></pre></td></tr></table></figure><blockquote><p>浅复制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Abc b = <span class="hljs-number">100</span>;<br>Abc c = b;<br>c.show();   <span class="hljs-comment">// a = 100, A = 1</span><br></code></pre></td></tr></table></figure><ul><li>与结构赋值一样，默认情况下，将一个对象赋给同类型的另一个对象时</li><li>源对象的数据成员的值将被逐个复制到目标对象相应的数据成员中，即浅复制</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="何时调用"><a href="#何时调用" class="headerlink" title="何时调用"></a>何时调用</h4><blockquote><p>创建的是静态存储类对象（静态全局对象、静态局部对象），其析构函数在 <code>main()</code> 结束时自动被调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abc</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> a，b；<br><span class="hljs-keyword">public</span>:<br>    Abc();      <span class="hljs-comment">// 默认构造函数</span><br>    Abc(<span class="hljs-keyword">int</span> v); <span class="hljs-comment">// 构造函数重载</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>    ~Abc();     <span class="hljs-comment">// 析构函数</span><br>&#125;;<br>Abc::Abc()&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造函数被调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    a = <span class="hljs-number">0</span>;<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br>Abc::Abc(<span class="hljs-keyword">int</span> v)&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造函数被调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    a = v;      <span class="hljs-comment">// this-&gt;a = v;</span><br>&#125;<br>Abc::~Abc()&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数被调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> Abc b = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 静态全局对象</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    b.show();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;退出 test()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数被调用</li><li>100 1</li><li>退出 test()</li><li>析构函数被调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">static</span> Abc b = <span class="hljs-number">100</span>; <span class="hljs-comment">// 静态局部对象</span><br>    b.show();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    test();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;退出 test()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数被调用</li><li>100 1</li><li>退出 test()</li><li>析构函数被调用</li></ul><blockquote><p>创建的是自动存储类对象（局部对象），其析构函数在程序执行完代码块时自动被调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    Abc b = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 局部对象</span><br>    b.show();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    test();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;退出 test()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数被调用</li><li>100 1</li><li>析构函数被调用</li><li>退出 test()</li></ul><blockquote><p>对象是通过 <code>new</code> 创建的，则它将驻留在自由存储区中；使用 <code>delete</code> 释放内存时，其析构函数自动被调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Abc *b = <span class="hljs-keyword">new</span> Abc;<br>    b-&gt;show();<br>    <span class="hljs-keyword">delete</span> b;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;退出 test()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数被调用</li><li>0 1</li><li>析构函数被调用</li><li>退出 test()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Abc *b = <span class="hljs-keyword">new</span> Abc;<br>    b-&gt;show();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;退出 test()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">delete</span> b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数被调用</li><li>0 1</li><li>退出 test()</li><li>析构函数被调用</li></ul><h2 id="数据成员常量"><a href="#数据成员常量" class="headerlink" title="数据成员常量"></a>数据成员常量</h2><h3 id="错误的类声明"><a href="#错误的类声明" class="headerlink" title="错误的类声明"></a>错误的类声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bakery</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Montes = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 只有常量在声明时可初始化</span><br>    <span class="hljs-keyword">double</span> costs[Months];   <span class="hljs-comment">// 若不要该行，则正确</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类声明只是描述了如何创建对象，并没有创建实际的对象</li><li>因此，创建对象前没有分配用于存储数据成员的内存</li></ul><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><blockquote><p>静态数据成员常量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bakery</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Months = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">double</span> costs[Months];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>静态数据成员存储在静态存储区，而不是存储在对象中</li><li>类的所有对象共享同一个静态成员。即无论创建了多少个对象，有且仅有一个静态成员</li></ul><blockquote><p>静态数据成员变量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bakery</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Months;<br>&#125;;<br><span class="hljs-keyword">int</span> Bakery::Months = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li><code>Months</code> 被类的所有对象共享，相当于类中的一个全局变量</li><li>静态数据成员变量只能在类外初始化（注意初始化格式）</li><li>不能在类中声明时初始化（只有常量可以），也不能在构造函数中初始化</li></ul><h3 id="枚举型符号常量"><a href="#枚举型符号常量" class="headerlink" title="枚举型符号常量"></a>枚举型符号常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bakery</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span> Months = <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">double</span> costs[Months];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类声明中的枚举并不会创建枚举型变量，因此也不会为其分配内存</li><li><code>Months</code> 只是一个符号常量，在类作用域中被替换为 <code>10</code></li></ul><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><blockquote><p>如何将两个要比较的对象提供给成员函数？<br>如何将方法的答案传回给调用程序？</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Stock &amp;<span class="hljs-title">maxVal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Stock &amp;s)</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>maxVal()</code> 隐式地访问一个对象，而显式地访问另一个对象，并返回其中一个对象的引用</li><li>括号中的 const 表明，不会修改被显式地访问的对象</li><li>括号后的 const 表明，不会修改被隐式地访问的对象</li><li>由于该函数返回了两个 const 对象之一的引用，因此返回类型也应为 const 引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Stock &amp;<span class="hljs-title">Stock::maxVal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Stock &amp;s)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.val &gt; val)    <span class="hljs-comment">// val == this-&gt;val</span><br>        <span class="hljs-keyword">return</span> s;      <span class="hljs-comment">// 参数对象（显式）</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 调用对象（隐式）</span><br>&#125;<br>stock1.topval(stock2); <span class="hljs-comment">// s 是 stock2 的引用，*this 是 stock1 的引用</span><br></code></pre></td></tr></table></figure><ul><li><code>this</code> 指针指向调用对象，可通过 <code>*this</code> 引用调用对象</li><li>每个成员函数（包括构造函数和析构函数）都有一个 <code>this</code> 指针</li><li>友元函数不是成员函数，因此没有 <code>this</code> 指针</li><li>在函数的括号后面使用 const 限定符将 <code>this</code> 限定为 const，故不能使用 <code>this</code> 修改对象的值</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类</tag>
      
      <tag>对象</tag>
      
      <tag>构造函数</tag>
      
      <tag>析构函数</tag>
      
      <tag>this 指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态内存分配</title>
    <link href="/2021/01/06/C++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2021/01/06/C++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ul><li>堆：操作系统维护的一块特殊内存。用户可以使用 <code>malloc()</code> 实现动态内存分配，但需使用 <code>free()</code> 手动释放，从而避免内存泄露。程序运行结束时自动释放</li><li>栈：由系统自动分配，存放局部变量。函数结束后，自动释放该变量的内存</li><li>自由存储区：C++ 基于 <code>new</code> 的一个抽象概念，凡是通过 <code>new</code> 申请的内存，都称为自由存储区</li><li>全局（静态）存储区：存放全局变量，静态变量 <code>static</code></li><li>常量存储区：存放常量（不能被修改）</li></ul><h2 id="静态变量-static"><a href="#静态变量-static" class="headerlink" title="静态变量 static"></a>静态变量 static</h2><h3 id="static-的作用"><a href="#static-的作用" class="headerlink" title="static 的作用"></a>static 的作用</h3><ul><li><code>static</code> 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量。未初始化时自动初始化为 0</li><li><code>static</code> 修饰的静态局部变量只执行初始化一次，直到程序运行结束以后才释放</li><li><code>static</code> 修饰的静态全局变量只能在本文件中被访问，不能被其它文件访问，即使是 <code>extern</code> 外部声明也不可以</li><li><code>static</code> 修饰的函数只能在本文件中调用，不能被其他文件调</li><li>数据安全性：使用全局变量时应该先考虑使用 <code>static</code>，类静态成员变量更能体现封装性</li></ul><h3 id="全局变量和全局静态变量的区别"><a href="#全局变量和全局静态变量的区别" class="headerlink" title="全局变量和全局静态变量的区别"></a>全局变量和全局静态变量的区别</h3><ul><li>全局变量的作用域是整个工程，在一个文件内定义的全局变量，在头文件中通过 <code>extern</code> 全局变量名的声明可以使用全局变量</li><li>全局静态变量的作用域是声明此变量所在的文件，其他的文件即使用 <code>extern</code> 声明也不能使用</li></ul><h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><ul><li>该变量在全局数据区分配内存</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化一次（若没有显式初始化，则被自动初始化为 0）</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域</li></ul><h2 id="new-与-malloc-的区别"><a href="#new-与-malloc-的区别" class="headerlink" title="new 与 malloc() 的区别"></a>new 与 malloc() 的区别</h2><blockquote><p>属性</p></blockquote><ul><li><code>new</code> 是 C++ 关键字，也是运算符，可以通过 <code>operator new()</code> 实现运算符重载</li><li><code>malloc()</code> 是 C 语言库函数</li></ul><blockquote><p>申请的内存位置</p></blockquote><ul><li><code>new</code> 在自由存储区中进行动态内存分配，<code>malloc()</code> 在堆中进行动态内存分配</li><li>自由存储区不仅可以是堆（默认），还可以是静态存储区。可以通过重载 <code>operator new()</code> 实现</li><li><code>new</code> 可以通过 <code>malloc()</code> 实现，而 <code>malloc()</code> 不能通过 <code>new</code> 实现</li></ul><blockquote><p>内存分配失败时的返回值</p></blockquote><ul><li><code>new</code> 申请内存失败时，默认返回 <code>bac_alloc</code> 异常</li><li><code>malloc()</code> 申请内存失败时，返回 <code>NULL</code></li></ul><blockquote><p>是否需要指定内存大小</p></blockquote><ul><li>使用 <code>new</code> 申请内存时无须指定内存大小，编译器会根据类型信息自行计算</li><li><code>malloc()</code> 需要显式地指出所需内存大小</li></ul><blockquote><p>返回类型安全性</p></blockquote><ul><li><code>new</code> 申请内存成功时，返回指向对象的指针，指针类型与对象类型匹配，无需类型转换</li><li><code>malloc()</code> 申请内存成功时，返回 <code>void *</code> 指针 ，需将 <code>void *</code> 指针强制转换为所需类型</li></ul><blockquote><p>是否调用构造函数/析构函数</p></blockquote><p>使用 <code>new</code> 申请内存时的 3 个步骤：</p><ul><li>调用 <code>operator new()</code> 函数分配一块所需大小的内存</li><li>调用构造函数以构造对象，并为对象赋初值（未初始化则不用）</li><li>对象构造完成后，返回一个指向该对象的指针</li></ul><p>使用 <code>delete</code> 释放对象内存时的 2 个步骤：</p><ul><li>调用对象的析构函数</li><li>调用 <code>operator delete()</code> 函数释放内存</li></ul><blockquote><p><code>new[]</code> 和 <code>delete[]</code> 处理数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;      <span class="hljs-comment">// 构造一个未初始化的对象，并让指针 a 指向该对象</span><br><span class="hljs-keyword">int</span> *b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">3</span>);   <span class="hljs-comment">// 构造一个初值为 3 的对象，并让指针 b 指向该对象</span><br><span class="hljs-keyword">int</span> *c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];   <span class="hljs-comment">// 构造一个 c[3] 的数组</span><br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-keyword">delete</span> b;<br><span class="hljs-keyword">delete</span>[] c;<br><span class="hljs-keyword">int</span> *d = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><span class="hljs-built_in">free</span>(d);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>new</tag>
      
      <tag>malloc()</tag>
      
      <tag>堆</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2021/01/06/C++/%E5%87%BD%E6%95%B0/"/>
    <url>/2021/01/06/C++/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> &amp;b = a;<br><span class="hljs-keyword">int</span> *c = &amp;a;<br></code></pre></td></tr></table></figure><ul><li>必须在声明引用变量时初始化，即不能这样声明：<code>int &amp;b; b = a;</code></li><li>引用变量只能指向变量，不能指向表达式，即不允许出现 <code>&amp;b = a + 1；</code></li><li>引用变量 <code>b</code> 是 <code>a</code> 的别名，它们的值和地址都相同，即 <code>a = b = *c，&amp;a = &amp;b = c;</code></li></ul><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><h4 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span></span>&#123;<br>    a *= a * a;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-keyword">double</span> b = cuba(<span class="hljs-number">2.5</span>);<br></code></pre></td></tr></table></figure><ul><li>形参 <code>a</code> 是实参 <code>2.5</code> 的副本</li><li>返回值 <code>a</code> 是一个临时变量，将值赋给 <code>b</code> 后就会被销毁</li></ul><h4 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">refcube</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;ra)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> ra * ra * ra;<br>&#125;<br><span class="hljs-keyword">double</span> ra = <span class="hljs-number">2.0</span>;<br><span class="hljs-keyword">double</span> rb = refcube(ra);<br></code></pre></td></tr></table></figure><ul><li>形参 <code>ra</code> 不是实参 <code>2.0</code> 的副本，而是一个指向实参的引用，因此省去了复制实参的额外开销</li><li><code>refcube()</code> 不必修改 <code>ra</code> 的值，因此可以将引用变量 <code>ra</code> 声明为 const 常量</li><li>这样，既可以避免在函数中无意修改 <code>ra</code> 的值，同时引用常量可以指向 const 实参和非 const 实参，更具通用性</li></ul><h4 id="const-引用参数，临时变量"><a href="#const-引用参数，临时变量" class="headerlink" title="const 引用参数，临时变量"></a>const 引用参数，临时变量</h4><blockquote><p>何时创建临时变量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> side = <span class="hljs-number">3.0</span>;<br><span class="hljs-keyword">double</span> *pd = &amp;side;<br><span class="hljs-keyword">double</span> &amp;rd = side;<br><span class="hljs-keyword">long</span> edge = <span class="hljs-number">5L</span>;<br><span class="hljs-keyword">double</span> lens[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">12.0</span>&#125;;<br><span class="hljs-keyword">double</span> c1 = refcube(side);          <span class="hljs-comment">// ra -&gt; 变量 side</span><br><span class="hljs-keyword">double</span> c2 = refcube(lens[<span class="hljs-number">2</span>]);       <span class="hljs-comment">// ra -&gt; 数组元素 lens[2]</span><br><span class="hljs-keyword">double</span> c3 = refcube(rd);            <span class="hljs-comment">// ra -&gt; 引用 rd</span><br><span class="hljs-keyword">double</span> c4 = refcube(*pd);           <span class="hljs-comment">// ra -&gt; 解引用的指针</span><br><span class="hljs-keyword">double</span> c5 = refcube(edge);          <span class="hljs-comment">// ra -&gt; 值为 double(edge) 的临时变量</span><br><span class="hljs-keyword">double</span> c6 = refcube(<span class="hljs-number">7.0</span>);           <span class="hljs-comment">// ra -&gt; 值为 7.0 的临时变量</span><br><span class="hljs-keyword">double</span> c7 = refcube(side + <span class="hljs-number">10.0</span>);   <span class="hljs-comment">// ra -&gt; 值为 side + 10.0 的临时变量</span><br></code></pre></td></tr></table></figure><p>若引用参数为 const，则将在下面两种情况下生成临时变量，并让引用参数指向该临时变量</p><ul><li>实参的类型正确，但不是左值（如常量 <code>7.0</code>，多项式 <code>side + 10.0</code>）</li><li>实参的类型不正确，但可以转换为正确的类型（如 <code>edge</code>）</li></ul><blockquote><p>const 引用参数的作用</p></blockquote><ul><li>使用 const 可以避免无意中修改数据</li><li>使用 const 使函数能够接受 const 和非 const 实参，否则只能接受非 const 实参</li><li>使用 const 引用使函数能够正确生成并使用临时变量</li></ul><h3 id="用于结构"><a href="#用于结构" class="headerlink" title="用于结构"></a>用于结构</h3><blockquote><p>返回引用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FreeThrows &amp;<span class="hljs-title">accumulate</span><span class="hljs-params">(FreeThrows &amp;tar, <span class="hljs-keyword">const</span> FreeThrows &amp;src)</span></span>&#123;<br>    tar.attempts += src.attempts;<br>    tar.made += src.made;<br>    set_perc(tar);<br>    <span class="hljs-keyword">return</span> tar;<br>&#125;<br>display(accumulate(team, two));<br></code></pre></td></tr></table></figure><ul><li>若返回类型为 <code>FreeThrows</code>，则返回 <code>tar</code> 的拷贝</li><li>若返回引用 <code>FreeThrows &amp;</code>，则返回 <code>tar</code> 本身，即 <code>accumulate()</code> 的实参 <code>team</code></li><li>因此，返回引用的 <code>accumulate()</code> 实际上就是被引用的实参 <code>team</code></li></ul><blockquote><p>避免返回指向临时变量或局部变量的引用/指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> FreeThrows &amp;<span class="hljs-title">clone</span><span class="hljs-params">(FreeThrows &amp;ft)</span></span>&#123;<br>    FreeThrows newguy;<br>    nuwguy = ft;<br>    <span class="hljs-keyword">return</span> newguy;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>newguy</code> 是一个局部变量，也是一个临时变量</li><li>当 <code>clone()</code> 被调用后，该临时变量就会被销毁【引用一个被销毁的临时变量是危险的】</li></ul><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><blockquote><p>只传值不修改</p></blockquote><ul><li>如果数据对象很小，则按值传递，如内置数据类型或小型结构</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为 const</li><li>如果数据对象是较大的结构，则使用 const 引用或 const 指针，以提高效率</li><li>如果数据对象是类对象，则使用 const 引用，因为传递类对象参数的标准方式是按引用传递</li></ul><blockquote><p>修改参数值</p></blockquote><ul><li>如果数据对象是内置数据类型，则使用指针</li><li>如果数据对象是数组，则只能使用指针</li><li>如果数据对象是结构，则使用引用或指针</li><li>如果数据对象是类对象，则使用引用</li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="函数特征标（参数列表）"><a href="#函数特征标（参数列表）" class="headerlink" title="函数特征标（参数列表）"></a>函数特征标（参数列表）</h3><ul><li>作用：使用相同的函数名，调用不同的函数版本</li><li>若多个函数的参数数目、类型和排列顺序都相同，则它们的特征标相同</li><li>若某个函数存在多个版本，它们的函数名相同，但函数特征标（参数列表）不同，则该函数被重载</li></ul><h3 id="重载判别"><a href="#重载判别" class="headerlink" title="重载判别"></a>重载判别</h3><blockquote><p>特征标不同，但不是函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-keyword">double</span> &amp;x)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>const、非 const 参数是函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dribble</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *bits)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dribble</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cbits)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>特征标相同，返回类型不同，不是函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> m)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> m)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="常规模板"><a href="#常规模板" class="headerlink" title="常规模板"></a>常规模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>&#123;<br>    T tmp;<br>    tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;, T &amp;)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>关键字 <code>template，typename</code> 在原型和定义中都是必需的</li><li>也可以使用关键字 <code>class</code> 代替 <code>typename</code></li><li>函数模板并不创建任何函数，只是告诉编译器如何定义函数</li></ul><h3 id="显式具体化模板"><a href="#显式具体化模板" class="headerlink" title="显式具体化模板"></a>显式具体化模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>];<br>    <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">floor</span>;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">void</span> swap&lt;job&gt;(job &amp;j1, job &amp;j2)&#123;<br>    <span class="hljs-keyword">double</span> t1;<br>    <span class="hljs-keyword">int</span> t2;<br>    t1 = j1.salary;<br>    j1.salary = j2.salary;<br>    j2.salary = t1;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">void</span> swap&lt;job&gt;(job &amp;, job &amp;);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> u, v;<br>job a, b;<br>swap(u, v);  <span class="hljs-comment">// swap(T &amp;, T &amp;)</span><br>swap(a, b);  <span class="hljs-comment">// swap&lt;job&gt;(job &amp;, job &amp;)</span><br></code></pre></td></tr></table></figure><ul><li>相同的函数名，可以有非模板函数、模板函数、显式具体化模板函数及它们的重载版本</li><li>优先级：非模板函数 &gt; 显式具体化模板 &gt; 常规模板</li><li>显式具体化模板的原型和定义都应以 <code>template&lt;&gt;</code> 打头，模板参数 <code>&lt;job&gt;</code> 可省</li><li>即可以将原型声明为 <code>template&lt;&gt; void swap(job &amp;, job &amp;)</code>，其定义亦是如此</li></ul><h3 id="显式实例化模板"><a href="#显式实例化模板" class="headerlink" title="显式实例化模板"></a>显式实例化模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;, T &amp;)</span>:   <span class="hljs-comment">// 常规模板</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">void</span> swap&lt;job&gt;<span class="hljs-params">(job &amp;, job &amp;)</span>:    <span class="hljs-comment">// 显式具体化</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(job &amp;, job &amp;)</span></span>;<br><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> swap&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-keyword">char</span> &amp;, <span class="hljs-keyword">char</span> &amp;);   <span class="hljs-comment">// 显示实例化</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> u, v;<br>job a, b;<br><span class="hljs-keyword">char</span> c, d;<br>swap(u, v);     <span class="hljs-comment">// swap(T &amp;, T &amp;)</span><br>swap(a, b);     <span class="hljs-comment">// swap&lt;job&gt;(job &amp;, job &amp;)</span><br>swap(c, d);     <span class="hljs-comment">// swap&lt;char&gt;(char &amp;, char &amp;)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>引用</tag>
      
      <tag>const</tag>
      
      <tag>函数重载</tag>
      
      <tag>函数模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2021/01/04/C++/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2021/01/04/C++/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="关键字-struct-与-typedef"><a href="#关键字-struct-与-typedef" class="headerlink" title="关键字 struct 与 typedef"></a>关键字 struct 与 typedef</h2><p>关键字 <code>struct</code> 建立结构声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表的结点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; p, q;<br></code></pre></td></tr></table></figure><ul><li><code>Node</code> 是结构声明的标记名，可省。<code>p</code> 和 <code>q</code> 是结构变量</li><li>该声明并未创建实际的数据对象，只描述了该对象由什么组成</li><li>结构声明中，用一对花括号括起来的是结构成员变量，每个成员变量都有自己的类型</li></ul><p>关键字 <code>typedef</code> 为结构声明 <code>Node</code> 创建别名 <code>LNode</code> 和 <code>*LinkList</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; LNode, *LinkList;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>;</span><br>LNode *q;<br>LinkList L;<br>L = <span class="hljs-keyword">new</span> LNode;<br></code></pre></td></tr></table></figure><ul><li><code>LNode</code> 与 <code>struct Node</code> 等价</li><li><code>LNode</code> 是普通类型，<code>LinkList</code> 是指针类型，声明结构变量时不同</li></ul><h2 id="通过结构变量访问成员变量"><a href="#通过结构变量访问成员变量" class="headerlink" title="通过结构变量访问成员变量"></a>通过结构变量访问成员变量</h2><blockquote><p>结构指针-&gt;成员成员 = 成员成员<br>结构指针-&gt;成员指针 = 成员指针<br>结构变量.成员成员 = 成员成员<br>结构变量.成员指针 = 成员指针</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>struct</tag>
      
      <tag>typedef</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组与指针</title>
    <link href="/2021/01/03/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <url>/2021/01/03/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> a[N] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>【注】不能把一个数组赋值给另一个数组</p><h2 id="指针的基本操作"><a href="#指针的基本操作" class="headerlink" title="指针的基本操作"></a>指针的基本操作</h2><ul><li><code>int *p = a; int *p = &amp;a[0]</code> p 指向 a[0] 的地址</li><li><code>int *p = q</code> 指针 p 指向指针 q</li><li><code>*p = 1</code> p 指向的地址的值为 1</li><li><code>*p++</code> 先取出 *p，再让 p++</li><li><code>*++p</code> 先让 p++，再取出 *p</li></ul><h2 id="函数原型与函数定义"><a href="#函数原型与函数定义" class="headerlink" title="函数原型与函数定义"></a>函数原型与函数定义</h2><blockquote><p>函数原型【可以】省略参数名</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [], <span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>int *ar</code> 和 <code>int ar[]</code> 都表示 <code>ar</code> 是一个指向 <code>int</code> 的指针</li><li>只有在函数原型中，才可以用 <code>int ar[]</code> 代替 <code>int *ar</code></li></ul><blockquote><p>函数定义【不能】省略参数名</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><blockquote><p>使用 const 保护数组的数据不被修改</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>指向 const 的指针【不能】修改其指向的地址的值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pd = rates; <span class="hljs-comment">// pd 指向数组的首元素</span><br>*pd = <span class="hljs-number">29.89</span>;              <span class="hljs-comment">// 不允许 -&gt; 因为 pd 是指向 const 的指针</span><br>pd[<span class="hljs-number">2</span>] = <span class="hljs-number">222.22</span>;           <span class="hljs-comment">// 不允许</span><br>rates[<span class="hljs-number">0</span>] = <span class="hljs-number">99.99</span>;         <span class="hljs-comment">// 允许 -&gt; 因为 rates 未被 const 限定</span><br></code></pre></td></tr></table></figure><blockquote><p>指向 const 的指针【可以】指向 const / 非 const 变量的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// 允许</span><br>pc = locked;              <span class="hljs-comment">// 允许</span><br>pc = &amp;rates[<span class="hljs-number">3</span>];           <span class="hljs-comment">// 允许</span><br></code></pre></td></tr></table></figure><blockquote><p>普通指针【只能】指向非 const 变量的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// 允许</span><br>pc = locked;        <span class="hljs-comment">// 不允许</span><br>pc = &amp;rates[<span class="hljs-number">3</span>];     <span class="hljs-comment">// 允许</span><br></code></pre></td></tr></table></figure><blockquote><p>声明并初始化一个不能指向别处的 const 指针【关键是 const 的位置】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pc = rates; <span class="hljs-comment">// pc 是一个不能指向别处的 const 指针</span><br>pc = &amp;rates[<span class="hljs-number">2</span>];           <span class="hljs-comment">// 不允许</span><br>*pc = <span class="hljs-number">92.99</span>;              <span class="hljs-comment">// 允许</span><br></code></pre></td></tr></table></figure><blockquote><p>双 const 指针既不能修改其指向的地址，也不能修改其指向的地址的值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> * <span class="hljs-keyword">const</span> pc = rates;<br>pc = &amp;rates[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 不允许</span><br>*pc = <span class="hljs-number">92.99</span>;    <span class="hljs-comment">// 不允许</span><br></code></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">int</span> a[][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span> (*a)[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><ul><li><code>a == &amp;a[0]</code></li><li><code>a + 1 == &amp;a[1]</code></li><li><code>a[0] == *a == &amp;a[0][0]</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>const</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
